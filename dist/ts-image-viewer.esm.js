/**
 * MIT License
 *
 * Copyright (c) 2021-present yermolim
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import { Vec2, Mat3, getDistance2D } from 'mathador';
import { v4 } from 'uuid';

var img$o = "data:image/png;base64,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";

var img$n = "data:image/png;base64,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";

var img$m = "data:image/png;base64,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";

var img$l = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/4yOikYAKilikULFIICiIpUTQRi1iBF/NZpNNhDyW3QQJtoKNRcBCtPFV+A+0FWwVBEERRGz8A74aCeudJJAgcZbZ+3FmzmXmDLjmUnrabglCOpOzwrMh3/LKqs/9RgttdOOmT9Ntc35xJsK/4/uBJlXvA6rX//sajs5Y3NahqV14QjetnPCU8NxmzlS8K9yrJ7WY8LGw35IDCt8oPVrhV8WJCn8qtiLhaXCpnr5EHUfrWE9aaeFR4aF0Kq9Xz6Nu4olnlhalDsgcxCbMLCF8RMmzQYocAakZyayxL1j2LZAVjy5/kwKWOBIkxesXNS9d41IN0ePypSio3P/maRvjY5XunhC0vjjOxzC496BUdJyfE8cpnULzM1xlav6s5DT5JXqxpg0dgXcbLq5rWnQfLneg/8nULK0sNct0GQa8n0PXCvTcQcdaJavqOmePENmSJ7qFg0MYkf3e9V+kTWfgP9nSuwAAAAlwSFlzAAALEwAACxMBAJqcGAAACLpJREFUeNrlW1tsU2Uc/76vl5HZjZ1e2Ea4GRZwvhD0AYHxJg9cAxEeSAj6sokCoqAmPBATo4kSCTgkBEi88kCUBBUlQ964yBIUeGOBcQkmk+HabmwTurbn8/dv2nL6tT29nq7ML+nanXN6zve//3///7+cWbx8Pl9TNBpdLDmfJxlr5br+rBSikem6JoSYRNfouh5iQgRxrh/n7nDGrnMpr+H87wMDA39buT9uxU3dbvcCvK3TOV8uGHu+lHuBOT1gxGmp6yeCwWA3DsmqZACIroeU27HRDmx4jhWMxb1vQlOOgCtHwYyhqmCApmmTsamdEMt2SLveCsIDfj9zezxGrRjmQnTqkchnQ0NDg+PFAK55ve2w248Y5z4zLYbkroJJ5/G5B1rSI8Phe/ALwyNNTcN0gev+/TqbzVbHHY4Z2NBcJmUrqFwCIufjtDC5t19nbPeg33+YnlMxBtT7fLPtuv41PrZluSQMIrqklMcgrbOQUrCY50yePLkBjFmK+2wEM5bhkCPLpZcE56/CYd60nAGQ+gYZjR6GnddlOB2EKXSGQ6EvRkZGBsppBi6Xy+t0Ot+Etm0nl5PBWY5CyzZDG45ZxQAOR7cHG3g3w8MfQQKfcM73+f3+YYvDqgvm87Yu5S4IoTbNUTK2P+j378zXJPJlgBNOiDi7Pt01y9PY0Fao+R1WwQXzmAXzOACBrMzAhJNBTdvAentD5WCAE5I/iQctV46Pgfj3AoFAJxvH5fF4tsBH7MX+apRTXQFNW5OLCbkYICD546rkofL3bUKshrpfLjSUW+WbGjStDybRrOQNPyJfeMXMHESO5OZTlXjctFc6HIsLIF4aXqyI7+T1vcFgcCoEcyOFi0Ks0TyefaYSNvP2qsMj4h0OR9vQgwe3LSA6n/uZrhqnc0kaExh7C4LcVJCqUZwXkQiBEZdR7UnyeRJv9eJmzhGSv4i9TzWGSLvN9gLyhBv5aACnJMdIPDk82PyqHMTnK3Ge41WSL0E0ugtiV8FBJ50faHkmIuU3megVGVS/PS3Dg7eHzf9RgtQLITDfa2U2AUDSV4BEdyiEvoSI8YapKhGwgfr04qPXGOcR6lYUSTwvow8we4bM9EzQ8xPoWW3EVdFIpMWYmqdqAFCdkXjK8CjJKWJjnJW31mB2P2ny/zbQ8K8xsCF5ej+jCcTwPCBtykmktyYZnqxkkaWYeyMHuAcaPk6FpnIrgaw0BlAxQ8HzQcrtCyCeW0x8UUxA2P6cYLPBIbqE3d6RzgBd71Ao7LQa2FjgD9JWf3//KPzYfgW9tScYyZM1PM67DZdExkKh5iyQVlZY7UtOpevq6jwOp7OPcI1B4G0wkYsJDVinhL2uKiS+6DU8POwHwacVh78+aQK6gvSArr6rUlqK9jPwZ8cUM4iFdh6r2+u6sfauI1Z6M5SxnkrpG6McuBDAR5tB0tMFNS0UwHOt2BpeNS8kcw+Bif9UDi8U1LFRbOOcVZh9vBfs/UKKsDmfL6hdpVzXM04Iz/oQouvXFT/QKqhXp3Clh03c1aM4xlki1qg0MiAcvldB9ZeV1C5Et7+UtLiRNGAKAEPyIHVsxiGpqQgTqKWmaIBPAC46kR8nDybaVeOQ0VnOhIcPH44oGmEX7H++BOwgbDQBalSOE6KzPKzW19e7FBMICfx9YDQB6tJWMK2taE6h9jNhAgFygv0pu3I4ZjwNuX2ReGC6UvDppzB4R9nR3HJj8qpBUpzPVTTgrqCBJCVYtk6EtDfLalUY0iNoGksJlm0T1eMD9rcpGnCVe73eZkSCPsPxaBwOD050OAxsMFPQHB6NohmutdFYygRUgJeVWsCtWNU4Hh5OK6qxMU9pPzXOECBvo/L/r3GIHFOFEymUCrGMZnImiuiRALkhvRUKA04kGUATmLEhxCfLERtImiBaYLfbNzNDRRgqfntwYOBCkgExImgCMzVGbKeBpBLATVWs5ubmWtDyjiL9I4k9C0P4O6rARTdNYxXg+auSCY/Hxrax1H7nqB6JJIWdZADN3tL4qVIw2NXQ0DDzaWUCQt80mPZuJf09mLU7DM7sZal9tFq8DhRYFaoaJkDVO2k4wnBoMBwO70lhiPEf4gzN3iq+YBWNohXBhHIyouD7aV5vBza3VknzP6AuUS4CaDSOPORCwxdD4OQimrwoUuq8BMILvk+DzzePRSLdiR9kxG3/8mAwSDRFs2pA4loaPI7N3j7RgppINHqKBpCKJLCQqbGSJsw0TZsBan9RiH9kE2KTSnw2BrDY1LUQm5ViwlQ4yTONjY1TSsT2Mser6OVqavLhBmdA1DTF8W3x+/0Zy/1Za4I0dU2DxwoT5oTGxs6baMK4ASSSvD0UOoc9PpfCbV0/GAgEvip2s0LzeE6ozgQq1SdttpVDAwNXK5Qk8Zw2T2qvSB6+6xSIX5tJ9XNqQILW2NQ1Y12qOdh0/VJDhrEzE9PgBRKc1/fI28ccnkI8otlvAbd7vRnx+atrS0uN5vcfp9nbNPHq+s9420bQsuJJDuJ8WqhLSJ6Iz2Nc3pbX0wKB6OPHj3+YVFur4YEL1Dob4PPrtbW1hLqujI6Ohq3O7R01NTvwzO+F2tmO2zyE8Rr2HC7ZtrJwfhNS5EOZfq0RyyKl3I9s65CacJQD0gLVkcltz/QjrfivVrbC5r8sm3PJtrxe75yIlN8KRRsMa4xmcuJjKWdpOKGY5yADrYOkl1IxI47nnRkdFZIcivPZQp0VGVrMF9LsLVz8hyzDj5gMK0qTGTScEO/P91CXlpBnoldHHRtqWlDdPl66bqUCJr7zIsF5k3sPUnoLBh/M5ewsi9nICTQaP6UJTGXC3LJFWSqhOgI2pZpa2ZIWGj+lCUwuZQdsdLY18E7epmIG4flyzTFZkbVxZGWLYnN4ur4CobOlRKJvUQGTanjxMlZ1/njaLF4TsqSBJJrJobEUmszAuxu+oCYeSuFT5T/Uq6N2FXVsqGmBU91W5xf/AaUAHXpt/nz4AAAAAElFTkSuQmCC";

var img$k = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/4yOikYAKilikULFIICiIpUTQRi1iBF/NZpNNhDyW3QQJtoKNRcBCtPFV+A+0FWwVBEERRGz8A74aCeudJJAgcZbZ+3FmzmXmDLjmUnrabglCOpOzwrMh3/LKqs/9RgttdOOmT9Ntc35xJsK/4/uBJlXvA6rX//sajs5Y3NahqV14QjetnPCU8NxmzlS8K9yrJ7WY8LGw35IDCt8oPVrhV8WJCn8qtiLhaXCpnr5EHUfrWE9aaeFR4aF0Kq9Xz6Nu4olnlhalDsgcxCbMLCF8RMmzQYocAakZyayxL1j2LZAVjy5/kwKWOBIkxesXNS9d41IN0ePypSio3P/maRvjY5XunhC0vjjOxzC496BUdJyfE8cpnULzM1xlav6s5DT5JXqxpg0dgXcbLq5rWnQfLneg/8nULK0sNct0GQa8n0PXCvTcQcdaJavqOmePENmSJ7qFg0MYkf3e9V+kTWfgP9nSuwAAAAlwSFlzAAALEwAACxMBAJqcGAAACQFJREFUeNrlW2tsHMUdn5nbuwv4dXd7ju2IUh4BbAmpBAQyjfnWSJQQSqREAslKK6QY0jwoBSIqFRBCFS1tRBKSUiUfWmgkRBMEgiRA+QaBgNoS+FKHEN6oiXOPtc8Hie8xw2+ud2Z2vPf07tk+Rjrfend2d37/x+///8/MUeJxi0ajfZzzHwtKrxKEDFDOLxaM9RDOw4yxoOyD6+cIYxaujeHap5SQUSrEBz6f761YLHbay/FRL54ZDocHKWNrAOwmgOyfzcM4If9lQhzG4YFkMvnuvBUAQHdBi+uhzhGAv8wLbUGgJ/DsPbCOvRBGal4IoKurK8QM4z7B+RZou6N0PplIkIhpemK2sIoUBr4DEtlmWdbEXAmAhUzzTkbIoziuhJRDOMdgHW8SSkfBAx+KbPaLfD4/me7tnZQd2k+f7oC/d1C//0JoV7pMP8DdAG0vk+8p+2QhYuCM31rx+F75X9MEAGK7jAvxNA6vL9MlC9CvUEr3AejrExMT4w1alyTKFXjOMIR3I075y3Q9kmPsF6lY7GPPBQCtD0M7f8HA2hwuJ6GVHZlM5s/pdDruptm3t7dH/cHgJgx4i6QcB36YpD7fnbCGZ70SAAub5jbc8CuHl3/DKH0MZrwdYSvtZdgyTbNDCHEPLPABKOE8B7f4Ewhya60uUZsAli4Nhi3rWXRe7fDCgzDzzTDzz0gTG9zjYgh8F1zjJofL+0HCw/jOzF4AAB+xrBdxdKMGfAq+eW8ikdhN5rBFIpEtEMIfcRjQxncYlrC6mhBoVbMPh58HG9+qmfypccta0sB4hRfcBLe4Ns/5S3CJXgdLuO3/kbMMwIrJjWk+4QD+RB3ghfYhDdxXtcEK/yX8/uWIPCe1S2thIX+oqOEKprWuyLg28MFA4IY6ALjRahLGxJkzn/j9/qEZQqD0vnA0entdpoY4f3kun39PDXUA/z88fHkVshNNcPuK7tG1ePElNJt9S3UHjD3NDeMqpzzByQJYDkmOLc6D8Ayfb5VL4GmVz6ysS1qCj7FVKvkBS7vB+d+cns8cCGUDTg7aTJ/SX8fj8fcqDEDUAZq41FdU4IR/Q2n3a6eH4ArrK5qTTD19hiF9KDL9FrArCo6flXkxrQKeusgDdb8DPHZIyxPiwLNULaBsFoDEYqsKXmZ4+NpcYSCiihbd9Htar3CQoG0ChrMqvcEf7nV0AVnWIr3cZLtI6e8grS/mwSRLtWc7CgGc9Skw/F7reDcso3OGAFDTj0iyUF0JYWXHPAJfzRochYBs9Ql8WQrgTkHpel0AFPa+Xkslt4+NjX3tUabXtAZCnMSgdtoGyfmITWNId5cj4zui9MlkM5klk5OTiWaksi6TI3UqpQPB4CkcGoqCB+UcIysGyrWahA47gJ+PrSZXKMxNCPGqdnrNdy7A+UrNb/Z5wNZz2oQQf9dym0J4pGDEC4D4SzV6oHfErVnX+eIKxRwnrhI/MsY+ps/roW78zwIDX1NDSLTg2u9recJyhpCwTEsMjixAfLW5HWNv2MyG0h8x+P+ARoCjLaJ0J7c4rnUYQKJEL6rUqZUaNG7DJtcpGdLfHo0tv2yylkSz3EAuyNj+Z6xHWkC3NuszOQcm2pQMUq5GKTilBSxm0LihdkqlUuk58k/PhVBaiitOkhBkvwFGvudNusCUeqKzs7N9jsKW5xmkXIRVXQD8l5UukLSHyu+WuJsohKakz3IFWnUBZMBnGExgTKsDftDkBKZptYNcftfC4Ji0gM80AVzRQomPLu0rtDAoZ4yonvgMtAi/UYeScEDrMCot4JhWJg61LOVzbsNGhXhf7ui6EPHw8+9BORwqlsM+JQQuYYVZXyHUJSPZ4SetpnxEgBUqeITB4/F4/BQrFgmHtKJhuJW0X6xxhrVwf5iUZkcA+IB290okRJFW0b6cFIWb/1Qr+w9MC2A8Hj8CEX2iXA8YhnFXq2g/EAj8kig7zAD+I7j+O9MCKFgIpXvsj6H39PX1nb+Q475s3d3d7cBytzYztKd0/3QxxHO5PSAGdSEkei6T2bzAwFOHEljuaovYyn3O907LonQgJw0RFnZrfvJgYdZ4gYIPhUI/RMHzG1snxnaWXR3OZrOPS0pQmLINrrFzIYIvjv9JfFQ3TsDSt9n6qP8UVoOEeFh78upwNDrSwECFy8DrAm+a5kb4/ipbIkjIg9LSq93sC4XDRyG5axW/OUcMY3A8FvugQU1Rj4iu3B6nqzHmtyGAoHL6aDKRGCLaljmnGaG8j7F16sYCCGMRpHBQps2z1KBwsa8jeKS8F+Xy+ZdV8JLcwW8/Jw77BR2nxBKJxHHcsFHreAFG9Fp7b2+3S+Zc7tPwHEJPT89ikNxrUNgSjQzuQtr7kSNPlHsLiqG/Igrs1kil35iaemMWluB+iatofiqTeRNjvFyT9vbxRGJf3Q8s8QHC4AsOZPIVpHFzDZwgvAQ9DT4aXUbz+YO65vHyF6xEYg1pdKus5INkJLIWd/9TdweSy71TQ3Sodw+g030VW8g0N/g4PzrD7Al51QqHb68EvnZ2ljvGk8n9uiWUpEyF2AKX+aqZvlB0wyfh87fMGBPnL1qmeRs5eXKqaplc09uSyfzZs2f/sWjRIpNSep0mwQFkWyPntbXxcCh0LJ1OZ70EDqJrCwaD90Pwz0HrVzooZKeVTN6BMedc8S+9gRPuAOBdZX6tEcPfHblc7qlUKpV0E3hHR4fp9/s3wAplbm/OnO0q/GplAyzxGVcJpkyW1Z/n/Bk1WdJaBpo4BNfYB4t5Xe7UauQ9xf18K+RkBkxdbmkJOE71EfKuQek6hLoTrjNslQgh081HJBdV6JeTu06YEHLjxSjAfChXoGVVVlqHlKtRckGmuCbRD7ADuGcIZHtNFTdNAsBDEPBT1cjOCwGoprkVbrGxzC/JXG9y+zvMfRdK3cf13L7pAlASkbDcbQqzH4FVXOJNLSg+lhM3cu6i0d8ieiYA9ZmhaHQIgliDz0oI49JZYZa/AGHsENS+H3X82y5Xmd6vyxXj9SD8exl8v19uyZG7UuTGjNLeBLlCLRdp5TplYamOMfnz+WOFCs7j/OJb5EAGggqAwaMAAAAASUVORK5CYII=";

var img$j = "data:image/png;base64,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";

var img$i = "data:image/png;base64,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";

var img$h = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/YyTBBykUEbHYwoiFAVEQS4mgjVrECEZtkk02EbKbZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9YwIJorPM3o8zcy4zZ8A3k9dN1z8MplV0YtNRbTGxpAVe8NNNB0HCSd21Z+en4vw7Pu9oUvU2onr9v+/P0ZbOuDo0BYXHdNspCk8Iz6wVbcVbwl16LpkWPhQecuSAwldKT1X5WXG2yu+KnXhsEnyqp5Zt4FQD6znHFB4U7jfzJb12HnWT9oy1MC+1V2YfLjGmiaKRosQqeYpEpFqS2d++4R/fHAXx6PK3KeOII0tOvEOilqRrRqoheka+PGWV++88XWN0pNq9PQotT573FobADlS2Pe/ryPMqx9D8CBdW3V+QnMY/RN+ua/0HENqAs8u6ltqF803oebCTTvJHapbpMwx4PYWOBHTeQOtyNavaOif3EF+XJ7qGvX0YkP2hlW/cxWf6XLNyeQAAAAlwSFlzAAALEwAACxMBAJqcGAAAAJpJREFUeNrt1TESxCAIBdCw97+z2+1slQmgNHmv9guS0VwXAAAAAADAS8TDdauYq2Qna6WbyeSz2claWza92yObnaz1aACrcZXW4LVd3SsfGw7/v9fpw++oFZUBRGNIcfhtyGajFUg2ls1O1fqt/TRe3mhkd/+uy31+DjeWycVwD1sGMPH1T+55O4AoNlbJTdYCAAAAAAAAXugLTOAcJH5aTj8AAAAASUVORK5CYII=";

var img$g = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABbmlDQ1BpY2MAACiRdZG9S0JRGMZ/amGY4VBDRIODhYRCFERjGORiDWqQ1aLXr8CPy71KSGvQ0iA0RC19Df0HtQatBUFQBBEt/QN9LSG392RghJ7Lue+P55zn5ZzngD1S0Ipm1zgUSxUjGg55lxLLXucLDly4GcOf1Ex9PjYXp+P4vMOm6m1Q9eq8r+3oTWdMDWw9wlOablSEZ4Qj6xVd8bbwgJZPpoUPhQOGHFD4SumpJj8rzjX5XbERj86CXfX05v5w6g9reaMo7Bf2FQtV7fc86ibuTGkxJnVI5jAmUcKE8JKiyhoFKgSlliSz9r7xH98CZfFo8tepYYgjR168AVGr0jUjNSt6Rr4CNZX7/zzN7OREs7s7BN1PlvU2As4daNQt6+vIshrH4HiEi1LLX5acpj9Er7c03wF4NuHssqWlduF8CwYf9KSR/JEcMu3ZLLyeQl8C+m/AtdLM6nedk3uIb8gTXcPePozKfs/qNw5zaBHJcPVKAAAACXBIWXMAAAsTAAALEwEAmpwYAAADIUlEQVR42u1bPY7UMBS2PZYQotmdTMMhqFhKGsR23IN6F1pEg7bj5xZUnICSluEAXIBmnEkFQsomPId45bGcxEnsTJ4nT7I0cX7s73u/diaUNMhms7H2F2VJ+kgqhK3b9hBqu3CdJM5jMUobz+12O2s/dwWOXRQukwgeO/AuIhg5caFd2m/ynZHiHAN8aLsNG58Y+KSiMLQRwWwnYwDvaiEnEQOkQp3T4Ny0PyY75be3JNvvD7CZz+MhJ+CDUFvhVRQFYYw1Fj7qHnlNl3DMpt23KrUGQUyAlcZdNOsqR7EAWd/rawTz2GEtMWitYLMa7sOMhpIwh2egcQEzGPsAj4oAPZv4Ao9yMdQGXsULmSajJMAFfN8swWIDH6ULhAKPgoCQ4FEGQZ/gnSrBOe4N+AKP0gJ8gkdHgG/wzouhMXsCvlwoBHg0FhAKPAoCQoJHnQYXAhwspnRYFPEYtdrHbRYXWAhYCFgIWAhYCDhhGV0H5Hn+iDF2Qyh9UedgGmqy6yT5/xanLL+lafpMDu/DAkqjmYNWr5NUU+/aVaOUfqnBi4NJhgIvhdKnSZK8HPioA7zjXYCxz/WvxDpZ3+DvOKBfZxED9kK8BZN87zJpX+DlsGB9PychQNbV8rW0anJzRG/VNWn6OgQJlvv3MIfHMKf17LKAbxJs9wH456D5H7NNgxUJhHwYS0KD5i98gw9SB4B5vhpDgpbq/mqavwTwWzSFUE0C6UuCOl8UxR8I8/e0gBcEfNBKUBZEBSEfXUnQ+6Gwul9r/sJnwAtSCXZsmV/nUDwBy1e1Zn8BuIct12fQztTvkJqfbC2QCXGtLKEDPKnBZ7Xmz6NZDOkk2ERahpHqtmQimWw1KEkAJ/9kr6Yry8hgFfUkNHi9qKua2RFSoGy+aiIBRr4UQnyPfj9AkmA3kOnBH21DRKZIsIR34Pu/pwx4gwg4O/c/N5k6V5S+4avVAzjcHvODLdtncyUEortgoP/fHrtIbLNwgTkJ07XdxlSM2pfYedcNNoKwAzfSb3+tH+sv9q6FjosoxS5fjg7xf8wWYLo0HeI7GAloimX/ANBjieJDfrkhAAAAAElFTkSuQmCC";

var img$f = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZG9S8NQFMVPW8Wi1Q46SHHIUMWhhaIgjlLBLtWhrWDVJXlN2kKShpcUKa6Ci0PBQXTxa/A/0FVwVRAERRBx8R/wa5ES72sKLdLe8PJ+nHfP5eUE8Kd1Zth9CcAwHZ5JJaW1/Lo08A4fRhBEHBGZ2dZydimHnvXzSN1UD3Exq3df1xoqqDYDfEHiOWZxh3iBOL3lWIL3iMdYSS4QnxDHOF2Q+Fboisdvgosefwnmucwi4BczpWIHKx3MStwgniaOGnqVte4jviSkmqtZ2iO0JmAjgxSSkKCgijJ0OJRLGSZl1t2XaPpWUCEPo7eFGjg5iiiRN0ZqlaaqtGukq/ToqInc/+dpa7Mz3vRQEuh/dd3PSWBgH2jUXff31HUbZ0DgBbg22/4K5TT/TXq9rUWPgfAOcHnT1pQD4GoXGH+2ZC43pQAtv6YBHxfAcB4YvQcGN7ysWuc4fwJy2/SL7oDDI2CK+sObf/JNaAQfxWcoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB30lEQVR42u2bzXKDIBCAw+ql6cnqpQ/Q93+f9gF60aan9GKwmkqHsXZA5Wd3YWcyySFO+D4WCLKKU+R4qush5u/DKfHIAlIXIFIDXs45eQhkAYlHiaUhTdMMcvgZniDcTE397Xb9vFweKQgoFfwU+ue1kFJ+AcDDf6J+RQKcqWRAv+cikyhqc4Ax71WPT73Pbg746Lpd/0uO7iVIrwIuNlJkBIyrhJddJBkBbdt62UIDp7Qf5xExL5PvLAXYwM+rxDM7AbbwLIeAL3gSAnzCoxfgGx61gBDwaAWEgkcpICQ8OgGh4VEJiAGPRkAseBQCPMF3JAQo+LV7e3vh9esGKd9M3xeppT2Kk6GYY/5PBiwb47sBmOCDZwA2eCsBVVW9Tg0fX63TsadNfLHgrQQIgBebHtza8+pQIyb81iFQc0n7YHMAdnivAijAexNABd6LAErwzgVQg3cqgCK8MwFU4Z0IoAx/WAB1+EMCOMBvEqAfOXOB3yRAHTlzgne6DOrwy3IW9gKWPa+Xs7AXQDHt9ThcJ7h2p8eiglPMdYF85oCpfvf+ble+OpDMAFNx8o7f7tELGHv2WhbF2SQGisJYv7soh+9JZICp3p565EdmsoDEQ8R+dpfSwUgeAlkAw/gGgdL3j4c6UpkAAAAASUVORK5CYII=";

var img$e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZG9S8NQFMVPW8Wi1Q46SHHIUMWhhaIgjlLBLtWhrWDVJXlN2kKShpcUKa6Ci0PBQXTxa/A/0FVwVRAERRBx8R/wa5ES72sKLdLe8PJ+nHfP5eUE8Kd1Zth9CcAwHZ5JJaW1/Lo08A4fRhBEHBGZ2dZydimHnvXzSN1UD3Exq3df1xoqqDYDfEHiOWZxh3iBOL3lWIL3iMdYSS4QnxDHOF2Q+Fboisdvgosefwnmucwi4BczpWIHKx3MStwgniaOGnqVte4jviSkmqtZ2iO0JmAjgxSSkKCgijJ0OJRLGSZl1t2XaPpWUCEPo7eFGjg5iiiRN0ZqlaaqtGukq/ToqInc/+dpa7Mz3vRQEuh/dd3PSWBgH2jUXff31HUbZ0DgBbg22/4K5TT/TXq9rUWPgfAOcHnT1pQD4GoXGH+2ZC43pQAtv6YBHxfAcB4YvQcGN7ysWuc4fwJy2/SL7oDDI2CK+sObf/JNaAQfxWcoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+0lEQVR42u2bMW/EIAyFA7qla5Ol///HdUm6dguFKlQuBwnh7ADKs5TlTsrxPp6NAZ16H0czCMTXsijO90mNUw83DwC4OwAV5hZ37rYWoV6kAAAAAAAAAAAAAAAAAAAAAADcMh6CO63F7iwnkR2cUmqe57YcEIq3zyg4cWaapnYARM7rRjtLYupXY9ggaAHxzqKDtSgbAXdIkwBqqgK4QryP8J3OBe6xLjBVAFwpnjoh9rmDUJoOuhfxqXTwTiitCbon8WE6ROrCaQi6N/GxdFjX9XtzwWkIukS8/cHPmuKfnKD1W6kTdMnM2x/8qC0+VhNIPciGoEts7+nb75ro53cm4nCJ3L0ZkrqRvWSXRwokBZR9M9SzeJoOR82SziHYe5C6kA/A2cZB8E/PsXfh+zgqLt4+DgIl2cotsivEdizJlD0aZ84ymOy/G5nd5FhyJukQwHby8td60jW3hULpxP8Wu605O+vQrEaIQqDtZ20nePG+OStJz+xW+MkJpP2s4QQqvmTmizZDUSdsg7jSCVzii7bDHkK4PF5VEzjFFx+IOAip/lsSArf4YgCxZkl6iZQQ/zKAVJ/AnQ5S4lkA0Jog3Msv3OK5HBBdHZjj300TZxvOdjcoCYHrjlHMAT0HAAAAAAAAAAAAAAAAAAAAANwzFP47jBQAgFvHDyRnPtj60cBDAAAAAElFTkSuQmCC";

var img$d = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAeNJREFUeNrlm2uOwjAMhDsWJ4De/4bsEfD+WGm3QqTNw54460hIBbWNP2ec2G3Alq/p4RhIDP/jgczwmRyghd9NQ0AbzkUEeAtD1MBAzIIf6VwdjAUbvqdTJUgWLPjWztQAQAlO0JZ7wgAeTnMIvOFrOlFSzFr0oz3Xw/qGrNi1shWB4Hv7HrJVAiYvICjm9EQNkjJf2WGiUgSFv7LHLERlW6+Zzk8IPPotyVO3nRKkYhuBG7JTiDl+yLpBssV8rQMQHN5UQp6TX/TQgqw8ehY2SmD5U5psydst0JJVM9urgVo1ogKmld+SGT6CA6bCz3bAdPiSAzQL/CwFWD/4HHYAFpU9VlPACLyyQ4CVx09Pu+XEEA0MD28FRBp5ZSiAqYJReDDmgH+zzrc6wEIFVvCUx/S1D0SUHK+0dxRiMLIMeHoq3PoqWo3A6XPHaP6NzX/vkOvuMa809JNj0OFc9xXq1jByq+wSc00pV9knWM0g+77/fjkeTzAOMxKlCApgQzfPAbUZngaGLucB98fDKr3F26ck8VD1AIzga64L+cpdnOCXaZIZ/swBKeBLDkgD/8kBqeDfHZAO/uiAlPBX9TxKNcJL/y75ej5nFk5uq0CajVKXD0UrKsTlQ+AoV9afF8PwfwNGBXNgWGrhCQAAAABJRU5ErkJggg==";

var img$c = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZE9S8NQFIbfpkpFqx3qIMUhQxWHFoqCOEoFu1SHtoJVl+Q2aYQkDUmKFFfBxaHgILr4NfgPdBVcFQRBEURc/AN+LVLiuU2hRdoTbs7De897uPdcQMjqzHD6UoBhunYukxZXi2ti6B0BxDACAVGJOdZSfrGAnvHzSNUUD0neq3dd1xgqKQ4DAgPEs8yyXeJ54uyWa3HeIx5lmlQiPiFO2HRA4luuyz6/cS77/MXZLuQWAIH3FMsdLHcw02yDeIo4buhV1joPv0lYMVfylGO0xuEghwzSECGjik3ocJGkbNLMuvtSTd8yKuRh9LdQg02OMjTyJkitUleFskq6Qp+OGp/7/3k66sy03z2cBvpfPe9zAgjtA4265/2eel7jDAi+ANdm21+hOc19k15va/FjILIDXN60NfkAuNoFxp4tyZaaUpCWoKrAxwUwXASi98Dguj+r1j7On4DCNj3RHXB4BExSfWTjD603Z+Sp2ztrAAAACXBIWXMAAAsTAAALEwEAmpwYAAADGklEQVR42uVbC47jIAytESeY6f1P2NkjLCOqInmoP5g4BChSpLZJAT8/G9sQuDHtfr+Tv/9P6WZp/35+tP6lDsEyXgBg7z0eD3qAVsE9AWgU/s8cOQG+vr+bAOCAiK2Cn9CS4TnwGrTIWYAItw9voGmfo56DJlI1DnD38jx75qGxOvcZRwuuCV++V888zaCmLyUkvlc+S0BE6uZBtBMDKHjYbvnMzVG6Rz0bvbSaByWo+0frR0GQWCSZicSE0Kv93Fm5mAl10V/4PSkrSGpRkgrAUXoatWbq8yVA8ujfFQBOg56UbxXQCoIXACytvUHwBjkepffL+Q0PYGqQseaxw5WWyScDcmyPr6uEYOzdnT3YcTcxwMsBtsTlXv1aVoJwpv0bNH16tDl8FThTmwygXeYSBtn61YAmLn6YlgFW0Bg/UgueatMYWQ+AWRiFQZjSBOql6kwneWlF6MyaA8E+6EqHtUleEQUeMD2ofcJH1QRPS4cno7tp/NjoMGbSIljpL4EfPo3ybwzAOzd5aRC0DSOTllEgBEPykBSAlmzBkjkhILyWJLb2Vy7qP54heW89oGu/rgiEKskiRdGETyurBUr7L08L0sA9FdhpTYBaZopmpMKjBwjO+5KiuVD9xVYPSuzXTRdAtdQRc90TnyMIBxBetuHib+jQxjYgPNnQ68m3igOsjm0nEALl4Q2BzvIgRC3Qwaewciu5A9pzr4sM65nAQRYszYioxPzqQUXsDzJbOMZMDwAX6GQB6vM522WDStKzdYt1HlCzQNrBXZEROAxuDYS2YUGtrAwGmw1+SmsNhdMm2n87Wxha1/PdvH/xa8GQg69eEL3ufMBszg+zPBjD2jRwgmfavv7CxC7rvqbcgA89E4cKYQNfkCTlDt0XmGDZezNt1QmuGBgJwvNvjeE/t5Siy3ncq/f9LcJTrA1Wp7GAQ2SFJ0+ItGx5C0XQNJPmhYIuiG+Otm5P9QzQypwjpmSlPR4TNDoTr6iRA40+ak/l95QD1+RaemdIE96UDqMDCUuBYBW+lhM0O1VC4nQl/SkW1MJrcvwCJhH28gf87HUAAAAASUVORK5CYII=";

var img$b = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZG9S0JRGMZ/adGX4VBDRIODRYOCGERjGNRiDWrQ16LXezVQu9yrRLQGLQ1BQ9TS19B/UGvQWhAERRDR0j/Q1xJye48KSui5nPv+eM55Xs55DriiOS1vt4cgXyhasdmIb3Fp2df5jpsh+gnTndRscy4+k6Dl+HmkTdWHoOrVel/T0ZvWbQ3auoQnNNMqCk8JRzeKpuJd4QEtm0wLnwgHLDmg8K3SU1V+U5yp8pdiKxGbBpfq6cs0cKqBtayVFx4T9udzJa12HnUTj15YiEsdkjmMTYxZIvhIUWKNHEWCUguSWXNfqOKbZ108mvxNNrHEkSEr3oCoJemqSzVE1+XLsaly/5+nbYyHq909Eeh4dZzPEejch/Ke4/yeOk75DNwvcF2o+9clp8lv0ffqmv8YvNtweVPXUgdwtQODz2bSSlYkt0yXYcDHBfQtQf899KxUs6qtc/4EiS15ojs4PIJR2e9d/QMO/2gR3i+r3wAAAAlwSFlzAAALEwAACxMBAJqcGAAAAvVJREFUeNrtW01y0zAYtRQPadzpkEQ5AwcoXcCGHSdgxTFaTtA9tGy5BxumnemCbXoD9mwsJ6sYZlqLT0EeUiNZ/pHj2P40o3HGcWS99733SXJk4hnKYrHQnk+E2B4jzr1DKXPGtkdKiPGaMAy150c64EEQGBsS6hjHca1Ow31ePhuPf0yOjye/4viuTlsT1V+SQ4DEJOtms3lyntgi3oQCIGIrOEx3z0F7pEkFmBRB9y1XxthZFrwsM8au27APsUXf5J2q4EE/NzoClL0+rzg/d3U/m6oltlHqD92XWb/U9TwAXMLHoyRJfoJfTzTReDUOgueQE765uKfsv6ymnCa/G+lYchn1FDzkjlsJXiWrkxxJvnZJginA6fnGc4BMeAB+qWS/zk2woAyVmM6njF256oMMqCmoJKsAl9FXkV9W/X3ieddrzi+qev3h8dFbr1a519IijetqgchHKXiIbGwb7nTnpRKgHVGaOBiqZaXULvBGLCAjL0e2v6ld/IaOTIqM9abvgYRPRQCntUyhTYCHTtz8MxkZl5noGK67sJFQtVDH4E+V7Gd1ZnlGEubzj3X7mFULrSMfDfjborKuRAIhH1yQ4FwBKuHd1418GyRQB7J/kQXuAryNBFg7XB4EAUKIt02BN7TH1azpvea6dEK1PwI451+Ahe9Ngde0y+B+X4H4dzrwW1C0OCzfQd8eoih6s4+la84k6jCGwS4WJGDoBFhzgOtnA6gAJKBjFjA9cOiLNdACSAAS0K+yOy0WBRZFfh+jWmZtgBZAApAAJAAJQAKQgGGvBrN/Bz158Cg3IO3+Y3RI2+MqFoEKQAJKECAlL/ffpbXoBoku5YDWFyzpRsfBWCCbSNtMrJgDkAAkAAlAAoa+FhhWxDMvVfhl3rJACyABAyRgOpv1mgD5vsB/+2PDMOxlYtBh9VvqiKchvR0L6KKtY6qP0ZfYfdsPum4HWzBJlajX2Va/74mOqaSBHfwwWMn/XVZA1tKkine6SIApl/0BVV9uhgTVncEAAAAASUVORK5CYII=";

var img$a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZG9S8NQFMVPW8Wi1Q46SHHIUMWhhaIgjlLBLtWhrWDVJXlN2kKShpcUKa6Ci0PBQXTxa/A/0FVwVRAERRBx8R/wa5ES72sKLdLe8PJ+nHfP5eUE8Kd1Zth9CcAwHZ5JJaW1/Lo08A4fRhBEHBGZ2dZydimHnvXzSN1UD3Exq3df1xoqqDYDfEHiOWZxh3iBOL3lWIL3iMdYSS4QnxDHOF2Q+Fboisdvgosefwnmucwi4BczpWIHKx3MStwgniaOGnqVte4jviSkmqtZ2iO0JmAjgxSSkKCgijJ0OJRLGSZl1t2XaPpWUCEPo7eFGjg5iiiRN0ZqlaaqtGukq/ToqInc/+dpa7Mz3vRQEuh/dd3PSWBgH2jUXff31HUbZ0DgBbg22/4K5TT/TXq9rUWPgfAOcHnT1pQD4GoXGH+2ZC43pQAtv6YBHxfAcB4YvQcGN7ysWuc4fwJy2/SL7oDDI2CK+sObf/JNaAQfxWcoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAIkklEQVR42uVbWYwTZRz/vm96YOku207r7hK8IgHXBw3GBI/VxEQfBFGM8mBCxBdWEAheaHwwJiYknhFX0YgPXsR4EFFBsmpijAKSeGBMDBtBNJggu3baLnt0u53O5+8/duvM19lDaJd2/L+0OzM7M//79z/KWY0pmUy2FYvFqyXnl0rGOrhlXSCFaMXn2VyIEF1jSVlgnPfjWB/O/cYZO8Sl/FEIsT+VSv1Zy/fjtbhpPB5fjI/bLc6XCMYu9rrGsiwGBiu+e1zXi3N7pGXtyGQyB3BI1qUAwHQztLwaL9qFF15QC8Hi3ochqW2QyqsQxkBdCCAWi83BSz0AtWyEDpvZDBCsYhDu022Z5rMDAwOZMyUAHkskVsNXN+N7YrL3heZ+hJC+wvdeWEmvLBSOIS4MDrW1DdIF0RMnmjRNa+LB4Ll4oYVMyg5w2QkmF+G0Nsm9DYuxR7OG8Qo9Z8YE0JxMXhiwrNfxtXOCS0ww0SOlfAva+vxUtTRnzpwWCOYG3GclhHEjDgUnuPQbwfkqBMzDNRcAtH6HLBa3wc+jHqczcIXuQj7/4tDQUKqaZh+NRhOhUOgeZIuNFHI83GIYVrYG1rC9VgIQCHRP4gUe9Hh4Dhp4gnP+nGEYgzVOq1G4z71InY9ACZGKQMnYloxhPDBdl5iuAEJxXSfJrqgMzXIPXmg9zPw3NoPU0tJyHgTwAhSyzEMIOzOx2B3syJF8NQQQguZ34kFLlONjYH5TOp3uZmeQdF1fhxjxLN4vrJzqScdiy6cSwlQC4ND8u6rmYfInNCGWwdy/Y3VAiUTiMrNY3AWLmKvghg+BF26bzB20KcDN05DsauWmR2QweF0mlfqZ1QmNjIz8GQ6HP8DXJYhDell7nF80KxKJjeZyPf/ZAijaI8e/rTIfDAY7+/v7+1gdUmtr69n5sbGvK5ColKvgqm9OWwCU54VpHsSNmpxmD81fPdDff5TVMQE7nA/MsM/pDnj3kYCmLQJO+KUitXkJhUCOk3kKePD5m+udeSJko9+lpt0ErZeDH6VLU8o3vfjVPEy/C2axTjGh+2FCO1mDUH5k5EQ4EjHAx1KHqc+LRCJ/5XK5byd0ASpsEDgOI3oknXkezC9lDUjg5yO4w82OQ+miac53QnO3SaCqczJPCI9ADmtc2kD+70xsqC0e8owBdj2PktZ1EvB2phFeNQkY4Bh42OwuTeV6KrIqBEDNDKWezxC2Zw1OSNvPU9nsCIhREQh0VQrAsroUPN1d68JmJqivr28YcWyLK/BJ2TUe/3i5h8f5Acc1hbF8fm61S9ozRU1NTXowFDpOdY1D4Z1wkX3jFnC7kvZ6/MI80eDgoAGG9ygBf0XZBSyl0kN1tZ35jBDPtitNDDu1c7tvb1nO3ruFXJk43WZjvRFlOUgh7QJ/Up4jaGihFDwH/ca8jYDS6ZOoib9XDl8paGKj+MbXzKcEf9/rUjbniwSNq5Trev0qAFj3ISUOdAia1SlS8a0AVOUiMJ4vaFDpEkChcMy3FiDlHwosbg3ADGLMMZikiY1nFNV12UjMpg2jotlDIzWhaU4LiAMai1nOi8bHVX6kkydPDikWERbsf04CZuHqm9Og0q/MNjc3R5UgaAbg/wR6yiMmmtLiIzUdn2o4bbv7nOQCf1EadLW4aUTtVwuAxs9RGj59lAZdHR97Pu9fASxULOB3QQtJSrLs8HHM61AE0itoG0tJltf4lXuU/Z2KBRzkiUSiHYjouFIO66gIs35iXtf1JiA5KocDjtrgPEF7eLSK5owNtJbiQxh8g5N5HPjV7hqX0sMe5eKVvhMA5yuVvz8plci2KexwBQchbqSdHB8BoLhzTFYSwI6yAGgD015C/JeC9kKSTygQCKxljo4wTPxoNpXaWxYAHbI3MN05YiMtJDU68+3t7YRyNyra38ZKK7fCkf5epXLRWQHTNlajC2B0bGyDMu8ctkyzrOxycTw6Opo/a/bs2fCVax0NgyvC4fDb+Xy+IVNiPB6fh4D+HgBPyIF0t2Sz2V3llOcCCqb5DHPP0SJIiS80cOTvVhY6s4VC4SnnNa4FCWh6NByJDLoiJucLIpFISl0sqHcqLXpsUsDAwwB4Xyq1T2XVGNd1ipBXOv4xD0leBdD0QyMw35JMXspM84Cz2wXf/zabyRBPRRezXpCZFo/t3dt/rSBsFou7aQGp7jUfi50LbncrzOc0Ie5UmZ9IAMzeuhZijdJMaAdA+pRW0eqV+WhbWxK57VMwNU+p+9cbhuHZ7p9wUXI0l/tpViTSAh+5wlE+6qZp3oLMsLveMgNpXhSLX0BRF7nc3rK2AuhtnrBHMFUXKabrO3DRre6K2Toe0LRl9RITbJ8ns1c0j9i1K51O3+pl+pO6gJNXe+uasR7FHeZCCPtbdP2Mw2WK9nbAU5i3GPssHY+vmIz56VjAPzR/fjhmGO8gBiyvyLWW9TE+NlBpOeMgB3letc6y5on5aazLa9N6WjpdBFJ8nxaP8cDFSltpIdDW3cAKVHX9MDw8XKg1tg+Gw/fjme8juF3ioRDy+bvwztN6D34Kkr8TEPkluMFsj9MGLSQBbb1MaynVLmlR1a2BxO9jHj/SKv1qZR18/rX/ct9T6vUnEokFppRvCEeGUGiMdnJKaymf03LCKZo5re1dT82MEjoNeQYqgBzK8xOluqoLYDwW6rq+Fnn3cebxIyYHFWkzg5YTSvP5XprSUuU5PqujiQ0NLahvX2pdd1ADE/9z+RRumoXFPQYBb50q2NVCADYBHcZo/ZQ2MCf4JVnViVAqzH0rFTan62pVG3fR+qm9gWlZq5Et5temvJNHqZlB9Xy19phqMe/jQGVX2Xt4lrX0tIUh5a/UwKQeXqmNVZ8/np4sX1NlSQtJtJNDaym0mYHPJGJBoJRK8/ieplkdjatoYkNDC5w6UGt88TeBNfhPMH+OaQAAAABJRU5ErkJggg==";

var img$9 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/EyXigxSxELFIEcXCoCiIWEkEbaJFEsFXk6x5CHksuxsk2Ao2FoKFaOOr8B9oK9gqCIIiiNj4B3w1EtY72UCCJLPM3o8zcy4zZ8AVzmo5s3UUcnnLiMyF/EvLK37POy58eBhhKq6Z+nx0NkbT8fNIi6oPQdWr+b6Go3M9aWrQ0i48oemGJTwtHN60dMW7wj1aJr4ufCI8bMgBhW+VnnD4TXHa4S/FRiwyAy7V05+u40QdaxkjJzwkHMhli1r1POomXcn8YlRqn8x+TCLMEcJPgiIbZLEISs1LZo19oxXfAgXxaPLXKWGII01GvMOiFqVrUmpK9KR8WUoq9/95mqnxMad7VwjaXm37cwA8+1Des+3fU9sun4H7Ba7zNX9Bcpr8Fn2vpgWOwbsNlzc1LXEAVzvQ+6zHjXhFcst0pVLwcQHdy+C7h45VJ6vqOudPENuSJ7qDwyMYlP3etT9GwWgrP+9tUQAAAAlwSFlzAAALEwAACxMBAJqcGAAACZpJREFUeNrNW11sHNUVvnN31xtt145nZxfbiL+KQHAfioIqpYT0oVJ5ICEUVPKAFEFf7AZIlLa0lZBaVaoUqX+o1DStGh7a0qhqRVRKoZEpUh8KhUi0BFWqsEhIUCqR2N3ZtWM79npn5/Y7w665e3d2/nbG3itZO56Znbnnu+fnO+ee1VjCo1QqjTYajbuEpt0uGBvXbPuTgvMRfF6jcT5A99hC1JmmzeHcLK5d0Bh7VxPiHc75G+Vy+VKS89OSeGihUNiJjwdtTdvDGfuU2z22bTMI2HHsct8Mrp0Stn2yWq2exinRlwBA6CGs8gQmOokJ35oEsHj2WSB1HKg8CzAW+gIAXde3YlJPYFmOYA2H2AYMaMUizGfKtqynFhYWqpsFgKYXixOw1aM4LnrNFyv3DkD6O45noCUzol6/CL+wuDQ6ukg35C9fHkylUoNaJnMDJrSdCTEOKXdDyB24nPJ4tmkz9p150/wlvWfDABgqlW5O2/avcbi7yy0WhJgWQvwWq/Vq1FXaunXrMIC5G885ADDuwalMl1vf5Jr2CBzm2cQBwKo/JBqN47DzvMvlKkxhql6r/Wxpaakcp9rn8/niwMDAY4gWR8jluJjFMrTsILThRFIAcDi6H2AC33B5+QpW4Puapv3ENM3FhMNqHubzVYTOJ7EIuQ5HydjTVdN8IqhJBAVgoGAYhOz+TtcsTmFCh6DmF9gGjuHh4RsBwDNYkH0uILxQ1fWH2LlztTgAGMDKv4AX7VHOr0H4b1YqlSm2icMwjMfhI57C/LLKpemKrt/vB4IfABpW/g/qykPlL6c43wd1/yfrg1EsFu+wGo2XoBHXKrzhT+ALX/Iyh5QPufkRkJ1QHnpOZDKfr5bL/2F9Mq5evXopm83+EYd74IeM9dXTtNu25HL66srKdGgNIG+PGP87VfhMJrN7bm5ulvXhGBkZuaa2tvZaBxMV4hGY6nOBAaA4zy3rDB40KKs9Vv6uhbm586yPB7jDTeAM/5DNAXO/mk6ldoAnvNcR2txAIZIjC08ODzZ/X78LTwPR6AORSt2LVV93fhQuLSGec5OXu6j+RAfDg7eHw3vL018YxoYK6vW+hXL5DDLRrymC7kTEeNTTBCixgeM4C+9RkuM87Gdv0MlUTHPDhe/2TsjzIszhPvnWhmVtk6l5uwYgq5OFJ4ZHJCfMZJLWhJDPP0z2L38ducW3XE3AyeeR0rZdBL2NwvCSBIFWG/OiP9H6Aw9wvRcc4CKuH21PTcUhSrI6AKBihpLPV4nbB5lQF3KSFOlhLlWhrlUihO2fUtosOcQ8T6cnOwGw7UnliVNBExs3EIC0owkb7RzVMTs7uww/9nSb4xNisuX/eKuGp5CHOqW0UVQzYcrLotQE6/X6L5zc5WOKeDMc5C5ZAx5Uwt50lHweRCNWnyB/L6rwNBYXF01o+CnF4e9fB8BWMj1kVyd6dVK9ghBSeF/Vgz87oRQxnNCuOXV725Zr7zZiZbHXYqObwARMNy3x4hVeAOB5geyOohxQqLQlgEJcz2nTQkl4zvQqvJ9jDANcL6rfNp9K5Qpy4n8pp+/ktGOj2MZrccfsoCGyCzg9qb5Cel5ve7Cm7eC0XaXcNxOn53ZT+W6aQIDJfz5RRQtiTop2v6v4gXFOe3UKKrECENUx+ql+WOHdFheO8SZOG5VtANTrF5OI4WEmHIfXd9UAIf6raOIIhxro8knasUmSx8chfMTVd7bUFA0ogADyLfLJ1nbVZoIQlyap48qVK0uKRmR5P1VzklJ9z8gAtWirm9NG5Wbk80mqfmsMDQ3lFROw0oj7RHrWt5hol5Y0LcJK+U6wh8ywZ+GbqfCgYgL/ozDYVuKmLeogDtXtnFcNYBNCnls+cL1CzWcpDF5QjGx7D+9wBaGb8H48PwzXDwjAdkUDPuDUkKQEy/Ee39MGgpfwQeYcc0FlXAFkhlM3lhIsPxdkYlE0oYvwws/u4yqvIe3frWjAGQ0PHwMj+lBJhw1khPMxVGe6Oq+gqh9Xyd0wjEG8jNLhtJQb3MipD49a0WTfQG0pQQhJAPsUEa9pMUcRWu27ZeFx4n2natwMD6eUmw+E8S0+mhI2l/cMeVFBQJJ3QPn/L+slMWpCbJsB5/dQT04IahoKBC9QwlaMAhKgAia4VwHg5DoA1IHpNCF+PDJOQ1I4fh4IBB+N0IJGizCOMZ1O057ggKTi5+fL5dfXAXDskTow22PEEWpISgKEsKoftbxGY2xsjFjuEWX1j7d8EJfC37NKuligbqwImVoU4uJLdaNWm1fX1g4r+53LtmUdl8pkHw3qvaX2UwXlJ6nhwCcU9gxCUKoblhIXCoXrYNrfVujvsa67w0Dmx6x9Hy2HkPhM2AmFASEs1VXNwYsbQNWnlIbO+Xq9/sM2QOR/iPxQ763iC+6lVjQ/r6yqYosneAkYlee3hPYSXi8WJ/HwBxQy8F3aJfKL4RzCkIe8U/piDUjuwoTf7qHYIZJKctQxXCrdzizrtFztgu2/NV+tkkwNXxKDyd5iNRrUJPUJ6QGXYE+7qAeH9fHQdf0GQU1SjF0nzX0lxfkdpml2VLx5F9WkHyYcVIoJY3CSr1ArWr8Knx8dLUHNXpGFbzq+Q27COwWgruFjZeXfW3K5YajIZ6X00bAs64vZbPblWq02328rzxuNv2Ghbmsze9s+hgh3NGpay3XDOKk6E6jUh+lUal8vPiF2m7ftl9WVh+96qVKpPKDava8JyLI6XdeMTSvmcC1AeGPYMB7b9JWHt3ccniI8otlfK4XCfi/hgxOWbduyumn+Hj7g/o5Ya9t/xsdhSi03UnCH5CDOd4S61sqT8AHa5VPBAm+lsbq6+jw1HuOFO9U6G9Lnr+RyOcq63l5eXq4nKThx+0w2+3W883k4t0+7LAjZ/Jcx50Dz0CIg/zAo8s/lECkNkxqSqCdHJRy9DkppkdUdZB91gHZw8OavVh6Hzf8qVBISkdTcagnxGy5FCGWsUU9Osy3lVWpOiKjm1Lb3BSpmNPP5AVdHBZKDOP9wt1AXOwAtX0i9t4i732MuP2KSRoM6M6g5obk/P0O7tJR5tvbqaMeGNi2obt8sXY9TARPf+YyPmc4TvQXAx/ycXRIAOAPZok7tp9SB2eWXZLEPSmkpq6PEpldTi42PU/up04Fp2xOIFtsSkVyI81TMoHw+jj6mWAGQn+k0IVIfnm3v7RkMId6nAibV8JplrP788bRXvKbMkhqSqCeH2lKoMwOfJfiCdDOU1nBcob062q6iHRvatMCl00nzi/8Dx0Tcgl7ehnwAAAAASUVORK5CYII=";

var img$8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAaNJREFUeNrlm0sOgzAMRHHEEbj/CbmDq7Ko2opWxBk79pBNuwCTN/4lCshSc+jbfxkxJMXhhzmEAH6IRUjgzTxCBG9iaoXhBSBW+gi4Aq8jbELiebMIQhL2ZhGEBN58rxDBm2wIGXy3LSGE77LZSOEv399I4S8viORm8GlqQDR8qjaYBn5GDZie8zMjIEXOzxIgJXyUAGnhIwRIDe8tQHp4TwFKwHsJUAbeQ4BS8GgBysEjBSgJf2pk27bjd993evjnWL/B7+J5xGaoPPxLAIP3KeCtEUADfxg+8/6fAkgF3xsBdPCnAvzwPiX8Rxsk8Tz8bDAzPOStkdUw8dnwipxf73l7NnjxqgG6+AwFpSKsQDYQQEl49EqwHPw/g8iXEhHwbmsCj91gGfgeAQSYDqneS2oArym4jWqkWM2hZmgV+F8PUcM1iLDXGWnSgMKhcj60RvTsBTwLni6ThjhOxgIf3iHWIFFTwp89VIPAU8BbIqDiV2bDAngfoU8VVYInqdkiKmpTolnTCXEuUBbeskTtTZ30RTRqpZa2eyA/R6FvmZTjAXQIhaMv+ge0AAAAAElFTkSuQmCC";

var img$7 = "data:image/png;base64,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";

var img$6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAA0dJREFUeNrlWwmO5CAMjBEv2On/v7BnnjDeZhUkixgfQELIIkXqzgG4XD64YKuU1+vF3v9F3Dzl5/vbVX9PewGg+uz9frP3wduxskMVAdHSlgeImgB/vr5MANTqid6OGAoK92GbXLKcGYgwuH7sfH55iZr2a9TrBAmkdjxsrPkYrZ70LLUZBwpes3vUQCjbSv+5zpf05YSkz/JvCYjAPRykdZCcX6vtWjTrqTOeZPtgZMIQQDTFSUwIrdpPlY2IHFqnRxauzrDNKzhKwz2hPFxA/22UL7AI6AVhJgOGULrXVOJoRK8UvhY2c4zXwuQ/BqTcnl53FHB09KCgTDeBGsPOYl5pNuHJmr7ECVobKqnXo+GRoIWRdmUNU/m9VhBGmkeYaecjtcy9Lw2oLgWgFq8/93BPpNjrrDR5ehRwJDBIQDqFlXGG8C3ffDqMwrfQCkLs7fBVmaLSD2wF4w5jAahcbpB306qaDAfi5SZAhfl0SJoqB6pdmt9bTWYTpt1cANxlQLSDAJY5hV1g1TSWHg5z5qL4iQNgkU4rJ9oI2gZrsjEJiEx70VSSj/i8BwcG5I8lBBWAblO0PlJHGYzCl0B0aarQWjVR2jUJLSGucKTDw2BTZrYLBVR4ia4EHI+tm/xEdpKB0z7pJAidw22tYosCOcxkzaT/QrzGM+21IW3WzAVcY4Fi4hFmaN0DAuMzDiXtJ6D7CMIIGq1W6ORvaNDGY0BIV2ik5CNAYBlgsfMngRA4D+9IdJYHIQqJDmSvSUseO5Clp+Fr/5ebQCcLlmZEVHJ+0NYLqT9IbKkx5vYA1BKdJMCoFZ0losCIQc+yJsCxgNuadsMJEbvGSRpsTYQew4LDstgHjOpo8H8p1lQYH6L9w4auYI3nT/P+2a8FxxgcFwcBe0zgUc6Psjw401q8sINn2r5+YOIpcV9TbqD7e5hNhfAAX4CScmNHpbCA3auHt1QnuGJiJAhfPzVGP7ZMRe9bVuCsjY5nCM+xNnidxgIOsSo8e2DCsuQtTILinTQvTOiCeHLUujzV0oCVOT2m5KU9bRM0OjNH1NiGZm21V84LgybX0itDmvCu4bB19+YKiyKS8KWcoNmpkhLjTPpzLCiF1+T4C+eX+V1keq0EAAAAAElFTkSuQmCC";

var img$5 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZHNK0RRGMZ/M4gYUSwk6S6GKFOiZKlRZoPFGGWwuffOnRk1M273zqTJVtlYTFmIja+F/4CtsqWUIiXZ+Ad8bTRd7zFqJHNu576/nnOet3OeA/7pjJl164chm8s70UhYW4gvao3P1NNDO4P06qZrz8xNxag5Pm7xqXoTUr1q7/t3tCQs1wRfk/CYaTt54Qnh6bW8rXhLuNNM6wnhA+EhRw4ofKl0o8JPilMVflPsxKKT4Fc9tdQvNn6xmXaywgPCwWymYP6cR90kYOXm56R2y+zBJUqEMBoGBVbIkCckNSeZ/e8b/vbNsioeU/42RRxxpEiLd0jUgnS1pCZFt+TLUFS5/83TTY6OVLoHwtDw6HmvfdC4DeWS530eel75COoe4DxX9a9KTuPvopeqWnAf2jbg9KKqGTtwtgld97bu6N9SnUx/MgkvJ9Aah45raF6qZPWzzvEdxNblia5gdw/6ZX/b8hco4WgdZKtgqgAAAAlwSFlzAAALEwAACxMBAJqcGAAAAhtJREFUeNrtW21uwyAMjREnWHv/E6brDrDGC1MzZQiCCWAMwVL+NCH2e/iLQGHyyP1+R9fvC+IkVRSA9948z86bQAXeOgE+IoAKvBcCbCLUdHGB0Oz7YidFVn22jiLg3noOsWlO4NzyJhaOiFCu2e8BPDXhXyIHGE/whZmWPvt2voiR79dr+no+/2GzPV6XNCBHgnOV3WVZJqWUt+xtY8wzIdEtu3aOnkSnzmCqh8Q2OgY0ZWazEVBbPh+Pw/sft1uS18D6ArQUUpKg1H44aLuN94wvoWCHibbt8msBVcLNJIdAdBL0ZHmyIlcVObsYOkp4W7K0nwkl0WZCgAKeKwS6Ad8EASXBN10FcoAfjZDxAMNkJJtdNULboN/LZif0vNCL4gF/FzgGdR0Ctu26oKJuW+HLrwUGAYOAjuRsEuSqAiDRAzhLII4QEEgAZw8AUnPAaIQGAb0QsP/iErvL0qLYGPVVgPtI0JdzeWtLXcccLRtJcBAwCOifAOqR2RbFhW0clfUx09thSR9GHRrQOhGhkIYzsX90PG23T5+VuPW9SOlaqX1NkePy+y22zeCc4G0dWb8HbIzkrALG8FRPyEmkK6S9Z4VzEZFCQk7w5P8MZRAM5Rvm94TLoEASkMvekiXuLAjktLV0jY8Fg9x2cjQ5VFBYw0auLi8EDmvZx9nmokTbuPt8lGZXjYUOSrKp5koPBdlSlYSqX6B+AGDuGPLVCsLeAAAAAElFTkSuQmCC";

var img$4 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcmlDQ1BpY2MAACiRdZE9S8NQFIbftkpFWwrqIOKQoYpCC0VBHKWCXapDW8GqS3KbtEKShpsUKa6Ci0PBQXTxa/Af6Cq4KgiCIoi4+Af8WqTEc5tCi7Qn3JyH9573cO+5gD+tM8PuSQCG6fBMKimt5tek4Dt8GEQYQ5iSmW0tZRdz6Bo/j1RN8RAXvbrXdYyBgmozwNdHPMss7hDPE6e3HEvwHvEwK8kF4hPiGKcDEt8KXfH4TXDR4y/BPJdZAPyip1RsY6WNWYkbxJPEUUOvsOZ5xE1CqrmSpTxKaww2MkghCQkKKtiEDgdxyibNrLMv0fAto0weRn8LVXByFFEib4zUCnVVKWukq/TpqIq5/5+nrc1Me91DSaD31XU/x4HgPlCvue7vqevWz4DAC3BttvxlmtPcN+m1lhY9BiI7wOVNS1MOgKtdYOTZkrnckAK0/JoGfFwA4TwwdA/0r3uzau7j/AnIbdMT3QGHR8AE1Uc2/gDt82gCvNGYhAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAcpJREFUeNrtWwFuwyAMjBEPWNf8/4XpugesoWMKUppBYidQ5cAnVZWaRtGdDxscoC6Bvu9d7PfRue6sMETJa8MwRC8Slzi6ACkhiEu8FgGWQpiucdBW9FNj5wiWzyvxjOk5/muVm30n8Xfjl8NfkNeEMLHo10Cem/CbyAHeCZMb/sGePfqTfXfh5/Hovu/3F25Lx9ujiURad6WIld1xHDtjTLLshXv8f7Zgka2dY04ClQNCxDmR5eL0Dvi63Vavf16vh1xjzzy13YKUPPQQWFaDHOShBJjX8VzkIRdDa+RDvvBlskoBOOSlVcLURr7KIVCKPIQAJclDJsGc5FkzwdBUqJE8pANykocTIDd59mKI2zIv0Q8oSR7GAaXIQwhQkjx0GVQBGI5xjEWRrTGqkmGjQ0AFUAFUABVABVAB2sXmRMi3pEbnSDLJyNm3h3MAEvnsAqCRZw0Bb/l5Q2THjg1qaghoFVABVAAVQAVQAVQAFUCCI9thxYSJXj5WcspCHaACNNgP+LhcTr+gySqAX/nNX2nP99ujI/aaX3NAbAPDkQ0RSNFfPTUWbkA/QLUVTNoT9RpOj+rJ0aUDJE5AdkDy8LRECEQBUrnsCeUexwK5uUFRAAAAAElFTkSuQmCC";

var img$3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAZBJREFUeNrtmlGOwyAMRDOoJ9jm/idM9wjrzVZaKWpDoBI2YzBSf6oqeB5jjGmWZfKBDnMKU0wgEd0tPpAKN4sTDsSrxgqyPDffH2AoHp2eYwqgddDqEEAs3gQCyMWrPz85KbHUZVA6VxewOsDFSOTWV392UrAkW3Nl6gCL5grMKSDsK94aAAhSIKpAACADIF7yvxUAeM3/SAFFAOIltRKLFXvNqZkCwr76sQc0BgBv9rdwgDDbP1Ig2uFwQAAIAI46QZU5wgEOdmzEHuAEgOV/BMJk0VxAFu8eQA3Auq6nlH/k/evvx+Ptu6/7van6mjkS8jy2bUMVgJzwKwCvAbYWXzvHFYAcCNQKLwGg2NBQnxH/IKavAiitfi53vIySttuowo86dgjZ0okzQqOIP7ggW0qn2AP2BX1+sifB4w9GW/2Ss3FiC4zshteUjzK4n6jk7Jg5w/g7TWLheNNr2AsRfgBajYunFOh1qdG9BYgUCAABIADcPuymnsPLrVCuAQoHXABAafWd3gNM0+x9PH4BvDJ3ZJJMpIIAAAAASUVORK5CYII=";

var img$2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/YyTBBykUEbHYwoiFAVEQS4mgjVrECEZtkk02EbKbZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9YwIJorPM3o8zcy4zZ8A3k9dN1z8MplV0YtNRbTGxpAVe8NNNB0HCSd21Z+en4vw7Pu9oUvU2onr9v+/P0ZbOuDo0BYXHdNspCk8Iz6wVbcVbwl16LpkWPhQecuSAwldKT1X5WXG2yu+KnXhsEnyqp5Zt4FQD6znHFB4U7jfzJb12HnWT9oy1MC+1V2YfLjGmiaKRosQqeYpEpFqS2d++4R/fHAXx6PK3KeOII0tOvEOilqRrRqoheka+PGWV++88XWN0pNq9PQotT573FobADlS2Pe/ryPMqx9D8CBdW3V+QnMY/RN+ua/0HENqAs8u6ltqF803oebCTTvJHapbpMwx4PYWOBHTeQOtyNavaOif3EF+XJ7qGvX0YkP2hlW/cxWf6XLNyeQAAAAlwSFlzAAALEwAACxMBAJqcGAAAADdJREFUeNrt1LERAAAEA0DsvzO9EfjvUsrlRAAAAAAAAABwX67c3+6u7wtQgC8AAAAAAAAAwH0DNkcBCEXoxRkAAAAASUVORK5CYII=";

var img$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZHNK0RRGMZ/xmiESWEhLO5iyAKJkqVGscFiZpTBZu51Z0bNx+3eO2myVTYWykJsfC38B2yVLaUUKcnGP+BrI13vMVMzyZzbue+v55zn7ZzngG8mY2Qd/zBkc64dmQ5rC/FFLfCCn27aGCKYMBxrNjoVo+b4vKNO1dtB1av2vn9H84rpGFDXKDxmWLYrPCE8s+ZaireEO4x0YkX4UHjAlgMKXyldL/Gz4lSJ3xXbscgk+FRPLVXFehUbaTsr3C8cymYKRvk86iYtZm4+KrVLZg8OEaYJo6FTYJUMLoNSc5LZ/77hX98cefEY8rcoYosjRVq8A6IWpKspNSm6KV+Gosr9b55OcnSk1L0lDA1PnvfWC4Ed+N72vK8jz/s+hvpHuMhV/HnJafxD9O2KFjqA1g04u6xo+i6cb0Lng5WwE79SvUxfMgmvpxCMQ/sNNC2Vsiqvc3IPsXV5omvY24c+2d+6/AMRKmgSy8M37AAAAAlwSFlzAAALEwAACxMBAJqcGAAAAV1JREFUeNrtmgEKgzAMRRvJCab3P6HuCOtU5nBdY61iqcn/UJBN0f9qkxTjHARBkGGR9EfXdT72+8v7as00JNpxfd/TLgCS8bsDkEDQXuNaAIQgGsSAxOxLa+cuSnljrcbXPkYI02EUBMUIaTG/eguWwz+vJmLAOKHziAZO7bOf8mY+CwCAdQBszXBYyfLB0rbWephKLAFf8QR7xIACAGquE7KfjUvdCGkQAAAAADRVgnoKoecwuGlYLYSWi+bxaFufc36lY1Mfj99BkYtI+RLwKISQBQAAAADgZBAslQmo1jegVBr0WAKVAihVB1DNMYAsvwFIg2oAjLuj9U5JveHQI1sxLkEw920w7CTjnNYyBEEAAAD9APa2zN5RMW9olZXIKGyWjHrk1AWae4V/dnQ5a3+rryjzK9PpUjZV6Ei6pF3+avNX3INDIpqzQGxJs3SCNhCae6AhCIKgo3oDRfKqQh1Aqh4AAAAASUVORK5CYII=";

var img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABbmlDQ1BpY2MAACiRdZE7SwNBFIW/JEpEE1JoIZIihYqFgiiIpUTQRi1iBF/N7uYlZDfLboKIrWBjIViINr4K/4G2gq2CICiCiI1/wFcjst5JAgmSzDJ7P87MucycAf9M3jDdlmEwraKTmI7HFpeWY8E3WogSIoxPM1x7dn4qSdPx/YBP1fsh1av5voajI5V2DfC1CY8ZtlMUnhCeWS/aineEu4yclhI+Fh505IDCN0rXK/yqOFvhT8VOMjEJftUzlq1jvY6NnGMKDwj3mvmSUT2PukkobS3MS+2RGcUlwTRxYuiUWCNPkSGplmTW2Ddc9s1REI8hf5sNHHFkyYl3UNSSdE1LzYieli/Phsr9f55uZnSk0j0Uh9YXz/vog+Ae/O563s+J5/2eQuAZrqyavyA5jX+JvlvTeo8gsgUX1zVN34fLbeh+sjVHK0sBmf5MBt7PIbwEnXfQvlLJqrrO2SMkN+WJbuHgEPplf2T1D6TFZ+Dpj8jzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJUlEQVR42u2b6wrCMAyFF9kTuL3/q0YUlDIQrGnatPkOFPZDluY0l7NQty05pHjWCfbo9nKd6KCa4pY9BSAgOwF7w7zTRrmrRIAjzvN8rSsB0rP1VFZ86RUBUqwIbc91L+8ooAtkdv4ZBUQABEAAn8Ot8KsS1Ei+946ASJ/dSgoMIECipf8+ed2pxv04hhdB2iAEQEAcjCiCLbWAGGwsIYTUYAMhtIIQEoMN8Qjv6woHhBBtEAIgYCUhZO4gTISoAXMLIfNe0k2E6AIQAAFT6ADLoGMJHaDOzqMDousAy6Cjai/p5gHlFTlSAAJsbVD/+E24lBBH52ts6ijfI6SAjrTLJanOJyeBokBSnvi36/IAUATD/3fQxXdJ6vyHBHRA9hQA2fEADxYsjjbR70EAAAAASUVORK5CYII=";

const lineTypeIcons = {
    straight: `<img src="${img$2}"/>`,
    cloudy: `<img src="${img$h}"/>`,
};
const mainHtml = `
  <div id="main-container" class="hide-previewer disabled" 
    ondragstart="return false;" ondrop="return false;">
    <div id="viewer"></div>
    <div id="previewer"></div>
    <div id="top-panel"> 
      <div id="previewer-toggler" class="subpanel panel-item">
        <div id="toggle-previewer" class="panel-button panel-item">
          <img src="${img$4}"/>
        </div> 
      </div>
      <div id="modes" class="subpanel panel-item">
        <div id="button-mode-hand" class="panel-button panel-item">
          <img src="${img$c}"/>
        </div> 
        <div id="button-mode-annotation" class="panel-button panel-item">
          <img src="${img$5}"/>
        </div> 
        <div class="panel-v-separator margin-s-5 panel-item"></div>
        <div id="button-open-file" class="panel-button panel-item">
          <img src="${img$b}"/>
        </div> 
        <div id="button-save-file" class="panel-button panel-item">
          <img src="${img$g}"/>
        </div> 
        <div id="button-close-file" class="panel-button panel-item">
          <img src="${img$i}"/>
        </div> 
      </div>
    </div>
    <div id="bottom-panel">
      <div id="paginator" class="subpanel panel-item">
        <div id="paginator-prev" class="panel-button">
          <img src="${img$o}"/>
        </div>
        <div id="paginator-next" class="panel-button">
          <img src="${img$n}"/>
        </div>
      </div>
      <div class="panel-v-separator panel-item"></div>
      <div id="rotator" class="subpanel panel-item">        
        <div id="rotate-counterclockwise" class="panel-button">
          <img src="${img$k}"/>
        </div>
        <div id="rotate-clockwise" class="panel-button">
          <img src="${img$l}"/>
        </div>
      </div>      
      <div class="panel-v-separator panel-item"></div>
      <div id="zoomer" class="subpanel panel-item">
        <div id="zoom-out" class="panel-button">
          <img src="${img$a}"/>
        </div>
        <div id="zoom-in" class="panel-button">
          <img src="${img$7}"/>
        </div>
        <div id="zoom-fit-viewer" class="panel-button">
          <img src="${img$e}"/>
        </div>
        <div id="zoom-fit-image" class="panel-button">
          <img src="${img$f}"/>
        </div>
      </div>
    </div>
    <div id="command-panel">
      <div class="command-panel-row">
        <div id="button-command-undo" 
          class="panel-button command-panel-subitem accent">
          <img src="${img$m}"/>
        </div>
      </div>      
    </div>
    <div id="annotation-panel">
      <div class="annotation-panel-row">
        <div id="button-annotation-edit-text" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$1}"/>
        </div> 
        <div id="button-annotation-delete" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$j}"/>
        </div> 
        <div id="button-annotation-mode-select" 
          class="panel-button annotation-panel-item">
          <img src="${img$6}"/>
        </div> 
      </div>
      <div class="annotation-panel-row">
        <div id="button-annotation-stamp-undo" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$m}"/>
        </div> 
        <div id="button-annotation-stamp-clear" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$j}"/>
        </div>
        <div id="button-annotation-stamp-save" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$9}"/>
        </div> 
        <div id="button-annotation-mode-stamp" 
          class="panel-button annotation-panel-item disabled">
          <img src="${img$3}"/>
        </div> 
      </div>
      <div class="annotation-panel-row">
        <div id="button-annotation-pen-undo" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$m}"/>
        </div> 
        <div id="button-annotation-pen-clear" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$j}"/>
        </div> 
        <div id="button-annotation-pen-save" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$9}"/>
        </div> 
        <div id="button-annotation-mode-pen" 
          class="panel-button annotation-panel-item">
          <img src="${img$8}"/>
        </div> 
      </div>
      <div class="annotation-panel-row">
        <div id="button-annotation-geometric-undo" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$m}"/>
        </div> 
        <div id="button-annotation-geometric-clear" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$j}"/>
        </div> 
        <div id="button-annotation-geometric-save" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$9}"/>
        </div> 
        <div id="button-annotation-mode-geometric" 
          class="panel-button annotation-panel-item disabled">
          <img src="${img$d}"/>
        </div>
      </div>
      <div class="annotation-panel-row">
        <div id="button-annotation-text-undo" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$m}"/>
        </div> 
        <div id="button-annotation-text-clear" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$j}"/>
        </div> 
        <div id="button-annotation-text-save" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$9}"/>
        </div> 
        <div id="button-annotation-mode-text" 
          class="panel-button annotation-panel-item disabled">
          <img src="${img}"/>
        </div>
      </div>
    </div>

    <div id="focused-annotation-panel">
      <p id="focused-annotation-author" class="line-clamp"></p>
      <p id="focused-annotation-date" class="line-clamp"></p>
      <p id="focused-annotation-text" class="line-clamp"></p>
    </div>

    <input id="open-file-input" type="file" multiple="true" class="abs-hidden">
  </div>
`;
const textDialogHtml = `
  <div class="abs-full-size-overlay text-dialog">
    <div class="form">
      <textarea class="text-input" maxlength="1024"></textarea>
      <div class="buttons">
        <div class="panel-button text-ok">
          <img src="${img$9}"/>
        </div>
        <div class="panel-button text-cancel">
          <img src="${img$j}"/>
        </div>
      </div>
    </div>
  </div>
`;
const loaderHtml = `
  <div class="abs-full-size-overlay">
    <div class="loader">
      <div></div>
      <div></div>
      <div></div>
    </div>
  </div>
`;

const styles = `
<style>
:host {
    --tsimage-color-primary-final: var(--tsimage-color-primary, rgba(40,40,40,1));
    --tsimage-color-primary-tr-final: var(--tsimage-color-primary-tr, rgba(40,40,40,0.9));
    --tsimage-color-secondary-final: var(--tsimage-color-secondary, rgba(60,60,60,1));
    --tsimage-color-secondary-tr-final: var(--tsimage-color-secondary-tr, rgba(60,60,60,0.9));
    --tsimage-color-accent-final: var(--tsimage-color-accent, rgba(96,96,96,1));
    --tsimage-color-shadow-final: var(--tsimage-color-shadow, rgba(0,0,0,0.75));
    --tsimage-color-bg-final: var(--tsimage-color-bg, rgba(128,128,128,1));
    --tsimage-color-fg-primary-final: var(--tsimage-color-fg-primary, rgba(255,255,255,1));
    --tsimage-color-fg-secondary-final: var(--tsimage-color-fg-secondary, rgba(187,187,187,1));
    --tsimage-color-fg-accent-final: var(--tsimage-color-fg-accent, rgba(255,204,0,1));
    --tsimage-color-text-selection-final: var(--tsimage-color-text-selection, rgba(104,104,128,0.3));
  }

  .disabled {
    pointer-events: none !important;
  }

  .relative {
    position: relative;
  }
  .absolute {
    position: absolute;
  }
  .abs-hidden {
    position: absolute;
    opacity: 0;
    z-index: -10;
  }
  .abs-stretch {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
  }
  .abs-topleft {
    position: absolute;
    left: 0;
    top: 0;
  }
  .stretch {
    width: 100%;
    height: 100%;
  }
  
  .no-margin {
    margin: 0;
  }
  .no-padding {
    padding: 0;
  }
  .margin-s-5 {
    margin: 0 5px;
  }

  .line-clamp {
    display: -webkit-box;
    -webkit-line-clamp: 1;
    -webkit-box-orient: vertical; 
    overflow: hidden; 
  }

  #main-container {
    box-sizing: border-box;
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: stretch;
    align-items: stretch;
    width: 100%;
    height: 100%;
    background: var(--tsimage-color-bg-final);
  }

  #top-panel {
    position: relative;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
    width: 100%;
    height: 50px;
    background: var(--tsimage-color-primary-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
    z-index: 4;
    transition: height 0.25s ease-out 0.1s;
  }
  .hide-panels #top-panel {
    height: 0;
    transition: height 0.25s ease-in 0.2s;
  }

  #bottom-panel {
    position: absolute;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    flex-grow: 0;
    flex-shrink: 0;
    left: calc(50% - 160px);
    bottom: 20px;
    width: 320px;
    height: 50px;  
    background: var(--tsimage-color-primary-tr-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
    z-index: 4;
    transition: height 0.25s ease-out, bottom 0.1s linear 0.25s;
  }
  .hide-panels #bottom-panel {
    bottom: 0;
    height: 0;
    transition: bottom 0.1s linear 0.1s, height 0.25s ease-in 0.2s;
  }
  .compact #bottom-panel {  
    left: calc(50% - 120px);  
    width: 240px;
  }
  .compact #zoom-fit-viewer,
  .compact #zoom-fit-image {  
    width: 0;  
    transform: scale(0);
  }

  #focused-annotation-panel {
    box-sizing: border-box;
    position: absolute;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: stretch;
    flex-grow: 0;
    flex-shrink: 0;
    left: calc(50% - 120px);
    top: 80px;
    width: 240px;
    height: 84px; 
    padding: 18px;
    border-radius: 18px;
    background: var(--tsimage-color-secondary-tr-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
    opacity: 0;
    transform: scale(0);
    transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
    z-index: 4;
    pointer-events: none;
  }
  .mobile #focused-annotation-panel {
    left: 20px;
    width: 150px;
  }
  .annotation-focused #focused-annotation-panel {
    opacity: 100;
    transform: scale(1);    
    transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
  }
  #focused-annotation-panel p {
    margin: 0;
    padding: 0;
    line-height: 16px;
    font-size: 12px;
    font-family: sans-serif;
    color: var(--tsimage-color-fg-primary-final);
  }
  
  #annotation-panel,
  #command-panel {
    position: absolute;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-end;
    flex-grow: 1;
    flex-shrink: 1;
    right: 20px;
    pointer-events: none;
  }
  #annotation-panel {
    top: 125px;
    z-index: -5;
    transition: z-index 0s linear 0.25s;
  }
  #command-panel {
    top: 80px;
    z-index: 5;
  }
  .mode-annotation #annotation-panel {
    z-index: 5;
  }
  
  .annotation-panel-row,
  .command-panel-row {      
      display: flex;
      flex-direction: row;
      justify-content: flex-end;
      align-items: center;
      flex-grow: 1;
      flex-shrink: 1;
    }

  .annotation-panel-item {
    margin: 3px;
    cursor: default;      
    opacity: 0;
    background: var(--tsimage-color-primary-tr-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
    transform: scale(0);
    transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
    pointer-events: all;
  }    
  .mode-annotation .annotation-panel-item { 
    cursor: pointer;
    opacity: 100;
    transform: scale(1);    
    transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
  }

  .annotation-panel-subitem,
  .command-panel-subitem {
    margin: 3px;    
    background: var(--tsimage-color-secondary-tr-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
    pointer-events: all;
  }    
  .command-panel-subitem.accent:hover,
  .command-panel-subitem.accent.on {
    box-shadow: 0 0 10px var(--tsimage-color-fg-accent-final);
  }
  :not(.undoable-commands) #button-command-undo,
  :not(.annotation-selected) #button-annotation-edit-text,
  :not(.annotation-selected) #button-annotation-delete,
  :not(.stamp-annotator-data-undoable) #button-annotation-stamp-undo,
  :not(.stamp-annotator-data-clearable) #button-annotation-stamp-clear,
  :not(.stamp-annotator-data-saveable) #button-annotation-stamp-save,
  :not(.pen-annotator-data-undoable) #button-annotation-pen-undo,
  :not(.pen-annotator-data-clearable) #button-annotation-pen-clear,
  :not(.pen-annotator-data-saveable) #button-annotation-pen-save,
  :not(.text-annotator-data-undoable) #button-annotation-text-undo,
  :not(.text-annotator-data-clearable) #button-annotation-text-clear,
  :not(.text-annotator-data-saveable) #button-annotation-text-save,
  :not(.geom-annotator-data-undoable) #button-annotation-geometric-undo,
  :not(.geom-annotator-data-clearable) #button-annotation-geometric-clear,
  :not(.geom-annotator-data-saveable) #button-annotation-geometric-save {
    cursor: default;      
    opacity: 0;
    transform: scale(0);
    transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
  }
  .undoable-commands #button-command-undo,
  .annotation-selected #button-annotation-edit-text,
  .annotation-selected #button-annotation-delete,
  .stamp-annotator-data-undoable #button-annotation-stamp-undo,
  .stamp-annotator-data-clearable #button-annotation-stamp-clear,
  .stamp-annotator-data-saveable #button-annotation-stamp-save,
  .pen-annotator-data-undoable #button-annotation-pen-undo,
  .pen-annotator-data-clearable #button-annotation-pen-clear,
  .pen-annotator-data-saveable #button-annotation-pen-save,
  .text-annotator-data-undoable #button-annotation-text-undo,
  .text-annotator-data-clearable #button-annotation-text-clear,
  .text-annotator-data-saveable #button-annotation-text-save,
  .geom-annotator-data-undoable #button-annotation-geometric-undo,
  .geom-annotator-data-clearable #button-annotation-geometric-clear,
  .geom-annotator-data-saveable #button-annotation-geometric-save { 
    cursor: pointer;
    opacity: 100;
    transform: scale(1);    
    transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
  }

  .panel-v-separator {
    width: 1px;
    height: 30px;
    background-color: var(--tsimage-color-fg-secondary-final);
  }

  .panel-button {
    cursor: pointer;
    user-select: none;
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    flex-grow: 0;
    justify-content: center;
    align-items: center;
    width: 36px;
    height: 36px;
    border-radius: 50%;
  }
  .panel-button:hover,
  .panel-button.on {
    background-color: var(--tsimage-color-accent-final);
  }
  .panel-button.accent,
  .panel-button.accent:hover,
  .panel-button.accent.on {
    background-color: var(--tsimage-color-fg-accent-final);
  }
  .panel-button img {
    width: 20px;
    height: 20px;
    filter: invert() opacity(0.7) drop-shadow(0 0 0 var(--tsimage-color-fg-primary-final)) saturate(1000%);
  }  
  .panel-button:hover img,
  .panel-button.on img {
    filter: invert() opacity(0.7) drop-shadow(0 0 0 var(--tsimage-color-fg-accent-final)) saturate(1000%);
  }  
  .panel-button.accent img,  
  .panel-button.accent:hover img,
  .panel-button.accent.on img {
    filter: opacity(0.7) drop-shadow(0 0 0 var(--tsimage-color-primary-final)) saturate(1000%);
  }
  .disabled .panel-button img,
  .panel-button.disabled img {
    filter: invert() opacity(0.2) drop-shadow(0 0 0 var(--tsimage-color-fg-primary-final)) saturate(1000%);
  }  
  .context-menu-content .panel-button {
    margin: 1px;
  }
  
  .subpanel {
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    margin: 0 4px;
  }    
  
  .panel-item {
    transform: scale(1);
    transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
  }
  .hide-panels .panel-item {
    cursor: default;      
    opacity: 0;
    transform: scale(0);
    transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
  }

  #paginator {  
    user-select: none;
    font-family: sans-serif;
    font-size: 16px;
    color: var(--tsimage-color-fg-primary-final);
  }

  #toggle-previewer {
    margin: 4px;
  }
    
  #previewer {
    box-sizing: border-box;
    position: absolute;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    overflow-x: hidden;
    overflow-y: auto;
    left: 0;
    top: 50px;
    bottom: 0;
    width: 160px; 
    padding-top: 0px;
    background: var(--tsimage-color-secondary-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
    z-index: 3;
    transition: padding-top 0.25s ease-out 0.1s, top 0.25s ease-out 0.1s, width 0.25s ease-out;
  } 
  .hide-panels #previewer {
    top: 0;
    padding-top: 50px;
    transition: padding-top 0.25s ease-in 0.2s, top 0.25s ease-in 0.2s;
  }   
  .mobile #previewer {
    background: var(--tsimage-color-secondary-tr-final);
  } 
  .hide-previewer #previewer {
    width: 0;
    transition: width 0.25s ease-in 0.1s;
  }
  #previewer .image-preview {      
    transform: scaleX(1);
    transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
  }
  .hide-previewer #previewer .image-preview {
    opacity: 0;
    transform: scaleX(0);
    transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
  }

  #viewer {
    box-sizing: border-box;
    position: absolute;
    display: flex;
    flex-direction: column;
    overflow: auto;
    left: 160px;
    right: 0;
    top: 50px;
    bottom: 0;
    padding-top: 0;
    transition: padding-top 0.25s ease-out 0.1s, top 0.25s ease-out 0.1s, left 0.25s ease-out;
  }
  #viewer.dialog-shown {
    overflow: hidden;
  }
  .mode-hand #viewer {
    cursor: grab !important;
    user-select: none !important;
  }
  .hide-panels #viewer {
    top: 0;
    padding-top: 50px;
    transition: padding-top 0.25s ease-in 0.2s, top 0.25s ease-in 0.2s;
  }      
  .hide-panels.mobile #viewer,
  .hide-panels.hide-previewer #viewer {
    top: 0;
    padding-top: 50px;
    left: 0;
    transition: padding-top 0.25s ease-in 0.2s, top 0.25s ease-in 0.2s, left 0.25s ease-in;
  }   
  .mobile #viewer,
  .hide-previewer #viewer {
    top: 50px;
    padding-top: 0px;
    left: 0;
    transition: padding-top 0.25s ease-out 0.1s, top 0.25s ease-out 0.1s, left 0.25s ease-in;
  }
  
  #annotation-overlay-container {
    position: absolute;
    top: 0; 
    right: 0;
    bottom: 0;
    left: 0; 
    margin-top: 0;
    transition: margin-top 0.25s ease-out 0.1s;
    z-index: 3;
  }
  .hide-panels #annotation-overlay-container {
    margin-top: 50px;
    transition: margin-top 0.25s ease-in 0.2s;
  }
  .mode-text-markup #annotation-overlay-container {
    pointer-events: none;
  }
  
  #annotation-overlay {
    position: absolute;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    touch-action: none;
  }

  .image-container {    
    position: relative;
    display: flex;
    flex-grow: 0;
    flex-shrink: 0;
    margin: auto;
    background-color: white;
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
  }
  .image {    
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;    
    transform-origin: left top;
  }
  .image-preview {   
    cursor: pointer; 
    position: relative;
    display: flex;
    flex-grow: 0;
    flex-shrink: 0;
    margin: 0 auto;
    background-color: white;
    background-clip: content-box;
    border-style: solid;
    border-width: 10px 10px 20px 10px;
    border-color: transparent;
  }
  .image-preview:hover,
  .image-preview.current {
    border-color: var(--tsimage-color-accent-final);
  }
  .image-preview::after {
    display: inline-block;
    position: absolute;
    top: calc(100% + 3px);
    width: 100%;
    text-align: center;
    font-family: sans-serif;
    font-size: 14px;
    line-height: 1;
    color: var(--tsimage-color-fg-primary-final);
    content: attr(data-image-index) " ";
  }

  .image-canvas {
    background-color: white;
  } 
  
  .image-annotations {
    width: 0;
    height: 0;
  }
  .mode-text-markup .image-annotations,
  .mode-text .image-annotations,
  .mode-hand .image-annotations {
    pointer-events: none;
  }
  .image-annotations-controls,
  .annotation-content,
  .annotation-content-element {    
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
  }
  .image-annotations-controls {
    z-index: 2;
  }
  .annotation-content {
    pointer-events: none;
  }

  .abs-full-size-overlay {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: var(--tsimage-color-secondary-tr-final);
    touch-action: none;
  }
  
  .fixed-full-size-overlay {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: var(--tsimage-color-secondary-tr-final);
  }
  
  .text-dialog {
    z-index: 9;
  }
  .text-dialog .form {
    box-sizing: border-box;
    position: absolute;
    display: flex;
    flex-direction: column;
    justify-content: stretch;
    align-items: stretch;
    flex-grow: 0;
    flex-shrink: 0;
    left: calc(50% - 160px);
    top: calc(50% - 120px);
    width: 320px;
    height: 240px;
    padding: 5px;
    background: var(--tsimage-color-primary-tr-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
  }
  .text-dialog textarea {
    height: 100%;
    margin: 0 0 5px 0;
    padding: 5px;
    font-size: 14px;
    resize: none;
    outline: none;
    border: none;
    color: var(--tsimage-color-fg-primary-final);
    background-color: var(--tsimage-color-primary-final);
  }
  .text-dialog textarea::placeholder {
    font-size: 14px;
    font-style: italic;
    color: var(--tsimage-color-fg-primary-final);
  }
  .text-dialog .buttons {
    display: flex;
    flex-direction: row;
    justify-content: flex-end;
    align-items: center;
    flex-grow: 1;
    flex-shrink: 1;
  } 
  
  .stamp-dialog {
    z-index: 9;
  }
  .stamp-dialog .form {
    position: absolute;
    display: flex;
    flex-direction: column;
    justify-content: stretch;
    align-items: stretch;
    flex-grow: 0;
    flex-shrink: 0;
    left: 50%;
    top: 50%;
    width: 100%;
    height: 100%;
    max-width: 720px;
    max-height: 720px;
    background: var(--tsimage-color-primary-tr-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
    transform-origin: center;
    transform: translate(-50%, -50%)
  }
  .stamp-dialog .buttons {
    display: flex;
    flex-direction: row;
    justify-content: flex-end;
    align-items: center;
    height: 40px;
  } 
  .stamp-dialog .form-canvas-wrapper {
    position: relative;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    margin: 20px;
    flex-grow: 1;
    flex-shrink: 1;
  } 
  .stamp-dialog input {
    width: 100%;
    margin: 10px;
    padding: 5px;
    font-size: 16px;
    outline: none;
    border: none;
    color: var(--tsimage-color-fg-primary-final);
    background-color: var(--tsimage-color-primary-final);
  }
  .stamp-dialog input::placeholder {
    font-size: 14px;
    font-style: italic;
    color: var(--tsimage-color-fg-primary-final);
  }
  .stamp-input-row {    
    display: flex;
    flex-direction: row;
    justify-content: stretch;
    align-items: center;
    height: 30px;
    margin: 10px;
  }
  .stamp-input-row p {
    user-select: none;
    margin: 0;   
    padding: 0 10px;
    font-family: sans-serif; 
    font-size: 16px;
    white-space: nowrap;
    color: var(--tsimage-color-fg-secondary-final);
  }
  
  .abs-ratio-canvas {
    outline: 0;
    position: absolute;
    width: 100%;
    height: auto;
    max-height: 100%;
    border: 2px solid var(--tsimage-color-fg-secondary-final);
  }

  .annotation-temp-copy {
    opacity: 0.2;
  }  
  .annotation-controls {
    cursor: pointer;
  }     
  .annotation-out-of-image {
    cursor: not-allowed;
  }
  .annotation-rect,
  .annotation-bbox {
    fill: none;
  }
  .mode-annotation .annotation-controls.selected {
    cursor: grab;
  } 
  .mode-annotation .annotation-controls.selected .annotation-rect {
    stroke: rgba(80, 80, 80, 0.5);
    stroke-dasharray: 3 3;
  }
  .mode-annotation .annotation-controls.selected .annotation-bbox {
    stroke: rgba(80, 80, 80, 1);
    stroke-dasharray: 3 3;
  }   
  .mode-annotation .annotation-controls.focused .annotation-bbox {
    stroke: rgba(255, 165, 0, 1);
    stroke-dasharray: 3 0;
  } 
  .mode-annotation .annotation-controls.selected .annotation-handle {
    stroke-width: 16;
    stroke-linecap: round;
    vector-effect: non-scaling-stroke;
    cursor: pointer;
  }
  .mode-annotation .annotation-controls.selected .annotation-handle.helper {
    stroke-width: 12;
    stroke: rgba(200, 200, 50, 0.75);
  }
  .mode-annotation .annotation-controls.selected .annotation-handle.scale {
    stroke: rgba(0, 0, 0, 0.75);
  }
  .mode-annotation .annotation-controls.selected .annotation-handle.rotation {
    stroke: rgba(50, 100, 50, 0.75);
  }
  .mode-annotation .annotation-controls.selected .annotation-handle.translation {
    stroke: rgba(100, 100, 200, 0.75);
  }
  .mode-annotation .annotation-controls.selected .annotation-rotator {
    fill: none;
    cursor: pointer;
  }
  .mode-annotation .annotation-controls.selected .annotation-rotator .circle {
    r: 25;
  }
  .mode-annotation .annotation-controls.selected .annotation-rotator .dashed {
    stroke: rgba(80, 80, 80, 1);
    stroke-dasharray: 3 3;
  }

  #context-menu {
    box-sizing: border-box;
    position: absolute;
    z-index: 5;
    min-width: 50px;
    min-height: 50px;
    max-height: 300px;
    padding: 5px;
    background: var(--tsimage-color-secondary-tr-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
    display: flex;
    flex-direction: column;
    justify-content: stretch;
    align-items: stretch;
    overflow-y: auto;
  }
  .context-menu-content {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-grow: 1;
    flex-shrink: 0;
  }
  .context-menu-content.row {
    flex-direction: row;
  }
  .context-menu-content.column {
    flex-direction: column;
  }
  .context-menu-color-icon {
    width: 20px;
    height: 20px;
    border-radius: 12px;
    border-width: 2px;
    border-style: solid;
    border-color: var(--tsimage-color-fg-secondary-final);
  }
  .context-menu-stamp-select-button {
    box-sizing: border-box;
    cursor: pointer;
    user-select: none;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-start;
    width: 100%;
    height: 36px;
    padding: 0 5px;
    border-radius: 5px;
    font-family: sans-serif;
    font-size: 16px;
    color: var(--tsimage-color-fg-primary-final); 
  }
  .context-menu-stamp-select-button:hover,
  .context-menu-stamp-select-button.on {
    background-color: var(--tsimage-color-accent-final);
  }
  .context-menu-slider {
    -webkit-appearance: none;
    appearance: none;
    outline: none;
    margin: 10px;
    height: 5px;
    border-radius: 5px;
    cursor: pointer;
    background-color: var(--tsimage-color-fg-secondary-final);
  }
  .context-menu-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    outline: none;
    width: 20px;
    height: 20px;
    border-radius: 10px;
    cursor: pointer;
    background-color: var(--tsimage-color-accent-final);
  }
  .context-menu-slider::-moz-range-thumb {
    outline: none; 
    width: 20px;
    height: 20px;
    border-radius: 10px;
    cursor: pointer;
    background-color: var(--tsimage-color-accent-final);
  }

  #button-open-file {
    pointer-events: auto !important;
  }
  .disabled #button-open-file img {
    filter: invert() opacity(0.7) drop-shadow(0 0 0 var(--tsimage-color-fg-primary-final)) saturate(1000%);
  }

  .loader {
    position: absolute;
    left: calc(50% - 30px);
    top: calc(50% - 30px);
    width: 60px;
    height: 60px;
  }
  .loader div {   
    position: absolute; 
    width: 20px;
    height: 20px;
    margin: 5px;
    border-radius: 5px;
    animation-duration: 3s;
    animation-timing-function: linear;
    animation-iteration-count: infinite;
  }
  .loader div:nth-child(1) {
    animation-name: loaderone;
    background-color: var(--tsimage-color-accent-final);
  }
  .loader div:nth-child(2) {
    animation-name: loadertwo;
    background-color: var(--tsimage-color-fg-primary-final);  
  }
  .loader div:nth-child(3) {  
    animation-name: loaderthree;
    background-color: var(--tsimage-color-fg-secondary-final);  
  }

  @keyframes loaderone {
    from {
      left: 0;
      top: 0;
    }
    8.3% {
      left: 0;
      top: 0;
    }
    16.7% {
      left: 0;
      top: 0;
    }
    25% { 
      left: 30px;
      top: 0px; 
    }
    33.3% {
      left: 30px;
      top: 0px;        
    }
    41.7% {
      left: 30px;
      top: 0px;        
    }
    50% {
      left: 30px;
      top: 30px;         
    }
    58.3% {
      left: 30px;
      top: 30px;       
    }
    66.7% {      
      left: 30px;
      top: 30px;   
    }
    75% {
      left: 0;
      top: 30px;
    }
    83.3% {
      left: 0;
      top: 30px;
    }
    91.7% {
      left: 0;
      top: 30px;
    }
    to {   
      left: 0;
      top: 0;   
    }
  }
  @keyframes loadertwo {
    from {
      left: 30px;
      top: 0px;
    }
    8.3% {
      left: 30px;
      top: 0px;
    }
    16.7% {
      left: 30px;
      top: 30px;
    }
    25% { 
      left: 30px;
      top: 30px;
    }
    33.3% {
      left: 30px;
      top: 30px;
    }
    41.7% {
      left: 0;
      top: 30px;
    }
    50% {
      left: 0;
      top: 30px;
    }
    58.3% {
      left: 0;
      top: 30px;
    }
    66.7% {
      left: 0;
      top: 0;
    }
    75% {
      left: 0;
      top: 0;
    }
    83.3% {
      left: 0;
      top: 0;
    }
    91.7% {
      left: 30px;
      top: 0px;
    }
    to {
      left: 30px;
      top: 0px;
    }
  }
  @keyframes loaderthree {
    from {
      left: 30px;
      top: 30px;
    }
    8.3% {
      left: 0;
      top: 30px;
    }
    16.7% {
      left: 0;
      top: 30px;
    }
    25% { 
      left: 0;
      top: 30px;
    }
    33.3% {
      left: 0;
      top: 0;
    }
    41.7% {
      left: 0;
      top: 0;
    }
    50% {
      left: 0;
      top: 0;
    }
    58.3% {
      left: 30px;
      top: 0; 
    }
    66.7% {
      left: 30px;
      top: 0;
    }
    75% {
      left: 30px;
      top: 0;
    }
    83.3% {
      left: 30px;
      top: 30px;
    }
    91.7% {
      left: 30px;
      top: 30px;
    }
    to {
      left: 30px;
      top: 30px; 
    }
  }
</style>
`;

var __awaiter$a = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function htmlToElements(html) {
    const template = document.createElement("template");
    template.innerHTML = html;
    const nodes = [];
    template.content.childNodes.forEach(x => {
        if (x instanceof HTMLElement) {
            nodes.push(x);
        }
    });
    return nodes;
}
function downloadFile(blob, name) {
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.setAttribute("download", name);
    link.href = url;
    document.body.appendChild(link);
    link.click();
    link.remove();
    setTimeout(() => URL.revokeObjectURL(url), 10000);
}
function loadImageAsync(url, revoke = false) {
    return __awaiter$a(this, void 0, void 0, function* () {
        const loadedImage = yield new Promise((resolve, reject) => {
            const image = new Image();
            image.onerror = (e) => {
                if (revoke) {
                    URL.revokeObjectURL(url);
                }
                console.log(`Error while loading image: ${e}`);
                resolve(null);
            };
            image.onload = () => {
                if (revoke) {
                    URL.revokeObjectURL(url);
                }
                resolve(image);
            };
            image.src = url;
        });
        return loadedImage;
    });
}

class EventService {
    constructor(container) {
        this._eventMap = new Map();
        if (!container) {
            throw new Error("Container is not defined");
        }
        const element = document.createElement("div");
        element.style.position = "absolute";
        element.style.width = "0";
        element.style.height = "0";
        element.style.zIndex = "-1000";
        container.append(element);
        this._element = element;
    }
    get element() {
        return this._element;
    }
    destroy() {
        this.removeAllListeners();
        this._element.remove();
        this._element = null;
    }
    addListener(key, listener, options) {
        if (!this._element) {
            return;
        }
        this._element.addEventListener(key, listener, options);
        if (this._eventMap.has(key)) {
            this._eventMap.get(key).add(listener);
        }
        else {
            this._eventMap.set(key, new Set().add(listener));
        }
    }
    removeListener(key, listener) {
        if (!this._element) {
            return;
        }
        this._element.removeEventListener(key, listener);
        if (this._eventMap.has(key)) {
            this._eventMap.get(key).delete(listener);
        }
    }
    removeAllListenersForKey(key) {
        if (!this._element) {
            return;
        }
        if (this._eventMap.has(key)) {
            const listeners = this._eventMap.get(key);
            listeners.forEach(x => this._element.removeEventListener(key, x));
            this._eventMap.delete(key);
        }
    }
    removeAllListeners() {
        if (!this._element) {
            return;
        }
        this._eventMap.forEach((v, k) => {
            v.forEach(x => this._element.removeEventListener(k, x));
        });
        this._eventMap.clear();
    }
    getListenersByKey(key) {
        const listenerSet = this._eventMap.get(key);
        return listenerSet
            ? [...listenerSet]
            : [];
    }
    hasListenersForKey(key) {
        const listenerSet = this._eventMap.get(key);
        return !!(listenerSet === null || listenerSet === void 0 ? void 0 : listenerSet.size);
    }
    dispatchEvent(e) {
        if (!this._element) {
            return;
        }
        if (!this.hasListenersForKey(e.type)) {
            return;
        }
        this._element.dispatchEvent(e);
    }
}

const imageChangeEvent = "tsimage-imagechange";
const scaleChangedEvent = "tsimage-scalechanged";
const annotSelectionRequestEvent = "tsimage-annotselectionrequest";
const annotFocusRequestEvent = "tsimage-annotfocusrequest";
const annotEditRequestEvent = "tsimage-annoteditrequest";
const annotChangeEvent = "tsimage-annotchange";
const imageServiceStateChangeEvent = "tsimage-imageservicechange";
class ImageEvent extends CustomEvent {
    constructor(detail) {
        super(imageChangeEvent, { detail });
    }
}
class ScaleChangedEvent extends CustomEvent {
    constructor(detail) {
        super(scaleChangedEvent, { detail });
    }
}
class AnnotSelectionRequestEvent extends CustomEvent {
    constructor(detail) {
        super(annotSelectionRequestEvent, { detail });
    }
}
class AnnotFocusRequestEvent extends CustomEvent {
    constructor(detail) {
        super(annotFocusRequestEvent, { detail });
    }
}
class AnnotEditRequestEvent extends CustomEvent {
    constructor(detail) {
        super(annotEditRequestEvent, { detail });
    }
}
class AnnotEvent extends CustomEvent {
    constructor(detail) {
        super(annotChangeEvent, { detail });
    }
}
class ImageServiceStateChangeEvent extends CustomEvent {
    constructor(detail) {
        super(imageServiceStateChangeEvent, { detail });
    }
}

class ContextMenu {
    constructor() {
        this.onPointerDownOutside = (e) => {
            if (!this._shown) {
                return;
            }
            const target = e.composedPath()[0];
            if (!target.closest("#context-menu")) {
                this.hide();
            }
        };
        this._container = document.createElement("div");
        this._container.id = "context-menu";
        this.hide();
        document.addEventListener("pointerdown", this.onPointerDownOutside);
    }
    set content(value) {
        var _a;
        (_a = this._content) === null || _a === void 0 ? void 0 : _a.forEach(x => x.remove());
        if (value === null || value === void 0 ? void 0 : value.length) {
            value.forEach(x => this._container.append(x));
            this._content = value;
        }
        else {
            this._content = null;
        }
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(value) {
        this._enabled = !!value;
    }
    destroy() {
        this.clear();
        document.removeEventListener("pointerdown", this.onPointerDownOutside);
    }
    show(pointerPosition, parent) {
        parent.append(this._container);
        this._shown = true;
        setTimeout(() => {
            this.setContextMenuPosition(pointerPosition, parent);
            this._container.style.opacity = "1";
        }, 0);
    }
    hide() {
        this._container.style.opacity = "0";
        this._container.remove();
        this._shown = false;
    }
    clear() {
        this.hide();
        this.content = null;
    }
    setContextMenuPosition(pointerPosition, parent) {
        const menuDimension = new Vec2(this._container.offsetWidth, this._container.offsetHeight);
        const menuPosition = new Vec2();
        const parentRect = parent.getBoundingClientRect();
        const relPointerPosition = new Vec2(pointerPosition.x - parentRect.x, pointerPosition.y - parentRect.y);
        if (relPointerPosition.x + menuDimension.x > parentRect.width + parentRect.x) {
            menuPosition.x = relPointerPosition.x - menuDimension.x;
        }
        else {
            menuPosition.x = relPointerPosition.x;
        }
        if (relPointerPosition.y + menuDimension.y > parentRect.height + parentRect.y) {
            menuPosition.y = relPointerPosition.y - menuDimension.y;
        }
        else {
            menuPosition.y = relPointerPosition.y;
        }
        this._container.style.left = menuPosition.x + parent.scrollLeft + "px";
        this._container.style.top = menuPosition.y + parent.scrollTop + "px";
    }
}

function getRandomUuid() {
    return v4();
}

const annotatorTypes = ["geom", "pen", "stamp", "text"];
const annotatorDataChangeEvent = "tsimage-annotatordatachange";
class AnnotatorDataChangeEvent extends CustomEvent {
    constructor(detail) {
        super(annotatorDataChangeEvent, { detail });
    }
}
class Annotator {
    constructor(imageService, parent) {
        this.onImageChange = (event) => {
            this.refreshViewBox();
        };
        this.onStateChange = (event) => {
            this.refreshViewBox();
        };
        this.onParentScroll = () => {
            this.refreshViewBox();
        };
        this.onOverlayPointerDown = (e) => {
            if (!e.isPrimary) {
                return;
            }
            this._lastPointerDownInfo = {
                timestamp: performance.now(),
                clientX: e.clientX,
                clientY: e.clientY,
            };
        };
        if (!imageService) {
            throw new Error("Image service not defined");
        }
        if (!parent) {
            throw new Error("Parent container not defined");
        }
        this._imageService = imageService;
        this._parent = parent;
    }
    get overlayContainer() {
        return this._overlayContainer;
    }
    destroy() {
        var _a, _b, _c;
        this._imageService.eventService.removeListener(imageChangeEvent, this.onImageChange);
        this._imageService.eventService.removeListener(imageServiceStateChangeEvent, this.onStateChange);
        (_a = this._parent) === null || _a === void 0 ? void 0 : _a.removeEventListener("scroll", this.onParentScroll);
        (_b = this._parentMutationObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this._parentResizeObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
        this._overlayContainer.remove();
    }
    refreshViewBox() {
        const { width: w, height: h } = this._overlay.getBoundingClientRect();
        if (!w || !h) {
            return;
        }
        this._overlay.style.left = this._parent.scrollLeft + "px";
        this._overlay.style.top = this._parent.scrollTop + "px";
        const viewBoxWidth = w / this._imageService.scale;
        const viewBoxHeight = h / this._imageService.scale;
        this._svgWrapper.setAttribute("viewBox", `0 0 ${viewBoxWidth} ${viewBoxHeight}`);
        this.refreshGroupPosition();
    }
    init() {
        const annotationOverlayContainer = document.createElement("div");
        annotationOverlayContainer.id = "annotation-overlay-container";
        const annotationOverlay = document.createElement("div");
        annotationOverlay.id = "annotation-overlay";
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.classList.add("abs-stretch", "no-margin", "no-padding");
        svg.setAttribute("opacity", "0.5");
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svg.append(g);
        annotationOverlay.append(svg);
        annotationOverlayContainer.append(annotationOverlay);
        this._overlayContainer = annotationOverlayContainer;
        this._overlay = annotationOverlay;
        this._svgWrapper = svg;
        this._svgGroup = g;
        this._parent.append(this._overlayContainer);
        this.refreshViewBox();
        this.initEventHandlers();
    }
    initEventHandlers() {
        this._overlay.addEventListener("pointerdown", this.onOverlayPointerDown);
        this._parent.addEventListener("scroll", this.onParentScroll);
        const parentRObserver = new ResizeObserver((entries) => {
            this.refreshViewBox();
        });
        const parentMObserver = new MutationObserver((mutations) => {
            const record = mutations[0];
            if (!record) {
                return;
            }
            record.addedNodes.forEach(x => {
                const element = x;
                if (element.classList.contains("image")) {
                    parentRObserver.observe(x);
                }
            });
            record.removedNodes.forEach(x => parentRObserver.unobserve(x));
            this.refreshViewBox();
        });
        parentRObserver.observe(this._parent);
        parentMObserver.observe(this._parent, {
            attributes: false,
            childList: true,
            subtree: false,
        });
        this._parentMutationObserver = parentMObserver;
        this._parentResizeObserver = parentRObserver;
        this._imageService.eventService.addListener(imageChangeEvent, this.onImageChange);
        this._imageService.eventService.addListener(imageServiceStateChangeEvent, this.onStateChange);
    }
    updatePointerCoords(clientX, clientY) {
        var _a;
        const imageCoords = (_a = this._imageService
            .currentImageView) === null || _a === void 0 ? void 0 : _a.getImageCoordsUnderPointer(clientX, clientY);
        if (!imageCoords) {
            this._svgGroup.classList.add("annotation-out-of-image");
        }
        else {
            this._svgGroup.classList.remove("annotation-out-of-image");
        }
        this._pointerCoordsInImageCS = imageCoords;
    }
}

class SmoothPath {
    constructor(options) {
        this._paths = [];
        this._positionBuffer = [];
        this._bufferSize = (options === null || options === void 0 ? void 0 : options.bufferSize) || SmoothPath._defaultBufferSize;
        this._uuid = options === null || options === void 0 ? void 0 : options.uuid;
    }
    get uuid() {
        return this._uuid;
    }
    get bufferSize() {
        return this._bufferSize;
    }
    get paths() {
        return this._paths.slice();
    }
    get pathCount() {
        return this._paths.length;
    }
    endPath() {
        if (this._currentPath && this._currentPath.positions.length > 1) {
            this._paths.push(this._currentPath);
        }
        this._positionBuffer = null;
        this._currentPath = null;
        this._currentPathString = null;
    }
    addPosition(pos) {
        this.appendPositionToBuffer(pos);
        this.updateCurrentPath();
    }
    appendPositionToBuffer(pos) {
        const buffer = this._positionBuffer;
        buffer.push(pos);
        this._positionBuffer = buffer
            .slice(Math.max(0, buffer.length - this._bufferSize), buffer.length);
    }
    getAverageBufferPosition(offset) {
        const len = this._positionBuffer.length;
        if (len >= this._bufferSize) {
            let totalX = 0;
            let totalY = 0;
            let pos;
            let i;
            let count = 0;
            for (i = offset; i < len; i++) {
                count++;
                pos = this._positionBuffer[i];
                totalX += pos.x;
                totalY += pos.y;
            }
            return new Vec2(totalX / count, totalY / count);
        }
        return null;
    }
    updateCurrentPath() {
        let pos = this.getAverageBufferPosition(0);
        if (!pos) {
            return null;
        }
        this._currentPathString += " L" + pos.x + " " + pos.y;
        this._currentPath.positions.push(pos);
        let tmpPath = "";
        for (let offset = 2; offset < this._positionBuffer.length; offset += 2) {
            pos = this.getAverageBufferPosition(offset);
            tmpPath += " L" + pos.x + " " + pos.y;
        }
        return tmpPath;
    }
}
SmoothPath._defaultBufferSize = 8;

class SvgSmoothPath extends SmoothPath {
    constructor(options) {
        super(options);
        this._paths = [];
        this._strokeWidth = (options === null || options === void 0 ? void 0 : options.strokeWidth) || SvgSmoothPath._defaultStrokeWidth;
        this._color = (options === null || options === void 0 ? void 0 : options.color) || SvgSmoothPath._defaultColor;
        this._group = document.createElementNS("http://www.w3.org/2000/svg", "g");
    }
    get strokeWidth() {
        return this._strokeWidth;
    }
    get color() {
        return this._color;
    }
    get group() {
        return this._group;
    }
    get paths() {
        return this._paths.slice();
    }
    newPath(startPosition) {
        const [r, g, b, a] = this._color || [0, 0, 0, 1];
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", `rgba(${r * 255},${g * 255},${b * 255},${a})`);
        path.setAttribute("stroke-width", this._strokeWidth + "");
        path.setAttribute("stroke-linecap", "round");
        path.setAttribute("stroke-linejoin", "round");
        const pathString = "M" + startPosition.x + " " + startPosition.y;
        path.setAttribute("d", pathString);
        this._positionBuffer = [startPosition];
        this._currentPath = { path, positions: [new Vec2(startPosition.x, startPosition.y)] };
        this._currentPathString = pathString;
        this._group.append(path);
    }
    removePath(path) {
        if (!path) {
            return;
        }
        path.remove();
        this._paths = this._paths.filter(x => x.path !== path);
    }
    removeLastPath() {
        const pathData = this._paths.pop();
        pathData === null || pathData === void 0 ? void 0 : pathData.path.remove();
    }
    updateCurrentPath() {
        const tmpPath = super.updateCurrentPath();
        if (tmpPath) {
            this._currentPath.path.setAttribute("d", this._currentPathString + tmpPath);
        }
        return tmpPath;
    }
}
SvgSmoothPath._defaultStrokeWidth = 3;
SvgSmoothPath._defaultColor = [0, 0, 0, 0.8];

var __awaiter$9 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class AnnotationBase {
    constructor(eventService, dto) {
        var _a;
        this._aabb = [new Vec2(), new Vec2()];
        this._currentAngle = 0;
        this._tempTransformationMatrix = new Mat3();
        this._tempStartPoint = new Vec2();
        this._tempVecX = new Vec2();
        this._tempVecY = new Vec2();
        this._svgId = getRandomUuid();
        this.onSvgPointerEnter = (e) => {
            if (this.onPointerEnterAction) {
                this.onPointerEnterAction(e);
            }
        };
        this.onSvgPointerLeave = (e) => {
            if (this.onPointerLeaveAction) {
                this.onPointerLeaveAction(e);
            }
        };
        this.onSvgPointerDown = (e) => {
            if (!this.imageUuid) {
                return;
            }
            if (this.onPointerDownAction) {
                this.onPointerDownAction(e);
            }
            this.onTranslationPointerDown(e);
        };
        this.onTranslationPointerDown = (e) => {
            if (!this.translationEnabled || !e.isPrimary) {
                return;
            }
            const target = e.target;
            target.setPointerCapture(e.pointerId);
            target.addEventListener("pointerup", this.onTranslationPointerUp);
            target.addEventListener("pointerout", this.onTranslationPointerUp);
            this._moved = false;
            this._transformationTimer = setTimeout(() => {
                this._transformationTimer = null;
                this._renderedControls.after(this._svgContentCopy);
                this._tempStartPoint.setFromVec2(this.convertClientCoordsToImage(e.clientX, e.clientY));
                target.addEventListener("pointermove", this.onTranslationPointerMove);
            }, 200);
        };
        this.onTranslationPointerMove = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const current = this.convertClientCoordsToImage(e.clientX, e.clientY);
            this._tempTransformationMatrix.reset()
                .applyTranslation(current.x - this._tempStartPoint.x, current.y - this._tempStartPoint.y);
            this._svgContentCopy.setAttribute("transform", `matrix(${this._tempTransformationMatrix.toFloatShortArray().join(" ")})`);
            this._moved = true;
        };
        this.onTranslationPointerUp = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const target = e.target;
            target.removeEventListener("pointermove", this.onTranslationPointerMove);
            target.removeEventListener("pointerup", this.onTranslationPointerUp);
            target.removeEventListener("pointerout", this.onTranslationPointerUp);
            target.releasePointerCapture(e.pointerId);
            this.applyTempTransformAsync();
        };
        this.onRotationHandlePointerDown = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const target = e.target;
            target.setPointerCapture(e.pointerId);
            target.addEventListener("pointerup", this.onRotationHandlePointerUp);
            target.addEventListener("pointerout", this.onRotationHandlePointerUp);
            this._moved = false;
            this._transformationTimer = setTimeout(() => {
                this._transformationTimer = null;
                this._renderedControls.after(this._svgContentCopy);
                target.addEventListener("pointermove", this.onRotationHandlePointerMove);
            }, 200);
            e.stopPropagation();
        };
        this.onRotationHandlePointerMove = (e) => {
            var _a;
            if (!e.isPrimary) {
                return;
            }
            const [{ x: xmin, y: ymin }, { x: xmax, y: ymax }] = this.aabb;
            const centerX = (xmin + xmax) / 2;
            const centerY = (ymin + ymax) / 2;
            const clientCenter = this.convertImageCoordsToClient(centerX, centerY);
            const imageAngle = ((_a = this._imageInfo) === null || _a === void 0 ? void 0 : _a.rotation)
                ? this._imageInfo.rotation / 180 * Math.PI
                : 0;
            const angle = Math.atan2(e.clientX - clientCenter.x, e.clientY - clientCenter.y) + imageAngle;
            this._tempTransformationMatrix.reset()
                .applyTranslation(-centerX, -centerY)
                .applyRotation(angle)
                .applyTranslation(centerX, centerY);
            this._svgContentCopy.setAttribute("transform", `matrix(${this._tempTransformationMatrix.toFloatShortArray().join(" ")})`);
            this._moved = true;
        };
        this.onRotationHandlePointerUp = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const target = e.target;
            target.removeEventListener("pointermove", this.onRotationHandlePointerMove);
            target.removeEventListener("pointerup", this.onRotationHandlePointerUp);
            target.removeEventListener("pointerout", this.onRotationHandlePointerUp);
            target.releasePointerCapture(e.pointerId);
            this.applyTempTransformAsync();
        };
        this.onScaleHandlePointerDown = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const target = e.target;
            target.setPointerCapture(e.pointerId);
            target.addEventListener("pointerup", this.onScaleHandlePointerUp);
            target.addEventListener("pointerout", this.onScaleHandlePointerUp);
            const [{ x: xmin, y: ymin }, { x: xmax, y: ymax }] = this.aabb;
            const ul = new Vec2(xmin, ymin);
            const ll = new Vec2(xmin, ymax);
            const lr = new Vec2(xmax, ymax);
            const ur = new Vec2(xmax, ymin);
            const handleName = target.dataset["handleName"];
            switch (handleName) {
                case "ll":
                    this._tempStartPoint.setFromVec2(ur);
                    this._tempVecX.setFromVec2(ul).subtract(ur);
                    this._tempVecY.setFromVec2(lr).subtract(ur);
                    break;
                case "lr":
                    this._tempStartPoint.setFromVec2(ul);
                    this._tempVecX.setFromVec2(ur).subtract(ul);
                    this._tempVecY.setFromVec2(ll).subtract(ul);
                    break;
                case "ur":
                    this._tempStartPoint.setFromVec2(ll);
                    this._tempVecX.setFromVec2(lr).subtract(ll);
                    this._tempVecY.setFromVec2(ul).subtract(ll);
                    break;
                case "ul":
                    this._tempStartPoint.setFromVec2(lr);
                    this._tempVecX.setFromVec2(ll).subtract(lr);
                    this._tempVecY.setFromVec2(ur).subtract(lr);
                    break;
                default:
                    throw new Error(`Invalid handle name: ${handleName}`);
            }
            this._tempX = this._tempVecX.getMagnitude();
            this._tempY = this._tempVecY.getMagnitude();
            this._moved = false;
            this._transformationTimer = setTimeout(() => {
                this._transformationTimer = null;
                this._renderedControls.after(this._svgContentCopy);
                target.addEventListener("pointermove", this.onScaleHandlePointerMove);
            }, 200);
            e.stopPropagation();
        };
        this.onScaleHandlePointerMove = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const currentBoxDiagonal = this.convertClientCoordsToImage(e.clientX, e.clientY)
                .subtract(this._tempStartPoint);
            const currentBoxDiagonalLength = currentBoxDiagonal.getMagnitude();
            const cos = Math.abs(currentBoxDiagonal.dotProduct(this._tempVecX))
                / currentBoxDiagonalLength / this._tempX;
            const currentXSideLength = cos * currentBoxDiagonalLength;
            const currentYSideLength = Math.sqrt(currentBoxDiagonalLength * currentBoxDiagonalLength
                - currentXSideLength * currentXSideLength);
            const scaleX = currentXSideLength / this._tempX;
            const scaleY = currentYSideLength / this._tempY;
            const [{ x: xmin, y: ymin }, { x: xmax, y: ymax }] = this.aabb;
            const annotCenterX = (xmin + xmax) / 2;
            const annotCenterY = (ymin + ymax) / 2;
            this._tempTransformationMatrix.reset()
                .applyTranslation(-annotCenterX, -annotCenterY)
                .applyScaling(scaleX, scaleY)
                .applyTranslation(annotCenterX, annotCenterY);
            const translation = this._tempStartPoint.clone().subtract(this._tempStartPoint.clone().applyMat3(this._tempTransformationMatrix));
            this._tempTransformationMatrix.applyTranslation(translation.x, translation.y);
            this._svgContentCopy.setAttribute("transform", `matrix(${this._tempTransformationMatrix.toFloatShortArray().join(" ")})`);
            this._moved = true;
        };
        this.onScaleHandlePointerUp = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const target = e.target;
            target.removeEventListener("pointermove", this.onScaleHandlePointerMove);
            target.removeEventListener("pointerup", this.onScaleHandlePointerUp);
            target.removeEventListener("pointerout", this.onScaleHandlePointerUp);
            target.releasePointerCapture(e.pointerId);
            this.applyTempTransformAsync();
        };
        if (!eventService) {
            throw new Error("Event service is not defined");
        }
        this.eventService = eventService;
        this.type = (dto === null || dto === void 0 ? void 0 : dto.annotationType) || "none";
        this.uuid = (dto === null || dto === void 0 ? void 0 : dto.uuid) || getRandomUuid();
        this._imageUuid = dto === null || dto === void 0 ? void 0 : dto.imageUuid;
        this._dateCreated = (dto === null || dto === void 0 ? void 0 : dto.dateCreated)
            ? new Date(dto.dateCreated)
            : new Date();
        this._dateModified = (dto === null || dto === void 0 ? void 0 : dto.dateModified)
            ? new Date(dto.dateModified)
            : new Date();
        this._author = (dto === null || dto === void 0 ? void 0 : dto.author) || "unknown";
        if (dto.textContent) {
            this._textContent = dto.textContent;
        }
        this._rotation = (_a = dto.rotation) !== null && _a !== void 0 ? _a : 0;
    }
    get imageUuid() {
        return this._imageUuid;
    }
    set imageUuid(value) {
        if (value !== this._imageUuid) {
            this._imageUuid = value;
            this._imageInfo = null;
        }
    }
    get deleted() {
        return this._deleted;
    }
    set deleted(value) {
        this._deleted = value;
    }
    get dateCreated() {
        return new Date(this._dateCreated);
    }
    get dateModified() {
        return new Date(this._dateModified);
    }
    get author() {
        return this._author;
    }
    get textContent() {
        return this._textContent;
    }
    get strokeWidth() {
        return this._strokeWidth;
    }
    get rotation() {
        return this._rotation;
    }
    get aabb() {
        if (!this._aabbIsActual) {
            this.updateAABB();
            this._aabbIsActual = true;
        }
        return [this._aabb[0].clone(), this._aabb[1].clone()];
    }
    get lastRenderResult() {
        if (!this._renderedControls || !this._renderedContent) {
            return null;
        }
        return {
            controls: this._renderedControls,
            content: this._renderedContent,
        };
    }
    renderAsync(imageInfo) {
        return __awaiter$9(this, void 0, void 0, function* () {
            if (!imageInfo) {
                throw new Error("Can't render the annotation: image dimensions is not defined");
            }
            this._imageInfo = imageInfo;
            if (!this._renderedControls) {
                this._renderedControls = this.renderControls();
            }
            yield new Promise((resolve, reject) => {
                setTimeout(() => __awaiter$9(this, void 0, void 0, function* () {
                    yield this.updateRenderAsync();
                    resolve();
                }), 0);
            });
            return this.lastRenderResult;
        });
    }
    moveToAsync(point) {
        return __awaiter$9(this, void 0, void 0, function* () {
            const aabb = this.aabb;
            const width = aabb[1].x - aabb[0].x;
            const height = aabb[1].y - aabb[0].y;
            const x = point.x - width / 2;
            const y = point.y - height / 2;
            const mat = Mat3.buildTranslate(x, y);
            yield this.applyCommonTransformAsync(mat);
        });
    }
    rotateByAsync(angle, center) {
        return __awaiter$9(this, void 0, void 0, function* () {
            if (!center) {
                const [{ x: xmin, y: ymin }, { x: xmax, y: ymax }] = this.aabb;
                center = new Vec2((xmin + xmax) / 2, (ymin + ymax) / 2);
            }
            const mat = new Mat3()
                .applyTranslation(-center.x, -center.y)
                .applyRotation(angle)
                .applyTranslation(center.x, center.y);
            yield this.applyCommonTransformAsync(mat);
        });
    }
    toDto() {
        var _a, _b;
        return {
            annotationType: this.type,
            uuid: this.uuid,
            imageUuid: this.imageUuid,
            dateCreated: (_a = this._dateCreated) === null || _a === void 0 ? void 0 : _a.toISOString(),
            dateModified: (_b = this._dateModified) === null || _b === void 0 ? void 0 : _b.toISOString(),
            author: this._author,
            textContent: this._textContent,
        };
    }
    setTextContentAsync(text, undoable = true) {
        return __awaiter$9(this, void 0, void 0, function* () {
            const oldText = this._textContent;
            this._textContent = text;
            this._dateModified = new Date();
            const undoAction = undoable
                ? () => __awaiter$9(this, void 0, void 0, function* () {
                    yield this.setTextContentAsync(oldText, false);
                })
                : undefined;
            this.emitEditRequest(undoAction);
        });
    }
    toImageAsync() {
        return __awaiter$9(this, void 0, void 0, function* () {
            const renderedContent = this._renderedContent;
            if (!renderedContent) {
                return null;
            }
            const contentSvgs = renderedContent.querySelectorAll(".annotation-content-element");
            if (!(contentSvgs === null || contentSvgs === void 0 ? void 0 : contentSvgs.length)) {
                return null;
            }
            const svgs = [];
            contentSvgs.forEach(x => {
                if (x instanceof SVGGraphicsElement) {
                    svgs.push(x);
                }
            });
            const images = [];
            for (const svg of svgs) {
                const svgSerialized = new XMLSerializer().serializeToString(svg);
                const svgBlob = new Blob([svgSerialized], { type: "image/svg+xml;charset=utf-8" });
                const svgUrl = URL.createObjectURL(svgBlob);
                const result = yield new Promise((resolve, reject) => {
                    const image = new Image();
                    image.onerror = (e) => {
                        console.log(`Error while loading image: ${e}`);
                        resolve(null);
                    };
                    image.onload = () => {
                        resolve(image);
                    };
                    image.src = svgUrl;
                });
                URL.revokeObjectURL(svgUrl);
                images.push(result);
            }
            return images;
        });
    }
    convertClientCoordsToImage(clientX, clientY) {
        var _a, _b;
        const [annotLocalMin, annotLocalMax] = this.aabb;
        const { x: annotClientXMin, y: annotClientYMin, width: annotClientHorLength, height: annotClientVertLength } = this._renderedBox.getBoundingClientRect();
        const imageRotation = ((_a = this._imageInfo) === null || _a === void 0 ? void 0 : _a.rotation) || 0;
        let imageScale = (_b = this === null || this === void 0 ? void 0 : this._imageInfo) === null || _b === void 0 ? void 0 : _b.scale;
        let annotLocalHorLength;
        const imageClientZero = new Vec2();
        const localResult = new Vec2();
        switch (imageRotation) {
            case 0:
                annotLocalHorLength = annotLocalMax.x - annotLocalMin.x;
                imageScale || (imageScale = annotClientHorLength / annotLocalHorLength);
                imageClientZero.set(annotClientXMin - annotLocalMin.x * imageScale, annotClientYMin - annotLocalMin.y * imageScale);
                localResult.set((clientX - imageClientZero.x) / imageScale, (clientY - imageClientZero.y) / imageScale);
                break;
            case 90:
                annotLocalHorLength = annotLocalMax.x - annotLocalMin.x;
                imageScale || (imageScale = annotClientHorLength / annotLocalHorLength);
                imageClientZero.set(annotClientXMin + annotClientHorLength + annotLocalMin.y * imageScale, annotClientYMin - annotLocalMin.x * imageScale);
                localResult.set((clientY - imageClientZero.y) / imageScale, (imageClientZero.x - clientX) / imageScale);
                break;
            case 180:
                annotLocalHorLength = annotLocalMax.x - annotLocalMin.x;
                imageScale || (imageScale = annotClientHorLength / annotLocalHorLength);
                imageClientZero.set(annotClientXMin + annotClientHorLength + annotLocalMin.x * imageScale, annotClientYMin + annotClientVertLength + annotLocalMin.y * imageScale);
                localResult.set((imageClientZero.x - clientX) / imageScale, (imageClientZero.y - clientY) / imageScale);
                break;
            case 270:
                annotLocalHorLength = annotLocalMax.y - annotLocalMin.y;
                imageScale || (imageScale = annotClientHorLength / annotLocalHorLength);
                imageClientZero.set(annotClientXMin - annotLocalMin.y * imageScale, annotClientYMin + annotClientVertLength + annotLocalMin.x * imageScale);
                localResult.set((imageClientZero.y - clientY) / imageScale, (clientX - imageClientZero.x) / imageScale);
                break;
            default:
                throw new Error(`Invalid rotation image value: ${imageRotation}`);
        }
        return localResult;
    }
    convertImageCoordsToClient(imageX, imageY) {
        var _a, _b;
        const [annotLocalMin, annotLocalMax] = this.aabb;
        const { x: annotClientXMin, y: annotClientYMin, width: annotClientHorLength, height: annotClientVertLength } = this._renderedBox.getBoundingClientRect();
        const imageRotation = ((_a = this._imageInfo) === null || _a === void 0 ? void 0 : _a.rotation) || 0;
        let imageScale = (_b = this === null || this === void 0 ? void 0 : this._imageInfo) === null || _b === void 0 ? void 0 : _b.scale;
        let annotLocalHorLength;
        const imageClientZero = new Vec2();
        const localResult = new Vec2();
        switch (imageRotation) {
            case 0:
                annotLocalHorLength = annotLocalMax.x - annotLocalMin.x;
                imageScale || (imageScale = annotClientHorLength / annotLocalHorLength);
                imageClientZero.set(annotClientXMin - annotLocalMin.x * imageScale, annotClientYMin - annotLocalMin.y * imageScale);
                localResult.set(imageX * imageScale + imageClientZero.x, imageY * imageScale + imageClientZero.y);
                break;
            case 90:
                annotLocalHorLength = annotLocalMax.x - annotLocalMin.x;
                imageScale || (imageScale = annotClientHorLength / annotLocalHorLength);
                imageClientZero.set(annotClientXMin + annotClientHorLength + annotLocalMin.y * imageScale, annotClientYMin - annotLocalMin.x * imageScale);
                localResult.set(imageClientZero.x - imageY * imageScale, imageX * imageScale + imageClientZero.y);
                break;
            case 180:
                annotLocalHorLength = annotLocalMax.x - annotLocalMin.x;
                imageScale || (imageScale = annotClientHorLength / annotLocalHorLength);
                imageClientZero.set(annotClientXMin + annotClientHorLength + annotLocalMin.x * imageScale, annotClientYMin + annotClientVertLength + annotLocalMin.y * imageScale);
                localResult.set(imageClientZero.x - imageX * imageScale, imageClientZero.y - imageY * imageScale);
                break;
            case 270:
                annotLocalHorLength = annotLocalMax.y - annotLocalMin.y;
                imageScale || (imageScale = annotClientHorLength / annotLocalHorLength);
                imageClientZero.set(annotClientXMin - annotLocalMin.y * imageScale, annotClientYMin + annotClientVertLength + annotLocalMin.x * imageScale);
                localResult.set(imageY * imageScale + imageClientZero.x, imageClientZero.y - imageX * imageScale);
                break;
            default:
                throw new Error(`Invalid rotation image value: ${imageRotation}`);
        }
        return localResult;
    }
    getAnnotationToImageMatrix() {
        const imageInfo = this._imageInfo;
        if (!imageInfo) {
            return new Mat3();
        }
        const imageRotation = imageInfo === null || imageInfo === void 0 ? void 0 : imageInfo.rotation;
        if (!imageRotation) {
            return new Mat3();
        }
        const [{ x: xmin, y: ymin }, { x: xmax, y: ymax }] = this.aabb;
        const centerX = (xmax + xmin) / 2;
        const centerY = (ymax + ymin) / 2;
        const { x: imageWidth, y: imageHeight } = imageInfo.dimensions;
        let x;
        let y;
        switch (imageRotation) {
            case 90:
                x = centerY;
                y = imageHeight - centerX;
                break;
            case 180:
                x = imageWidth - centerX;
                y = imageHeight - centerY;
                break;
            case 270:
                x = imageWidth - centerY;
                y = centerX;
                break;
            default:
                throw new Error(`Invalid rotation image value: ${imageRotation}`);
        }
        const mat = new Mat3()
            .applyTranslation(-centerX, -centerY)
            .applyRotation(imageRotation / 180 * Math.PI)
            .applyTranslation(x, y);
        return mat;
    }
    applyCommonTransformAsync(matrix, undoable = true) {
        return __awaiter$9(this, void 0, void 0, function* () {
            this._dateModified = new Date();
            this._aabbIsActual = false;
            yield this.updateRenderAsync();
            const invertedMat = Mat3.invert(matrix);
            const undoAction = undoable
                ? () => __awaiter$9(this, void 0, void 0, function* () {
                    yield this.applyCommonTransformAsync(invertedMat, false);
                })
                : undefined;
            this.emitEditRequest(undoAction);
        });
    }
    applyTempTransformAsync() {
        return __awaiter$9(this, void 0, void 0, function* () {
            if (this._transformationTimer) {
                clearTimeout(this._transformationTimer);
                this._transformationTimer = null;
                return;
            }
            if (this._transformationPromise) {
                yield this._transformationPromise;
            }
            this._transformationPromise = new Promise((resolve) => __awaiter$9(this, void 0, void 0, function* () {
                this._svgContentCopy.remove();
                this._svgContentCopy.setAttribute("transform", "matrix(1 0 0 1 0 0)");
                if (this._moved) {
                    yield this.applyCommonTransformAsync(this._tempTransformationMatrix);
                }
                this._tempTransformationMatrix.reset();
                resolve();
            }));
            yield this._transformationPromise;
        });
    }
    renderRect() {
        const [{ x: xmin, y: ymin }, { x: xmax, y: ymax }] = this.aabb;
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.classList.add("annotation-rect");
        rect.setAttribute("data-annotation-name", this.uuid);
        rect.setAttribute("x", xmin + "");
        rect.setAttribute("y", ymin + "");
        rect.setAttribute("width", xmax - xmin + "");
        rect.setAttribute("height", ymax - ymin + "");
        return rect;
    }
    renderBox() {
        const [{ x: xmin, y: ymin }, { x: xmax, y: ymax }] = this.aabb;
        const bBox = {
            ul: new Vec2(xmin, ymin),
            ll: new Vec2(xmin, ymax),
            lr: new Vec2(xmax, ymax),
            ur: new Vec2(xmax, ymin),
        };
        const { ll, lr, ur, ul } = bBox;
        const boxPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        boxPath.classList.add("annotation-bbox");
        boxPath.setAttribute("data-annotation-name", this.uuid);
        boxPath.setAttribute("d", `M ${ll.x} ${ll.y} L ${lr.x} ${lr.y} L ${ur.x} ${ur.y} L ${ul.x} ${ul.y} Z`);
        return boxPath;
    }
    renderControls() {
        const controlsGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        controlsGroup.classList.add("annotation-controls");
        controlsGroup.setAttribute("data-annotation-name", this.uuid);
        controlsGroup.addEventListener("pointerdown", this.onSvgPointerDown);
        controlsGroup.addEventListener("pointerenter", this.onSvgPointerEnter);
        controlsGroup.addEventListener("pointerleave", this.onSvgPointerLeave);
        return controlsGroup;
    }
    buildRenderedContentStructure(renderResult) {
        var _a;
        const content = document.createElement("div");
        content.id = this._svgId;
        content.classList.add("annotation-content");
        content.setAttribute("data-annotation-name", this.uuid);
        const { x: width, y: height } = this._imageInfo.dimensions;
        if ((_a = renderResult.clipPaths) === null || _a === void 0 ? void 0 : _a.length) {
            const clipPathsContainer = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            clipPathsContainer.setAttribute("viewBox", `0 0 ${width} ${height}`);
            clipPathsContainer.append(...renderResult.clipPaths);
            content.append(clipPathsContainer);
        }
        renderResult.elements.forEach(x => {
            const elementContainer = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            elementContainer.classList.add("annotation-content-element");
            elementContainer.setAttribute("viewBox", `0 0 ${width} ${height}`);
            elementContainer.style["mixBlendMode"] = x.blendMode;
            elementContainer.append(x.element);
            content.append(elementContainer);
        });
        return content;
    }
    buildRenderContentCopy(contentRenderResult) {
        const copy = document.createElementNS("http://www.w3.org/2000/svg", "g");
        contentRenderResult.elements.forEach(x => {
            copy.append(x.element.cloneNode(true));
        });
        copy.classList.add("annotation-temp-copy");
        return copy;
    }
    renderScaleHandles() {
        const [{ x: xmin, y: ymin }, { x: xmax, y: ymax }] = this.aabb;
        const bBox = {
            ul: new Vec2(xmin, ymin),
            ll: new Vec2(xmin, ymax),
            lr: new Vec2(xmax, ymax),
            ur: new Vec2(xmax, ymin),
        };
        const handles = [];
        ["ll", "lr", "ur", "ul"].forEach(x => {
            const handle = document.createElementNS("http://www.w3.org/2000/svg", "line");
            handle.classList.add("annotation-handle", "scale");
            handle.setAttribute("data-handle-name", x);
            handle.setAttribute("x1", bBox[x].x + "");
            handle.setAttribute("y1", bBox[x].y + "");
            handle.setAttribute("x2", bBox[x].x + "");
            handle.setAttribute("y2", bBox[x].y + 0.1 + "");
            handle.addEventListener("pointerdown", this.onScaleHandlePointerDown);
            handles.push(handle);
        });
        return handles;
    }
    renderRotationHandle() {
        const [{ x: xmin, y: ymin }, { x: xmax, y: ymax }] = this.aabb;
        const centerX = (xmin + xmax) / 2;
        const centerY = (ymin + ymax) / 2;
        const rotationGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        rotationGroup.classList.add("annotation-rotator");
        rotationGroup.setAttribute("data-handle-name", "center");
        const rotationGroupCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        rotationGroupCircle.classList.add("circle", "dashed");
        rotationGroupCircle.setAttribute("cx", centerX + "");
        rotationGroupCircle.setAttribute("cy", centerY + "");
        const handleMatrix = new Mat3()
            .applyTranslation(-centerX, -centerY + 35)
            .applyTranslation(centerX, centerY);
        const handleCenter = new Vec2(centerX, centerY).applyMat3(handleMatrix);
        const rotationGroupLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        rotationGroupLine.classList.add("dashed");
        rotationGroupLine.setAttribute("x1", centerX + "");
        rotationGroupLine.setAttribute("y1", centerY + "");
        rotationGroupLine.setAttribute("x2", handleCenter.x + "");
        rotationGroupLine.setAttribute("y2", handleCenter.y + "");
        const centerRectHandle = document.createElementNS("http://www.w3.org/2000/svg", "line");
        centerRectHandle.classList.add("annotation-handle", "rotation");
        centerRectHandle.setAttribute("data-handle-name", "center");
        centerRectHandle.setAttribute("x1", handleCenter.x + "");
        centerRectHandle.setAttribute("y1", handleCenter.y + "");
        centerRectHandle.setAttribute("x2", handleCenter.x + "");
        centerRectHandle.setAttribute("y2", handleCenter.y + 0.1 + "");
        centerRectHandle.addEventListener("pointerdown", this.onRotationHandlePointerDown);
        rotationGroup.append(rotationGroupCircle, rotationGroupLine, centerRectHandle);
        return rotationGroup;
    }
    renderHandles() {
        return [...this.renderScaleHandles(), this.renderRotationHandle()];
    }
    updateRenderAsync() {
        var _a;
        return __awaiter$9(this, void 0, void 0, function* () {
            if (!this._renderedControls) {
                return;
            }
            this._renderedControls.innerHTML = "";
            const contentRenderResult = this.renderAppearance();
            if (!contentRenderResult || !((_a = contentRenderResult.elements) === null || _a === void 0 ? void 0 : _a.length)) {
                this._renderedBox = null;
                this._svgContentCopy = null;
                return null;
            }
            const content = this.buildRenderedContentStructure(contentRenderResult);
            this._renderedContent = content;
            const rect = this.renderRect();
            const box = this.renderBox();
            const handles = this.renderHandles();
            this._renderedBox = box;
            this._renderedControls.append(rect, box, ...contentRenderResult.pickHelpers, ...handles);
            const copy = this.buildRenderContentCopy(contentRenderResult);
            this._svgContentCopy = copy;
            this.eventService.dispatchEvent(new AnnotEvent({
                type: "render",
                annotations: [this.toDto()],
            }));
        });
    }
    emitEditRequest(undoAction) {
        this.eventService.dispatchEvent(new AnnotEditRequestEvent({
            undoAction,
            annotation: this,
        }));
    }
}

const selectionStrokeWidth = 20;

var __awaiter$8 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class PenAnnotation extends AnnotationBase {
    constructor(eventService, dto) {
        if (!dto) {
            throw new Error("No source object passed to the constructor");
        }
        if (dto.annotationType !== "pen") {
            throw new Error(`Invalid annotation type: '${dto.annotationType}' (must be 'pen')`);
        }
        super(eventService, dto);
        this._pathList = dto.pathList;
        this._strokeColor = dto.strokeColor;
        this._strokeWidth = dto.strokeWidth;
        this._strokeDashGap = dto.strokeDashGap;
    }
    get pathList() {
        return this._pathList;
    }
    get color() {
        return this.color;
    }
    get strokeWidth() {
        return this._strokeWidth;
    }
    get strokeDashGap() {
        return this._strokeDashGap;
    }
    toDto() {
        return {
            annotationType: this.type,
            uuid: this.uuid,
            imageUuid: this._imageUuid,
            dateCreated: this._dateCreated.toISOString(),
            dateModified: this._dateModified.toISOString(),
            author: this._author,
            rotation: this._rotation,
            textContent: this._textContent,
            pathList: this._pathList,
            strokeColor: this._strokeColor,
            strokeWidth: this._strokeWidth,
            strokeDashGap: this._strokeDashGap,
        };
    }
    applyCommonTransformAsync(matrix, undoable = true) {
        const _super = Object.create(null, {
            applyCommonTransformAsync: { get: () => super.applyCommonTransformAsync }
        });
        return __awaiter$8(this, void 0, void 0, function* () {
            let x;
            let y;
            const vec = new Vec2();
            this._pathList.forEach(list => {
                for (let i = 0; i < list.length; i = i + 2) {
                    x = list[i];
                    y = list[i + 1];
                    vec.set(x, y).applyMat3(matrix);
                    list[i] = vec.x;
                    list[i + 1] = vec.y;
                }
            });
            yield _super.applyCommonTransformAsync.call(this, matrix, undoable);
        });
    }
    updateAABB() {
        let x;
        let y;
        let xMin;
        let yMin;
        let xMax;
        let yMax;
        this._pathList.forEach(list => {
            for (let i = 0; i < list.length; i = i + 2) {
                x = list[i];
                y = list[i + 1];
                if (!xMin || x < xMin) {
                    xMin = x;
                }
                if (!yMin || y < yMin) {
                    yMin = y;
                }
                if (!xMax || x > xMax) {
                    xMax = x;
                }
                if (!yMax || y > yMax) {
                    yMax = y;
                }
            }
        });
        const halfStrokeW = this.strokeWidth / 2;
        xMin -= halfStrokeW;
        yMin -= halfStrokeW;
        xMax += halfStrokeW;
        xMax += halfStrokeW;
        this._aabb[0].set(xMin, yMin);
        this._aabb[1].set(xMax, yMax);
    }
    renderAppearance() {
        try {
            const clipPaths = [];
            const elements = [];
            const pickHelpers = [];
            const [min, max] = this.aabb;
            const clipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
            clipPath.id = `clip0_${this.uuid}`;
            clipPath.innerHTML = "<path d=\""
                + `M${min.x},${min.y} `
                + `L${max.x},${min.y} `
                + `L${max.x},${max.y} `
                + `L${min.x},${max.y} `
                + "z"
                + "\"/>";
            clipPaths.push(clipPath);
            const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
            group.setAttribute("clip-path", `url(#${clipPath.id})`);
            const clonedGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            clonedGroup.classList.add("annotation-pick-helper");
            for (const pathCoords of this.pathList) {
                if (!(pathCoords === null || pathCoords === void 0 ? void 0 : pathCoords.length)) {
                    continue;
                }
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                group.setAttribute("fill", "none");
                const [r, g, b, a] = this._strokeColor;
                group.setAttribute("stroke", `rgba(${r * 255},${g * 255},${b * 255},${a})`);
                group.setAttribute("stroke-width", this._strokeWidth + "");
                if (this._strokeDashGap) {
                    group.setAttribute("stroke-dasharray", this._strokeDashGap.join(" "));
                }
                let d = `M ${pathCoords[0]} ${pathCoords[1]}`;
                for (let i = 2; i < pathCoords.length;) {
                    d += ` L ${pathCoords[i++]} ${pathCoords[i++]}`;
                }
                path.setAttribute("d", d);
                group.append(path);
                const clonedPath = path.cloneNode(true);
                const clonedPathStrokeWidth = this._strokeWidth < selectionStrokeWidth
                    ? selectionStrokeWidth
                    : this._strokeWidth;
                clonedPath.setAttribute("stroke-width", clonedPathStrokeWidth + "");
                clonedPath.setAttribute("stroke", "transparent");
                clonedPath.setAttribute("fill", "none");
                clonedGroup.append(clonedPath);
            }
            elements.push({
                element: group,
                blendMode: "normal",
            });
            pickHelpers.push(clonedGroup);
            return {
                elements,
                clipPaths,
                pickHelpers,
            };
        }
        catch (e) {
            console.log(`Annotation render error: ${e.message}`);
            return null;
        }
    }
}

var __awaiter$7 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class PenAnnotator extends Annotator {
    constructor(imageService, parent, options) {
        super(imageService, parent);
        this.onPointerDown = (e) => {
            if (!e.isPrimary || e.button === 2) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updatePointerCoords(cx, cy);
            const imageCoords = this._pointerCoordsInImageCS;
            if (!imageCoords) {
                return;
            }
            const { x: ix, y: iy, info: { uuid } } = imageCoords;
            if (!this._annotationPathData || uuid !== this._annotationPathData.uuid) {
                this.resetTempPenData(uuid);
            }
            this._annotationPathData.newPath(new Vec2(ix, iy));
            const target = e.target;
            target.addEventListener("pointermove", this.onPointerMove);
            target.addEventListener("pointerup", this.onPointerUp);
            target.addEventListener("pointerout", this.onPointerUp);
            target.setPointerCapture(e.pointerId);
        };
        this.onPointerMove = (e) => {
            var _a;
            if (!e.isPrimary || !this._annotationPathData) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updatePointerCoords(cx, cy);
            const imageCoords = this._pointerCoordsInImageCS;
            if (!imageCoords || ((_a = imageCoords.info) === null || _a === void 0 ? void 0 : _a.uuid) !== this._annotationPathData.uuid) {
                return;
            }
            const position = new Vec2(imageCoords.x, imageCoords.y);
            this._annotationPathData.addPosition(position);
        };
        this.onPointerUp = (e) => {
            var _a;
            if (!e.isPrimary) {
                return;
            }
            const target = e.target;
            target.removeEventListener("pointermove", this.onPointerMove);
            target.removeEventListener("pointerup", this.onPointerUp);
            target.removeEventListener("pointerout", this.onPointerUp);
            target.releasePointerCapture(e.pointerId);
            (_a = this._annotationPathData) === null || _a === void 0 ? void 0 : _a.endPath();
            this.emitDataChanged();
        };
        this.init();
        this._color = (options === null || options === void 0 ? void 0 : options.color) || [0, 0, 0, 0.9];
        this._strokeWidth = (options === null || options === void 0 ? void 0 : options.strokeWidth) || 3;
    }
    destroy() {
        this.removeTempPenData();
        super.destroy();
    }
    undo() {
        var _a;
        (_a = this._annotationPathData) === null || _a === void 0 ? void 0 : _a.removeLastPath();
        this.emitDataChanged();
    }
    clear() {
        this.removeTempPenData();
    }
    saveAnnotationAsync() {
        return __awaiter$7(this, void 0, void 0, function* () {
            if (!this._annotationPathData) {
                return;
            }
            const imageUuid = this._annotationPathData.uuid;
            const dto = this.buildAnnotationDto(this._annotationPathData);
            const annotation = new PenAnnotation(this._imageService.eventService, dto);
            this._imageService.appendAnnotationToImage(imageUuid, annotation);
            this.clear();
        });
    }
    init() {
        super.init();
        this._overlay.addEventListener("pointerdown", this.onPointerDown);
    }
    refreshGroupPosition() {
        if (!this._annotationPathData) {
            return;
        }
        const image = this._imageService.currentImageView;
        if (!image || image.imageInfo.uuid !== this._annotationPathData.uuid) {
            this._annotationPathData.group.setAttribute("transform", "scale(0)");
            return;
        }
        const { height: imageHeight, width: imageWidth, top: imageTop, left: imageLeft } = image.viewContainer.getBoundingClientRect();
        const imageBottom = imageTop + imageHeight;
        const imageRight = imageLeft + imageWidth;
        const { top: overlayTop, left: overlayLeft } = this._overlay.getBoundingClientRect();
        const rotation = image.rotation;
        const scale = image.scale;
        let offsetX;
        let offsetY;
        switch (rotation) {
            case 0:
                offsetX = (imageLeft - overlayLeft) / scale;
                offsetY = (imageTop - overlayTop) / scale;
                break;
            case 90:
                offsetX = (imageRight - overlayLeft) / scale;
                offsetY = (imageTop - overlayTop) / scale;
                break;
            case 180:
                offsetX = (imageRight - overlayLeft) / scale;
                offsetY = (imageBottom - overlayTop) / scale;
                break;
            case 270:
                offsetX = (imageLeft - overlayLeft) / scale;
                offsetY = (imageBottom - overlayTop) / scale;
                break;
            default:
                throw new Error(`Invalid rotation degree: ${rotation}`);
        }
        this._annotationPathData.group.setAttribute("transform", `translate(${offsetX} ${offsetY}) rotate(${rotation})`);
    }
    removeTempPenData() {
        if (this._annotationPathData) {
            this._annotationPathData.group.remove();
            this._annotationPathData = null;
            this.emitDataChanged();
        }
    }
    resetTempPenData(imageUuid) {
        this.removeTempPenData();
        this._annotationPathData = new SvgSmoothPath({
            uuid: imageUuid,
            color: this._color,
            strokeWidth: this._strokeWidth,
        });
        this._svgGroup.append(this._annotationPathData.group);
        this.refreshGroupPosition();
    }
    emitDataChanged() {
        var _a;
        const count = ((_a = this._annotationPathData) === null || _a === void 0 ? void 0 : _a.pathCount) || 0;
        this._imageService.eventService.dispatchEvent(new AnnotatorDataChangeEvent({
            annotatorType: "pen",
            elementCount: count,
            undoable: count > 1,
            clearable: count > 0,
            saveable: count > 0,
        }));
    }
    buildAnnotationDto(data) {
        const pathList = [];
        data.paths.forEach(path => {
            const ink = [];
            path.positions.forEach(pos => {
                ink.push(pos.x, pos.y);
            });
            pathList.push(ink);
        });
        const nowString = new Date().toISOString();
        const dto = {
            uuid: getRandomUuid(),
            annotationType: "pen",
            imageUuid: null,
            dateCreated: nowString,
            dateModified: nowString,
            author: this._imageService.userName || "unknown",
            textContent: null,
            pathList,
            strokeColor: data.color,
            strokeWidth: data.strokeWidth,
            strokeDashGap: null,
        };
        return dto;
    }
}

const geometricAnnotatorTypes = ["square", "circle", "line", "arrow", "polyline", "polygon"];

class AnnotatorService {
    constructor(imageService, viewer) {
        this._annotationColors = [
            [0, 0, 0, 0.5],
            [0.804, 0, 0, 0.5],
            [0, 0.804, 0, 0.5],
            [0, 0, 0.804, 0.5],
            [1, 0.5, 0, 0.5],
            [1, 0.2, 1, 0.5],
        ];
        this._strokeColor = this._annotationColors[0];
        this._strokeWidth = 3;
        this._geometricCloudMode = false;
        this._geometricSubmode = geometricAnnotatorTypes[0];
        this.onContextMenu = (event) => {
            if (this._contextMenu.enabled) {
                event.preventDefault();
                this._contextMenu.show(new Vec2(event.clientX, event.clientY), this._viewer.container);
            }
        };
        this.onImageChange = (event) => {
            if (event.detail.type === "render") {
                this._contextMenu.hide();
            }
        };
        if (!imageService) {
            throw new Error("Page service is not defined");
        }
        if (!viewer) {
            throw new Error("Viewer is not defined");
        }
        this._imageService = imageService;
        this._viewer = viewer;
        this.init();
    }
    get mode() {
        return this._mode;
    }
    set mode(value) {
        this.setMode(value);
    }
    get annotator() {
        return this._annotator;
    }
    destroy() {
        var _a, _b, _c;
        this._imageService.eventService.removeListener(imageChangeEvent, this.onImageChange);
        this._viewer.container.removeEventListener("contextmenu", this.onContextMenu);
        (_a = this._viewerResizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
        (_b = this._contextMenu) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this._annotator) === null || _c === void 0 ? void 0 : _c.destroy();
    }
    init() {
        this._imageService.eventService.addListener(imageChangeEvent, this.onImageChange);
        this._viewer.container.addEventListener("contextmenu", this.onContextMenu);
        const viewerRObserver = new ResizeObserver((entries) => {
            var _a;
            (_a = this._contextMenu) === null || _a === void 0 ? void 0 : _a.hide();
        });
        viewerRObserver.observe(this._viewer.container);
        this._viewerResizeObserver = viewerRObserver;
        this._contextMenu = new ContextMenu();
    }
    setMode(mode) {
        var _a;
        mode || (mode = this._mode);
        this._contextMenu.content = [];
        (_a = this._annotator) === null || _a === void 0 ? void 0 : _a.destroy();
        this._imageService.setSelectedAnnotation(null);
        this._mode = mode;
        switch (mode) {
            case "select":
                this._contextMenu.enabled = false;
                return;
            case "stamp":
                break;
            case "pen":
                this._annotator = new PenAnnotator(this._imageService, this._viewer.container, {
                    strokeWidth: this._strokeWidth,
                    color: this._strokeColor,
                });
                break;
            case "geometric":
                break;
            case "text":
                break;
            default:
                throw new Error(`Invalid annotation mode: ${mode}`);
        }
        const cmContent = this.buildContextMenuContent();
        this._contextMenu.content = cmContent;
        this._contextMenu.enabled = true;
    }
    buildContextMenuContent() {
        switch (this._mode) {
            case "select":
                return [];
            case "pen":
                return [
                    this.buildStrokeColorPicker(),
                    this.buildStrokeWidthSlider(false),
                ];
            default:
                throw new Error(`Invalid annotation mode: ${this._mode}`);
        }
    }
    buildStrokeColorPicker() {
        const colorPickerDiv = document.createElement("div");
        colorPickerDiv.classList.add("context-menu-content", "row");
        this._annotationColors.forEach(x => {
            const item = document.createElement("div");
            item.classList.add("panel-button");
            if (x === this._strokeColor) {
                item.classList.add("on");
            }
            item.addEventListener("click", () => {
                this._strokeColor = x;
                this.setMode();
            });
            const colorIcon = document.createElement("div");
            colorIcon.classList.add("context-menu-color-icon");
            colorIcon.style.backgroundColor = `rgb(${x[0] * 255},${x[1] * 255},${x[2] * 255})`;
            item.append(colorIcon);
            colorPickerDiv.append(item);
        });
        return colorPickerDiv;
    }
    buildStrokeWidthSlider(cloudButtons) {
        const disableLineTypeButtons = !cloudButtons
            || this._geometricSubmode === "polyline"
            || this._geometricSubmode === "line"
            || this._geometricSubmode === "arrow";
        const div = document.createElement("div");
        div.classList.add("context-menu-content", "row");
        const cloudyLineButton = document.createElement("div");
        cloudyLineButton.classList.add("panel-button");
        if (disableLineTypeButtons) {
            cloudyLineButton.classList.add("disabled");
        }
        else {
            if (this._geometricCloudMode) {
                cloudyLineButton.classList.add("on");
            }
            cloudyLineButton.addEventListener("click", () => {
                this._geometricCloudMode = true;
                this.setMode();
            });
        }
        cloudyLineButton.innerHTML = lineTypeIcons.cloudy;
        div.append(cloudyLineButton);
        const straightLineButton = document.createElement("div");
        straightLineButton.classList.add("panel-button");
        if (disableLineTypeButtons) {
            straightLineButton.classList.add("disabled");
        }
        else {
            if (!this._geometricCloudMode) {
                straightLineButton.classList.add("on");
            }
            straightLineButton.addEventListener("click", () => {
                this._geometricCloudMode = false;
                this.setMode();
            });
        }
        straightLineButton.innerHTML = lineTypeIcons.straight;
        div.append(straightLineButton);
        const slider = document.createElement("input");
        slider.setAttribute("type", "range");
        slider.setAttribute("min", "1");
        slider.setAttribute("max", "32");
        slider.setAttribute("step", "1");
        slider.setAttribute("value", this._strokeWidth + "");
        slider.classList.add("context-menu-slider");
        slider.addEventListener("change", () => {
            this._strokeWidth = slider.valueAsNumber;
            this.setMode();
        });
        div.append(slider);
        return div;
    }
}

class Loader {
    constructor() {
        this._loaderElement = htmlToElements(loaderHtml)[0];
    }
    show(parent, zIndex = 8) {
        if (this._isShown || !parent) {
            return;
        }
        this._loaderElement.style.zIndex = zIndex + "";
        this._loaderElement.style.top = parent.scrollTop + "px";
        this._loaderElement.style.left = parent.scrollLeft + "px";
        parent.append(this._loaderElement);
        this._isShown = true;
    }
    hide() {
        this._loaderElement.remove();
        this._isShown = false;
    }
}

var __awaiter$6 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Previewer {
    constructor(imageService, container, options) {
        this._hidden = true;
        this.onImageChange = (event) => __awaiter$6(this, void 0, void 0, function* () {
            var _a;
            if (event.detail.type === "open") {
                (_a = event.detail.imageViews) === null || _a === void 0 ? void 0 : _a.forEach(x => {
                    x.previewContainer.addEventListener("click", this.onPreviewerImageClick);
                    this._container.append(x.previewContainer);
                });
            }
            else if (event.detail.type === "select") {
                this.scrollToPreview(event.detail.imageViews[0].index);
            }
            yield this.renderVisibleAsync();
        });
        this.onPreviewerImageClick = (e) => {
            let target = e.target;
            let imageNumber;
            while (target && !imageNumber) {
                const data = target.dataset["imageIndex"];
                if (data) {
                    imageNumber = +data;
                }
                else {
                    target = target.parentElement;
                }
            }
            if (imageNumber) {
                this._imageService.setImageAtIndexAsCurrent(imageNumber - 1);
            }
        };
        this.onPreviewerScroll = (e) => __awaiter$6(this, void 0, void 0, function* () {
            yield this.renderVisibleAsync();
        });
        if (!imageService) {
            throw new Error("Image service is not defined");
        }
        if (!container) {
            throw new Error("Container is not defined");
        }
        this._imageService = imageService;
        this._container = container;
        this._canvasWidth = (options === null || options === void 0 ? void 0 : options.canvasWidth) || 100;
        this.init();
    }
    get canvasWidth() {
        return this._canvasWidth;
    }
    get hidden() {
        return this._hidden;
    }
    destroy() {
        this._imageService.eventService.removeListener(imageChangeEvent, this.onImageChange);
        this._container.removeEventListener("scroll", this.onPreviewerScroll);
    }
    show() {
        this._hidden = false;
        setTimeout(() => this.renderVisibleAsync(), 1000);
    }
    hide() {
        this._hidden = true;
    }
    init() {
        this._container.addEventListener("scroll", this.onPreviewerScroll);
        this._imageService.eventService.addListener(imageChangeEvent, this.onImageChange);
    }
    scrollToPreview(imageIndex) {
        if (!this._imageService.imageCount) {
            return;
        }
        const { top: cTop, height: cHeight } = this._container.getBoundingClientRect();
        const { top: pTop, height: pHeight } = this._imageService.getImage(imageIndex)
            .previewContainer.getBoundingClientRect();
        const cCenter = cTop + cHeight / 2;
        const pCenter = pTop + pHeight / 2;
        const scroll = pCenter - cCenter + this._container.scrollTop;
        this._container.scrollTo(0, scroll);
    }
    getVisiblePreviewImages() {
        const images = this._imageService.imageViews;
        const cointainer = this._container;
        const imagesVisible = new Set();
        if (!images.length) {
            return imagesVisible;
        }
        const cRect = cointainer.getBoundingClientRect();
        const cTop = cRect.top;
        const cBottom = cRect.top + cRect.height;
        for (let i = 0; i < images.length; i++) {
            const image = images[i];
            const pRect = image.previewContainer.getBoundingClientRect();
            const pTop = pRect.top;
            const pBottom = pRect.top + pRect.height;
            if (pTop < cBottom && pBottom > cTop) {
                imagesVisible.add(i);
            }
            else if (imagesVisible.size) {
                break;
            }
        }
        return imagesVisible;
    }
    renderVisibleAsync() {
        return __awaiter$6(this, void 0, void 0, function* () {
            if (this._hidden) {
                return;
            }
            const images = this._imageService.imageViews;
            const visiblePreviewNumbers = this.getVisiblePreviewImages();
            const minImageNumber = Math.max(Math.min(...visiblePreviewNumbers), 0);
            const maxImageNumber = Math.min(Math.max(...visiblePreviewNumbers), images.length - 1);
            for (let i = 0; i < images.length; i++) {
                const image = images[i];
                if (i >= minImageNumber && i <= maxImageNumber) {
                    yield image.renderPreviewAsync();
                }
            }
        });
    }
}

var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const viewerModes = ["hand", "annotation"];
class Viewer {
    constructor(imageService, container, options) {
        this._scale = 1;
        this._pointerInfo = {
            lastPos: null,
            downPos: null,
            downScroll: null,
        };
        this._pinchInfo = {
            active: false,
            lastDist: 0,
            minDist: 10,
            sensitivity: 0.025,
            target: null,
        };
        this.onImageChange = (e) => __awaiter$5(this, void 0, void 0, function* () {
            if (e.detail.type === "select") {
                const selectedImageView = e.detail.imageViews[0];
                yield this.renderImageAsync(selectedImageView);
            }
        });
        this.onPointerMove = (event) => {
            const { clientX, clientY } = event;
            this._pointerInfo.lastPos = new Vec2(clientX, clientY);
        };
        this.onScroll = (e) => {
        };
        this.onPointerDownScroll = (e) => {
            if (this._mode !== "hand") {
                return;
            }
            const { clientX, clientY } = e;
            this._pointerInfo.downPos = new Vec2(clientX, clientY);
            this._pointerInfo.downScroll = new Vec2(this._container.scrollLeft, this._container.scrollTop);
            const onPointerMove = (moveEvent) => {
                const { x, y } = this._pointerInfo.downPos;
                const { x: left, y: top } = this._pointerInfo.downScroll;
                const dX = moveEvent.clientX - x;
                const dY = moveEvent.clientY - y;
                this._container.scrollTo(left - dX, top - dY);
            };
            const onPointerUp = (upEvent) => {
                this._pointerInfo.downPos = null;
                this._pointerInfo.downScroll = null;
                const upTarget = upEvent.target;
                upTarget.removeEventListener("pointermove", onPointerMove);
                upTarget.removeEventListener("pointerup", onPointerUp);
                upTarget.removeEventListener("pointerout", onPointerUp);
                upTarget.releasePointerCapture(upEvent.pointerId);
            };
            const target = e.target;
            target.setPointerCapture(e.pointerId);
            target.addEventListener("pointermove", onPointerMove);
            target.addEventListener("pointerup", onPointerUp);
            target.addEventListener("pointerout", onPointerUp);
        };
        this.onWheelZoom = (event) => {
            if (!event.ctrlKey) {
                return;
            }
            event.preventDefault();
            if (event.deltaY > 0) {
                this.zoomOutCentered(this._pointerInfo.lastPos);
            }
            else {
                this.zoomInCentered(this._pointerInfo.lastPos);
            }
        };
        this.onTouchZoom = (event) => {
            if (event.touches.length !== 2) {
                return;
            }
            const a = event.touches[0];
            const b = event.touches[1];
            this._pinchInfo.active = true;
            this._pinchInfo.lastDist = getDistance2D(a.clientX, a.clientY, b.clientX, b.clientY);
            const onTouchMove = (moveEvent) => {
                if (moveEvent.touches.length !== 2) {
                    return;
                }
                const mA = moveEvent.touches[0];
                const mB = moveEvent.touches[1];
                const dist = getDistance2D(mA.clientX, mA.clientY, mB.clientX, mB.clientY);
                const delta = dist - this._pinchInfo.lastDist;
                const factor = Math.floor(delta / this._pinchInfo.minDist);
                if (factor) {
                    const center = new Vec2((mB.clientX + mA.clientX) / 2, (mB.clientY + mA.clientY) / 2);
                    this._pinchInfo.lastDist = dist;
                    this.zoom(factor * this._pinchInfo.sensitivity, center);
                }
            };
            const onTouchEnd = (endEvent) => {
                this._pinchInfo.active = false;
                this._pinchInfo.lastDist = 0;
                event.target.removeEventListener("touchmove", onTouchMove);
                event.target.removeEventListener("touchend", onTouchEnd);
                event.target.removeEventListener("touchcancel", onTouchEnd);
            };
            event.target.addEventListener("touchmove", onTouchMove);
            event.target.addEventListener("touchend", onTouchEnd);
            event.target.addEventListener("touchcancel", onTouchEnd);
        };
        if (!imageService) {
            throw new Error("Image service is not defined");
        }
        if (!container) {
            throw new Error("Container is not defined");
        }
        this._imageService = imageService;
        this._container = container;
        this._minImageSize = (options === null || options === void 0 ? void 0 : options.minImageSize) || 100;
        this.init();
    }
    get container() {
        return this._container;
    }
    get mode() {
        return this._mode;
    }
    set mode(value) {
        if (this._dialogClose) {
            this._dialogClose();
        }
        if (!value || value === this._mode) {
            return;
        }
        this._mode = value;
    }
    get scale() {
        return this._scale;
    }
    destroy() {
        this._imageService.eventService.removeListener(imageChangeEvent, this.onImageChange);
        this._container.removeEventListener("scroll", this.onScroll);
        this._container.removeEventListener("wheel", this.onWheelZoom);
        this._container.removeEventListener("pointermove", this.onPointerMove);
        this._container.removeEventListener("pointerdown", this.onPointerDownScroll);
        this._container.removeEventListener("touchstart", this.onTouchZoom);
    }
    zoomOut() {
        this.zoomOutCentered();
    }
    zoomIn() {
        this.zoomInCentered();
    }
    zoomFitViewer() {
        const cWidth = this._container.getBoundingClientRect().width;
        const pWidth = this._imageService.currentImageView
            .viewContainer.getBoundingClientRect().width;
        const scale = (cWidth - 20) / pWidth * this._scale;
        if (!scale || scale === Infinity) {
            return;
        }
        this.setScale(scale);
    }
    zoomFitImage() {
        const { width: cWidth, height: cHeight } = this._container.getBoundingClientRect();
        const { width: pWidth, height: pHeight } = this._imageService.currentImageView
            .viewContainer.getBoundingClientRect();
        const hScale = (cWidth - 20) / pWidth * this._scale;
        const vScale = (cHeight - 20) / pHeight * this._scale;
        const scale = Math.min(hScale, vScale);
        if (!scale || scale === Infinity) {
            return;
        }
        this.setScale(scale);
    }
    showTextDialogAsync(initialText) {
        return __awaiter$5(this, void 0, void 0, function* () {
            if (this._dialogClose) {
                return;
            }
            const dialog = htmlToElements(textDialogHtml)[0];
            dialog.style.top = this._container.scrollTop + "px";
            dialog.style.left = this._container.scrollLeft + "px";
            this._container.append(dialog);
            this._container.classList.add("dialog-shown");
            let value = initialText || "";
            const input = dialog.querySelector(".text-input");
            input.placeholder = "Enter text...";
            input.value = value;
            input.addEventListener("change", () => value = input.value);
            const textPromise = new Promise((resolve, reject) => {
                const ok = () => {
                    resolve(value || "");
                };
                const cancel = () => {
                    resolve(null);
                };
                dialog.addEventListener("click", (e) => {
                    if (e.target === dialog) {
                        cancel();
                    }
                });
                dialog.querySelector(".text-ok").addEventListener("click", ok);
                dialog.querySelector(".text-cancel").addEventListener("click", cancel);
                this._dialogClose = () => resolve(null);
            });
            const result = yield textPromise;
            this._dialogClose = null;
            dialog.remove();
            this._container.classList.remove("dialog-shown");
            return result;
        });
    }
    init() {
        this._container.addEventListener("scroll", this.onScroll);
        this._container.addEventListener("wheel", this.onWheelZoom, { passive: false });
        this._container.addEventListener("pointermove", this.onPointerMove);
        this._container.addEventListener("pointerdown", this.onPointerDownScroll);
        this._container.addEventListener("touchstart", this.onTouchZoom);
        this._imageService.eventService.addListener(imageChangeEvent, this.onImageChange);
    }
    renderImageAsync(image) {
        return __awaiter$5(this, void 0, void 0, function* () {
            image.scale = this._scale;
            yield image.renderViewAsync(false);
            this._container.innerHTML = "";
            this._container.append(image.viewWrapper);
            this.zoomFitImage();
            this._imageService.emitRendered([image]);
        });
    }
    setScale(scale, cursorPosition = null) {
        var _a;
        const imageView = (_a = this === null || this === void 0 ? void 0 : this._imageService) === null || _a === void 0 ? void 0 : _a.currentImageView;
        if (!scale || !imageView) {
            return;
        }
        cursorPosition || (cursorPosition = this.getCenterPosition());
        const { x, y } = cursorPosition;
        const { x: imageX, y: imageY, width: imageWidth, height: imageHeight } = imageView.viewContainer.getBoundingClientRect();
        const minScale = this._minImageSize / imageView.imageInfo.dimensions.x;
        if (scale < minScale) {
            scale = minScale;
        }
        if (scale === this._scale) {
            return;
        }
        let imageUnderCursor;
        let xImageRatio;
        let yImageRatio;
        if (imageX <= x
            && imageX + imageWidth >= x
            && imageY <= y
            && imageY + imageHeight >= y) {
            imageUnderCursor = true;
            xImageRatio = (x - imageX) / imageWidth;
            yImageRatio = (y - imageY) / imageHeight;
        }
        this._scale = scale;
        this._imageService.scale = scale;
        this._imageService.emitStateChanged();
        if (imageUnderCursor) {
            const { x: imageScaledX, y: imageScaledY, width: imageScaledWidth, height: imageScaledHeight } = imageView.viewContainer.getBoundingClientRect();
            let scrollLeft;
            let scrollTop;
            if (imageScaledWidth > this._container.clientHeight
                || imageScaledHeight > this._container.clientWidth) {
                const { x: initialX, y: initialY } = cursorPosition;
                const resultX = imageScaledX + (imageScaledWidth * xImageRatio);
                const resultY = imageScaledY + (imageScaledHeight * yImageRatio);
                scrollLeft = this._container.scrollLeft + (resultX - initialX);
                scrollTop = this._container.scrollTop + (resultY - initialY);
                scrollLeft = scrollLeft < 0
                    ? 0
                    : scrollLeft;
                scrollTop = scrollTop < 0
                    ? 0
                    : scrollTop;
            }
            else {
                scrollLeft = 0;
                scrollTop = 0;
            }
            if (scrollTop !== this._container.scrollTop
                || scrollLeft !== this._container.scrollLeft) {
                this._container.scrollTo(scrollLeft, scrollTop);
                return;
            }
        }
    }
    zoom(diff, cursorPosition = null) {
        const scale = this._scale + diff;
        this.setScale(scale, cursorPosition || this.getCenterPosition());
    }
    zoomOutCentered(center = null) {
        this.zoom(-this.getZoomStep(), center);
    }
    zoomInCentered(center = null) {
        this.zoom(this.getZoomStep(), center);
    }
    getCenterPosition() {
        const { x, y, width, height } = this._container.getBoundingClientRect();
        return new Vec2(x + width / 2, y + height / 2);
    }
    getZoomStep() {
        let step = 0;
        if (this._scale < 0.5) {
            step = 0.1;
        }
        else if (this._scale < 1) {
            step = 0.25;
        }
        else if (this._scale < 2) {
            step = 0.5;
        }
        else {
            step = 1;
        }
        return step;
    }
}

var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ImageInfo {
    constructor(source, uuid) {
        this._dimensions = new Vec2();
        this._scale = 1;
        this._rotation = 0;
        this._annotations = [];
        this._uuid = uuid || getRandomUuid();
        if (source instanceof HTMLImageElement) {
            if (!source || !source.complete) {
                throw new Error("Image is not loaded");
            }
            this._preloadedImage = source;
            this._dimensions.set(source.naturalWidth, source.naturalHeight);
            return;
        }
        this._url = source;
    }
    get uuid() {
        return this._uuid;
    }
    get url() {
        return this._url;
    }
    get dimensions() {
        return this._dimensions;
    }
    set scale(value) {
        if (this._scale === value) {
            return;
        }
        this._scale = Math.max(value, 0);
    }
    get scale() {
        return this._scale;
    }
    set rotation(value) {
        if (this._rotation === value || isNaN(value)) {
            return;
        }
        this._rotation = value % 360;
    }
    get rotation() {
        return this._rotation;
    }
    get annotations() {
        return this._annotations;
    }
    getImageAsync() {
        return __awaiter$4(this, void 0, void 0, function* () {
            if (this._preloadedImage) {
                return this._preloadedImage;
            }
            if (!this._url) {
                throw new Error("No image or image url found");
            }
            const image = yield loadImageAsync(this._url);
            if (image) {
                this._dimensions.set(image.naturalWidth, image.naturalHeight);
            }
            return image;
        });
    }
}

var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ImageAnnotationView {
    constructor(eventService, imageInfo) {
        this._rendered = new Set();
        this.onAnnotationSelectionChange = (e) => {
            var _a;
            if (e.detail.type === "select") {
                if ((_a = e.detail.annotations) === null || _a === void 0 ? void 0 : _a.length) {
                    this._container.style.touchAction = "none";
                }
                else {
                    this._container.style.touchAction = "";
                }
            }
        };
        if (!eventService) {
            throw new Error("Event service is not defined");
        }
        if (!imageInfo) {
            throw new Error("Image info is not defined");
        }
        this._eventService = eventService;
        this._imageInfo = imageInfo;
        this._container = document.createElement("div");
        this._container.classList.add("image-annotations");
        this._svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        this._svg.classList.add("image-annotations-controls");
        this._svg.setAttribute("data-image-uuid", imageInfo.uuid + "");
        this._svg.setAttribute("viewBox", `0 0 ${imageInfo.dimensions.x} ${imageInfo.dimensions.y}`);
        this._svg.addEventListener("pointerdown", (e) => {
            if (e.target === this._svg) {
                eventService.dispatchEvent(new AnnotSelectionRequestEvent({ annotation: null }));
            }
        });
    }
    destroy() {
        this.remove();
        this._container = null;
        this._destroyed = true;
    }
    remove() {
        var _a;
        (_a = this._container) === null || _a === void 0 ? void 0 : _a.remove();
        this._eventService.removeListener(annotChangeEvent, this.onAnnotationSelectionChange);
    }
    appendAsync(parent) {
        return __awaiter$3(this, void 0, void 0, function* () {
            if (this._destroyed) {
                return;
            }
            yield this.renderAnnotationsAsync();
            parent.append(this._container);
            this._eventService.addListener(annotChangeEvent, this.onAnnotationSelectionChange);
        });
    }
    renderAnnotationsAsync() {
        var _a, _b;
        return __awaiter$3(this, void 0, void 0, function* () {
            this.clear();
            const annotations = this._imageInfo.annotations || [];
            for (let i = 0; i < annotations.length || 0; i++) {
                const annotation = annotations[i];
                if (annotation.deleted) {
                    continue;
                }
                let renderResult;
                if (!this._rendered.has(annotation)) {
                    annotation.onPointerDownAction = (e) => {
                        this._eventService.dispatchEvent(new AnnotSelectionRequestEvent({ annotation }));
                    };
                    annotation.onPointerEnterAction = (e) => {
                        this._eventService.dispatchEvent(new AnnotFocusRequestEvent({ annotation }));
                    };
                    annotation.onPointerLeaveAction = (e) => {
                        this._eventService.dispatchEvent(new AnnotFocusRequestEvent({ annotation: null }));
                    };
                    renderResult = yield annotation.renderAsync(this._imageInfo);
                }
                else {
                    renderResult = annotation.lastRenderResult || (yield annotation.renderAsync(this._imageInfo));
                }
                if (!renderResult) {
                    continue;
                }
                this._rendered.add(annotation);
                this._svg.append(renderResult.controls);
                (_a = this._container) === null || _a === void 0 ? void 0 : _a.append(renderResult.content);
            }
            (_b = this._container) === null || _b === void 0 ? void 0 : _b.append(this._svg);
            return true;
        });
    }
    clear() {
        this._container.innerHTML = "";
        this._svg.innerHTML = "";
    }
}

var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ImageView {
    constructor(eventService, imageInfo, index, previewWidth) {
        this._dimensions = {
            width: 0,
            height: 0,
            previewWidth: 0,
            previewHeight: 0,
            scaledWidth: 0,
            scaledHeight: 0,
        };
        if (!eventService) {
            throw new Error("Event service is not defined");
        }
        if (!imageInfo) {
            throw new Error("Image info is not defined");
        }
        if (isNaN(index)) {
            throw new Error("Index is not defined");
        }
        this.eventService = eventService;
        this.imageInfo = imageInfo;
        this.index = index;
        this._previewWidth = previewWidth;
        this._previewContainer = document.createElement("div");
        this._previewContainer.classList.add("image-preview");
        this._previewContainer.setAttribute("data-image-index", this.index + 1 + "");
        this._viewInnerContainer = document.createElement("div");
        this._viewInnerContainer.classList.add("image");
        this._viewInnerContainer.setAttribute("data-image-index", this.index + "");
        this._viewOuterContainer = document.createElement("div");
        this._viewOuterContainer.classList.add("image-container");
        this._viewOuterContainer.setAttribute("data-image-index", this.index + "");
        this._viewOuterContainer.append(this._viewInnerContainer);
        this.refreshDimensions();
    }
    get previewContainer() {
        return this._previewContainer;
    }
    get viewWrapper() {
        return this._viewOuterContainer;
    }
    get viewContainer() {
        return this._viewInnerContainer;
    }
    set $viewRendered(value) {
        this._viewRendered = value;
        this._viewInnerContainer.setAttribute("data-loaded", value + "");
    }
    get $viewRendered() {
        return this._viewRendered;
    }
    set scale(value) {
        if (this.imageInfo.scale === value) {
            return;
        }
        this.imageInfo.scale = value;
        this.refreshDimensions();
    }
    get scale() {
        return this.imageInfo.scale;
    }
    set $rotation(value) {
        if (this.imageInfo.rotation === value) {
            return;
        }
        this.imageInfo.rotation = value;
        this.refreshDimensions();
    }
    get rotation() {
        return this.imageInfo.rotation;
    }
    get viewValid() {
        return this._dimensionsValid && this.$viewRendered;
    }
    destroy() {
        this._previewContainer.remove();
        this._viewOuterContainer.remove();
    }
    renderPreviewAsync(force = false) {
        return __awaiter$2(this, void 0, void 0, function* () {
            if (!force && this._previewRendered) {
                return;
            }
            const image = yield this.imageInfo.getImageAsync();
            const { x: imgW, y: imgH } = this.imageInfo.dimensions;
            this.refreshDimensions();
            const canvas = this.createPreviewCanvas();
            const ctx = canvas.getContext("2d");
            if (image) {
                ctx.drawImage(image, 0, 0, imgW, imgH, 0, 0, canvas.width, canvas.height);
            }
            this._previewContainer.innerHTML = "";
            this._previewContainer.append(canvas);
            this._previewRendered = true;
        });
    }
    renderViewAsync(force = false) {
        var _a;
        return __awaiter$2(this, void 0, void 0, function* () {
            if (!force && this.viewValid) {
                return;
            }
            const image = yield this.imageInfo.getImageAsync();
            const { x: imgW, y: imgH } = this.imageInfo.dimensions;
            this.refreshDimensions();
            const canvas = this.createViewCanvas();
            const ctx = canvas.getContext("2d");
            if (image) {
                ctx.drawImage(image, 0, 0, imgW, imgH, 0, 0, canvas.width, canvas.height);
            }
            (_a = this._viewCanvas) === null || _a === void 0 ? void 0 : _a.remove();
            this._viewInnerContainer.append(canvas);
            this._viewCanvas = canvas;
            this.$viewRendered = true;
            if (!this._annotationView) {
                this._annotationView = new ImageAnnotationView(this.eventService, this.imageInfo);
            }
            yield this._annotationView.appendAsync(this.viewContainer);
            this._dimensionsValid = true;
        });
    }
    clearPreview() {
        this._previewContainer.innerHTML = "";
        this._previewRendered = false;
    }
    clearView() {
        var _a, _b;
        (_a = this._annotationView) === null || _a === void 0 ? void 0 : _a.destroy();
        this._annotationView = null;
        (_b = this._viewCanvas) === null || _b === void 0 ? void 0 : _b.remove();
        this.$viewRendered = false;
    }
    rotateClockwise() {
        if (this.rotation === 270) {
            this.$rotation = 0;
        }
        else {
            this.$rotation = (this.rotation || 0) + 90;
        }
    }
    rotateCounterClockwise() {
        if (!this.rotation) {
            this.$rotation = 270;
        }
        else {
            this.$rotation = this.rotation - 90;
        }
    }
    bakeAnnotationsAsync() {
        return __awaiter$2(this, void 0, void 0, function* () {
            const tempCanvas = document.createElement("canvas");
            const { x, y } = this.imageInfo.dimensions;
            tempCanvas.width = x;
            tempCanvas.height = y;
            const tempCtx = tempCanvas.getContext("2d");
            const image = yield this.imageInfo.getImageAsync();
            if (image) {
                tempCtx.drawImage(image, 0, 0, x, y, 0, 0, x, y);
            }
            for (const annot of this.imageInfo.annotations || []) {
                if (annot.deleted) {
                    continue;
                }
                const annotImages = yield annot.toImageAsync();
                for (const annotImage of annotImages) {
                    tempCtx.drawImage(annotImage, 0, 0);
                }
            }
            const result = yield new Promise((resolve, reject) => {
                tempCanvas.toBlob((blob) => {
                    resolve(blob);
                }, "image/png", 0.7);
            });
            return result;
        });
    }
    getImageCoordsUnderPointer(clientX, clientY) {
        const { left: pxMin, top: pyMin, width: pw, height: ph } = this.viewContainer.getBoundingClientRect();
        const pxMax = pxMin + pw;
        const pyMax = pyMin + ph;
        if ((clientX < pxMin || clientX > pxMax)
            || (clientY < pyMin || clientY > pyMax)) {
            return null;
        }
        let x;
        let y;
        const scale = this.scale;
        const rotation = this.rotation;
        switch (rotation) {
            case 0:
                x = (clientX - pxMin) / scale;
                y = (clientY - pyMin) / scale;
                break;
            case 90:
                x = (clientY - pyMin) / scale;
                y = (pxMax - clientX) / scale;
                break;
            case 180:
                x = (pxMax - clientX) / scale;
                y = (pyMax - clientY) / scale;
                break;
            case 270:
                x = (pyMax - clientY) / scale;
                y = (clientX - pxMin) / scale;
                break;
            default:
                throw new Error(`Invalid rotation degree: ${rotation}`);
        }
        return {
            info: this.imageInfo,
            x,
            y,
        };
    }
    createPreviewCanvas() {
        const canvas = document.createElement("canvas");
        canvas.classList.add("image-canvas");
        const dpr = window.devicePixelRatio;
        const { previewWidth: width, previewHeight: height } = this._dimensions;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        return canvas;
    }
    createViewCanvas() {
        const canvas = document.createElement("canvas");
        canvas.classList.add("image-canvas");
        canvas.style.width = this._dimensions.scaledWidth + "px";
        canvas.style.height = this._dimensions.scaledHeight + "px";
        canvas.width = this._dimensions.width;
        canvas.height = this._dimensions.height;
        return canvas;
    }
    refreshDimensions() {
        var _a;
        const { x: width, y: height } = this.imageInfo.dimensions;
        const previewWidth = Math.max((_a = this._previewWidth) !== null && _a !== void 0 ? _a : 0, 50);
        const previewHeight = previewWidth * (height / width);
        this._dimensions.width = width;
        this._dimensions.height = height;
        this._dimensions.previewWidth = previewWidth;
        this._dimensions.previewHeight = previewHeight;
        this._previewContainer.style.width = this._dimensions.previewWidth + "px";
        this._previewContainer.style.height = this._dimensions.previewHeight + "px";
        this._dimensions.scaledWidth = this._dimensions.width * this.scale;
        this._dimensions.scaledHeight = this._dimensions.height * this.scale;
        const w = this._dimensions.scaledWidth + "px";
        const h = this._dimensions.scaledHeight + "px";
        if (this._viewCanvas) {
            this._viewCanvas.style.width = w;
            this._viewCanvas.style.height = h;
        }
        this._viewInnerContainer.style.width = w;
        this._viewInnerContainer.style.height = h;
        switch (this.rotation) {
            case 0:
                this._viewOuterContainer.style.width = w;
                this._viewOuterContainer.style.height = h;
                this._viewInnerContainer.style.transform = "";
                break;
            case 90:
                this._viewOuterContainer.style.width = h;
                this._viewOuterContainer.style.height = w;
                this._viewInnerContainer.style.transform = "rotate(90deg) translateY(-100%)";
                break;
            case 180:
                this._viewOuterContainer.style.width = w;
                this._viewOuterContainer.style.height = h;
                this._viewInnerContainer.style.transform = "rotate(180deg) translateX(-100%) translateY(-100%)";
                break;
            case 270:
                this._viewOuterContainer.style.width = h;
                this._viewOuterContainer.style.height = w;
                this._viewInnerContainer.style.transform = "rotate(270deg) translateX(-100%)";
                break;
            default:
                throw new Error(`Invalid rotation degree: ${this.rotation}`);
        }
        this._dimensionsValid = false;
    }
}

var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ImageService {
    constructor(eventService, options) {
        var _a;
        this._imageViews = [];
        this._lastCommands = [];
        this.onSelectionRequest = (e) => {
            var _a;
            if ((_a = e.detail) === null || _a === void 0 ? void 0 : _a.annotation) {
                this.setSelectedAnnotation(e.detail.annotation);
            }
            else {
                this.setSelectedAnnotation(null);
            }
        };
        this.onFocusRequest = (e) => {
            var _a;
            if ((_a = e.detail) === null || _a === void 0 ? void 0 : _a.annotation) {
                this.setFocusedAnnotation(e.detail.annotation);
            }
            else {
                this.setFocusedAnnotation(null);
            }
        };
        this.onEditRequest = (e) => {
            var _a;
            if ((_a = e.detail) === null || _a === void 0 ? void 0 : _a.annotation) {
                this.setFocusedAnnotation(e.detail.annotation);
            }
            else {
                this.setFocusedAnnotation(null);
            }
            const { annotation, undoAction } = e.detail;
            if (!annotation.imageUuid) {
                return;
            }
            if (undoAction) {
                this.pushCommand({ timestamp: Date.now(), undo: undoAction });
            }
            this._eventService.dispatchEvent(new AnnotEvent({
                type: "edit",
                annotations: [annotation.toDto()],
            }));
        };
        if (!eventService) {
            throw new Error("Event service is not defined");
        }
        this._eventService = eventService;
        this._userName = (options === null || options === void 0 ? void 0 : options.userName) || "guest";
        this._previewWidth = (options === null || options === void 0 ? void 0 : options.previewWidth) || 100;
        this._lazyLoadImages = (_a = options === null || options === void 0 ? void 0 : options.lazyLoadImages) !== null && _a !== void 0 ? _a : true;
        this._eventService.addListener(annotSelectionRequestEvent, this.onSelectionRequest);
        this._eventService.addListener(annotFocusRequestEvent, this.onFocusRequest);
        this._eventService.addListener(annotEditRequestEvent, this.onEditRequest);
    }
    get eventService() {
        return this._eventService;
    }
    get userName() {
        return this._userName;
    }
    get imageViews() {
        return this._imageViews;
    }
    get imageCount() {
        return this._imageViews.length;
    }
    get currentImageView() {
        return this._currentImageView;
    }
    get focusedAnnotation() {
        return this._focusedAnnotation;
    }
    get selectedAnnotation() {
        return this._selectedAnnotation;
    }
    get scale() {
        var _a;
        return ((_a = this._imageViews[0]) === null || _a === void 0 ? void 0 : _a.scale) || 1;
    }
    set scale(value) {
        if (!value || isNaN(value)) {
            value = 1;
        }
        this._imageViews.forEach(x => x.scale = value);
        this._eventService.dispatchEvent(new ScaleChangedEvent({ scale: value }));
    }
    destroy() {
        var _a;
        this._eventService.removeListener(annotSelectionRequestEvent, this.onSelectionRequest);
        this._eventService.removeListener(annotFocusRequestEvent, this.onFocusRequest);
        this._eventService.removeListener(annotEditRequestEvent, this.onEditRequest);
        (_a = this._imageViews) === null || _a === void 0 ? void 0 : _a.forEach(x => x.destroy());
    }
    undoAsync() {
        return __awaiter$1(this, void 0, void 0, function* () {
            yield this.undoCommandAsync();
        });
    }
    addImagesAsync(loadInfos) {
        var _a;
        return __awaiter$1(this, void 0, void 0, function* () {
            if (!(loadInfos === null || loadInfos === void 0 ? void 0 : loadInfos.length)) {
                return;
            }
            for (const info of loadInfos) {
                if (!info || !info.type || !info.data) {
                    console.log("Empty image load info");
                    continue;
                }
                let imageSource;
                let imageUrl;
                switch (info.type) {
                    case "URL":
                        if (typeof info.data !== "string") {
                            throw new Error(`Invalid data type: ${typeof info.data} (must be string)`);
                        }
                        if (this._lazyLoadImages) {
                            imageSource = info.data;
                        }
                        else {
                            imageSource = yield loadImageAsync(info.data);
                        }
                        break;
                    case "Base64":
                        if (typeof info.data !== "string") {
                            throw new Error(`Invalid data type: ${typeof info.data} (must be string)`);
                        }
                        imageSource = yield loadImageAsync(info.data);
                        break;
                    case "Blob":
                        if (!(info.data instanceof Blob)) {
                            throw new Error("Invalid data type: must be Blob");
                        }
                        imageUrl = URL.createObjectURL(info.data);
                        imageSource = yield loadImageAsync(imageUrl, true);
                        break;
                    case "ByteArray":
                        if (!(info.data instanceof Uint8Array)) {
                            throw new Error("Invalid data type: must be Uint8Array");
                        }
                        if (!((_a = info.data) === null || _a === void 0 ? void 0 : _a.length)) {
                            console.log("Empty image load byte data");
                            continue;
                        }
                        const blob = new Blob([info.data], {
                            type: "application/octet-binary",
                        });
                        imageUrl = URL.createObjectURL(blob);
                        imageSource = yield loadImageAsync(imageUrl, true);
                        break;
                    default:
                        throw new Error(`Invalid info type: ${info.type}`);
                }
                if (!imageSource) {
                    continue;
                }
                const imageInfo = new ImageInfo(imageSource, info.uuid);
                const view = new ImageView(this._eventService, imageInfo, this._imageViews.length, this._previewWidth);
                this._imageViews.push(view);
            }
            this._eventService.dispatchEvent(new ImageEvent({
                type: "open",
                imageViews: [...this._imageViews],
            }));
            if (!this._currentImageView) {
                this.setImageAtIndexAsCurrent(0);
            }
        });
    }
    clearImages() {
        this.setSelectedAnnotation(null);
        this._currentImageView = null;
        this._imageViews.forEach(x => x.destroy());
        this._eventService.dispatchEvent(new ImageEvent({
            type: "close",
            imageViews: [...this._imageViews],
        }));
        this._imageViews.length = 0;
    }
    getImage(index) {
        return this._imageViews[index];
    }
    setImageAtIndexAsCurrent(index) {
        var _a;
        const imageView = this._imageViews[index];
        if (!imageView || imageView === this._currentImageView) {
            return;
        }
        (_a = this._currentImageView) === null || _a === void 0 ? void 0 : _a.previewContainer.classList.remove("current");
        this._currentImageView = imageView;
        this._currentImageView.previewContainer.classList.add("current");
        this._eventService.dispatchEvent(new ImageEvent({
            type: "select",
            imageViews: [this._currentImageView],
        }));
    }
    setPreviousImageAsCurrent() {
        this.setImageAtIndexAsCurrent(this._currentImageView.index - 1);
    }
    setNextImageAsCurrent() {
        this.setImageAtIndexAsCurrent(this._currentImageView.index + 1);
    }
    appendAnnotationToImage(imageUuid, annotation) {
        this.appendAnnotation(imageUuid, annotation, true);
    }
    appendSerializedAnnotations(dtos) {
        let annotation;
        for (const dto of dtos) {
            switch (dto.annotationType) {
                case "pen":
                    annotation = new PenAnnotation(this._eventService, dto);
                    break;
                default:
                    throw new Error(`Unsupported annotation type: ${dto.annotationType}`);
            }
            this.appendAnnotationToImage(dto.imageUuid, annotation);
        }
    }
    deleteAnnotation(annotation) {
        this.removeAnnotation(annotation, true);
    }
    deleteSelectedAnnotation() {
        const annotation = this._selectedAnnotation;
        if (annotation) {
            this.removeAnnotation(annotation, true);
        }
    }
    serializeAnnotations(imageUuid) {
        var _a, _b, _c, _d, _e;
        const dtos = [];
        if (imageUuid) {
            for (const imageView of this._imageViews) {
                if (((_a = imageView.imageInfo) === null || _a === void 0 ? void 0 : _a.uuid) === imageUuid) {
                    if ((_c = (_b = imageView.imageInfo) === null || _b === void 0 ? void 0 : _b.annotations) === null || _c === void 0 ? void 0 : _c.length) {
                        dtos.push(...imageView.imageInfo.annotations.map(x => x.toDto()));
                    }
                    break;
                }
            }
        }
        else {
            for (const imageView of this._imageViews) {
                if ((_e = (_d = imageView.imageInfo) === null || _d === void 0 ? void 0 : _d.annotations) === null || _e === void 0 ? void 0 : _e.length) {
                    dtos.push(...imageView.imageInfo.annotations.map(x => x.toDto()));
                }
            }
        }
        return dtos;
    }
    setSelectedAnnotation(annotation) {
        var _a, _b, _c;
        if (annotation === this._selectedAnnotation) {
            return;
        }
        if (this._selectedAnnotation) {
            this._selectedAnnotation.translationEnabled = false;
            const oldSelectedSvg = (_b = (_a = this._selectedAnnotation) === null || _a === void 0 ? void 0 : _a.lastRenderResult) === null || _b === void 0 ? void 0 : _b.controls;
            oldSelectedSvg === null || oldSelectedSvg === void 0 ? void 0 : oldSelectedSvg.classList.remove("selected");
        }
        const newSelectedSvg = (_c = annotation === null || annotation === void 0 ? void 0 : annotation.lastRenderResult) === null || _c === void 0 ? void 0 : _c.controls;
        if (!newSelectedSvg) {
            this._selectedAnnotation = null;
        }
        else {
            annotation.translationEnabled = true;
            newSelectedSvg.classList.add("selected");
            this._selectedAnnotation = annotation;
        }
        this._eventService.dispatchEvent(new AnnotEvent({
            type: "select",
            annotations: this._selectedAnnotation
                ? [this._selectedAnnotation.toDto()]
                : [],
        }));
        return this._selectedAnnotation;
    }
    setFocusedAnnotation(annotation) {
        var _a, _b, _c;
        if (annotation === this._focusedAnnotation) {
            return;
        }
        if (this._focusedAnnotation) {
            this._focusedAnnotation.translationEnabled = false;
            const oldFocusedSvg = (_b = (_a = this._focusedAnnotation) === null || _a === void 0 ? void 0 : _a.lastRenderResult) === null || _b === void 0 ? void 0 : _b.controls;
            oldFocusedSvg === null || oldFocusedSvg === void 0 ? void 0 : oldFocusedSvg.classList.remove("focused");
        }
        const newFocusedSvg = (_c = annotation === null || annotation === void 0 ? void 0 : annotation.lastRenderResult) === null || _c === void 0 ? void 0 : _c.controls;
        if (!newFocusedSvg) {
            this._focusedAnnotation = null;
        }
        else {
            annotation.translationEnabled = true;
            newFocusedSvg.classList.add("focused");
            this._focusedAnnotation = annotation;
        }
        this._eventService.dispatchEvent(new AnnotEvent({
            type: "focus",
            annotations: this._focusedAnnotation
                ? [this._focusedAnnotation.toDto()]
                : [],
        }));
        return this._focusedAnnotation;
    }
    getSelectedAnnotationTextContent() {
        var _a;
        return (_a = this._selectedAnnotation) === null || _a === void 0 ? void 0 : _a.textContent;
    }
    setSelectedAnnotationTextContentAsync(text) {
        var _a;
        return __awaiter$1(this, void 0, void 0, function* () {
            yield ((_a = this._selectedAnnotation) === null || _a === void 0 ? void 0 : _a.setTextContentAsync(text));
        });
    }
    bakeImageAnnotationsAsync(imageUuid) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const imageView = imageUuid
                ? this._imageViews.find(x => x.imageInfo.uuid === imageUuid)
                : this._currentImageView;
            if (!imageView) {
                return null;
            }
            const blob = imageView.bakeAnnotationsAsync();
            return blob;
        });
    }
    emitRendered(imageViews) {
        this._eventService.dispatchEvent(new ImageEvent({ type: "render", imageViews: imageViews }));
    }
    emitStateChanged() {
        this._eventService.dispatchEvent(new ImageServiceStateChangeEvent({
            undoableCount: this._lastCommands.length,
            scale: this.scale,
        }));
    }
    pushCommand(command) {
        this._lastCommands.push(command);
        this.emitStateChanged();
    }
    undoCommandAsync() {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (!this._lastCommands.length) {
                return;
            }
            const lastCommand = this._lastCommands.pop();
            yield lastCommand.undo();
            this.emitStateChanged();
        });
    }
    appendAnnotation(imageUuid, annotation, undoable) {
        if (!annotation) {
            throw new Error("Annotation is not defined");
        }
        const image = this._imageViews.find(x => x.imageInfo.uuid === imageUuid);
        if (!image) {
            throw new Error(`Image with uuid '${imageUuid}' is not found`);
        }
        if (image.imageInfo.annotations.find(x => x.uuid === annotation.uuid)) {
            throw new Error(`Image already has the annotation with this uuid: '${imageUuid}'`);
        }
        image.imageInfo.annotations.push(annotation);
        annotation.deleted = false;
        annotation.imageUuid = imageUuid;
        if (undoable) {
            this.pushCommand({
                timestamp: Date.now(),
                undo: () => __awaiter$1(this, void 0, void 0, function* () {
                    this.removeAnnotation(annotation, false);
                    if (this.selectedAnnotation === annotation) {
                        this.setSelectedAnnotation(null);
                    }
                })
            });
        }
        this._eventService.dispatchEvent(new AnnotEvent({
            type: "add",
            annotations: [annotation.toDto()],
        }));
    }
    removeAnnotation(annotation, undoable) {
        if (!annotation) {
            return;
        }
        annotation.deleted = true;
        this.setSelectedAnnotation(null);
        if (undoable) {
            this.pushCommand({
                timestamp: Date.now(),
                undo: () => __awaiter$1(this, void 0, void 0, function* () {
                    this.appendAnnotation(annotation.imageUuid, annotation, false);
                })
            });
        }
        this._eventService.dispatchEvent(new AnnotEvent({
            type: "delete",
            annotations: [annotation.toDto()],
        }));
    }
}

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class TsImageViewer {
    constructor(options) {
        var _a;
        this._timers = {
            hidePanels: 0,
        };
        this.onFileInput = () => {
            const files = this._fileInput.files;
            if (files.length === 0) {
                return;
            }
            const imageLoadInfos = [];
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const imageLoadInfo = {
                    type: "Blob",
                    data: file,
                };
                imageLoadInfos.push(imageLoadInfo);
            }
            this._fileInput.value = null;
            this.openImagesAsync(imageLoadInfos);
        };
        this.onOpenFileButtonClick = () => {
            this._shadowRoot.getElementById("open-file-input").click();
        };
        this.onSaveFileButtonClick = () => __awaiter(this, void 0, void 0, function* () {
            const blob = yield this._imageService.bakeImageAnnotationsAsync();
            if (!blob) {
                return;
            }
            downloadFile(blob, `img_${new Date().toISOString()}.png`);
        });
        this.onCloseFileButtonClick = () => {
            this.closeImages();
        };
        this.onHandModeButtonClick = () => {
            this.setViewerMode("hand");
        };
        this.onAnnotatorModeButtonClick = () => {
            this.setViewerMode("annotation");
        };
        this.onZoomOutClick = () => {
            this._viewer.zoomOut();
        };
        this.onZoomInClick = () => {
            this._viewer.zoomIn();
        };
        this.onZoomFitViewerClick = () => {
            this._viewer.zoomFitViewer();
        };
        this.onZoomFitImageClick = () => {
            this._viewer.zoomFitImage();
        };
        this.onRotateCounterClockwiseClick = () => {
            var _a;
            (_a = this._imageService.currentImageView) === null || _a === void 0 ? void 0 : _a.rotateCounterClockwise();
            this.setAnnotatorMode(this._annotatorService.mode);
        };
        this.onRotateClockwiseClick = () => {
            var _a;
            (_a = this._imageService.currentImageView) === null || _a === void 0 ? void 0 : _a.rotateClockwise();
            this.setAnnotatorMode(this._annotatorService.mode);
        };
        this.onPaginatorPrevClick = () => {
            this._imageService.setPreviousImageAsCurrent();
        };
        this.onPaginatorNextClick = () => {
            this._imageService.setNextImageAsCurrent();
        };
        this.annotatorUndo = () => {
            var _a;
            (_a = this._annotatorService.annotator) === null || _a === void 0 ? void 0 : _a.undo();
        };
        this.annotatorClear = () => {
            var _a;
            (_a = this._annotatorService.annotator) === null || _a === void 0 ? void 0 : _a.clear();
        };
        this.annotatorSave = () => {
            var _a;
            (_a = this._annotatorService.annotator) === null || _a === void 0 ? void 0 : _a.saveAnnotationAsync();
        };
        this.onAnnotatorChange = (e) => __awaiter(this, void 0, void 0, function* () {
            if (!e.detail) {
                return;
            }
            const annotations = e.detail.annotations;
            switch (e.detail.type) {
                case "focus":
                    if (annotations === null || annotations === void 0 ? void 0 : annotations.length) {
                        this._mainContainer.classList.add("annotation-focused");
                    }
                    else {
                        this._mainContainer.classList.remove("annotation-focused");
                    }
                    const annotation = annotations[0];
                    if (annotation) {
                        this._shadowRoot.querySelector("#focused-annotation-author")
                            .textContent = annotation.author || "";
                        this._shadowRoot.querySelector("#focused-annotation-date")
                            .textContent = new Date(annotation.dateModified || annotation.dateCreated).toDateString();
                        this._shadowRoot.querySelector("#focused-annotation-text")
                            .textContent = annotation.textContent || "";
                    }
                    else {
                        this._shadowRoot.querySelector("#focused-annotation-author")
                            .textContent = "";
                        this._shadowRoot.querySelector("#focused-annotation-date")
                            .textContent = "";
                        this._shadowRoot.querySelector("#focused-annotation-text")
                            .textContent = "";
                    }
                    break;
                case "select":
                    if (annotations === null || annotations === void 0 ? void 0 : annotations.length) {
                        this._mainContainer.classList.add("annotation-selected");
                        this._mainContainer.classList.add("annotation-focused");
                    }
                    else {
                        this._mainContainer.classList.remove("annotation-selected");
                        this._mainContainer.classList.remove("annotation-focused");
                    }
                    break;
                case "add":
                case "delete":
                case "render":
                    if (annotations === null || annotations === void 0 ? void 0 : annotations.length) {
                        const imageUuidSet = new Set(annotations.map(x => x.imageUuid));
                        if (this._imageService.currentImageView
                            && imageUuidSet.has(this._imageService.currentImageView.imageInfo.uuid)) {
                            yield this._imageService.currentImageView.renderViewAsync(true);
                        }
                    }
                    break;
            }
            if (this._annotChangeCallback) {
                this._annotChangeCallback(e.detail);
            }
        });
        this.onAnnotatorDataChanged = (event) => {
            annotatorTypes.forEach(x => {
                this._mainContainer.classList.remove(x + "-annotator-data-saveable");
                this._mainContainer.classList.remove(x + "-annotator-data-undoable");
                this._mainContainer.classList.remove(x + "-annotator-data-clearable");
            });
            if (event.detail.saveable) {
                this._mainContainer.classList.add(event.detail.annotatorType + "-annotator-data-saveable");
            }
            if (event.detail.undoable) {
                this._mainContainer.classList.add(event.detail.annotatorType + "-annotator-data-undoable");
            }
            if (event.detail.clearable) {
                this._mainContainer.classList.add(event.detail.annotatorType + "-annotator-data-clearable");
            }
        };
        this.onAnnotatorEditTextButtonClick = () => __awaiter(this, void 0, void 0, function* () {
            var _b, _c;
            const initialText = (_b = this._imageService) === null || _b === void 0 ? void 0 : _b.getSelectedAnnotationTextContent();
            const text = yield this._viewer.showTextDialogAsync(initialText);
            if (text === null) {
                return;
            }
            yield ((_c = this._imageService) === null || _c === void 0 ? void 0 : _c.setSelectedAnnotationTextContentAsync(text));
        });
        this.onAnnotatorDeleteButtonClick = () => {
            var _a;
            (_a = this._imageService) === null || _a === void 0 ? void 0 : _a.deleteSelectedAnnotation();
        };
        this.onAnnotatorSelectModeButtonClick = () => {
            this.setAnnotatorMode("select");
        };
        this.onAnnotatorStampModeButtonClick = () => {
            this.setAnnotatorMode("stamp");
        };
        this.onAnnotatorPenModeButtonClick = () => {
            this.setAnnotatorMode("pen");
        };
        this.onAnnotatorGeometricModeButtonClick = () => {
            this.setAnnotatorMode("geometric");
        };
        this.onAnnotatorTextModeButtonClick = () => {
            this.setAnnotatorMode("text");
        };
        this.imageServiceUndo = () => {
            var _a;
            (_a = this._imageService) === null || _a === void 0 ? void 0 : _a.undoAsync();
        };
        this.onImageChange = (e) => {
            if (e.detail.type === "open"
                || e.detail.type === "close") {
                setTimeout(() => this.refreshImages(), 0);
            }
            else if (e.detail.type === "select") {
                setTimeout(() => this.setAnnotatorMode(this._annotatorService.mode), 0);
            }
        };
        this.onImageServiceStateChange = (e) => {
            if (e.detail.undoableCount) {
                this._mainContainer.classList.add("undoable-commands");
            }
            else {
                this._mainContainer.classList.remove("undoable-commands");
            }
        };
        this.onPreviewerToggleClick = () => {
            this.showPreviewer(this._previewer.hidden);
        };
        this.onMainContainerPointerMove = (event) => {
            const { clientX, clientY } = event;
            const { x: rectX, y: rectY, width, height } = this._mainContainer.getBoundingClientRect();
            const l = clientX - rectX;
            const t = clientY - rectY;
            const r = width - l;
            const b = height - t;
            if (Math.min(l, r, t, b) > 150) {
                if (!this._panelsHidden && !this._timers.hidePanels) {
                    this._timers.hidePanels = setTimeout(() => {
                        if (!this._imageService.currentImageView) {
                            return;
                        }
                        this._mainContainer.classList.add("hide-panels");
                        this._panelsHidden = true;
                        this._timers.hidePanels = null;
                    }, 5000);
                }
            }
            else {
                if (this._timers.hidePanels) {
                    clearTimeout(this._timers.hidePanels);
                    this._timers.hidePanels = null;
                }
                if (this._panelsHidden) {
                    this._mainContainer.classList.remove("hide-panels");
                    this._panelsHidden = false;
                }
            }
        };
        if (!options) {
            throw new Error("No options provided");
        }
        const container = document.querySelector(options.containerSelector);
        if (!container) {
            throw new Error("Container not found");
        }
        else if (!(container instanceof HTMLDivElement)) {
            throw new Error("Container is not a DIV element");
        }
        else {
            this._outerContainer = container;
        }
        this._userName = options.userName || "guest";
        this._fileOpenAction = options.fileOpenAction;
        this._fileSaveAction = options.fileSaveAction;
        this._fileCloseAction = options.fileCloseAction;
        this._annotChangeCallback = options.annotChangeCallback;
        const lazyLoadImages = (_a = options.lazyLoadImages) !== null && _a !== void 0 ? _a : true;
        const previewWidth = options.previewWidth || 100;
        this._shadowRoot = this._outerContainer.attachShadow({ mode: "open" });
        this._shadowRoot.innerHTML = styles + mainHtml;
        this._mainContainer = this._shadowRoot.querySelector("div#main-container");
        this._eventService = new EventService(this._mainContainer);
        this._imageService = new ImageService(this._eventService, {
            lazyLoadImages: lazyLoadImages,
            previewWidth: previewWidth,
            userName: this._userName,
        });
        this._loader = new Loader();
        this._previewer = new Previewer(this._imageService, this._shadowRoot.querySelector("#previewer"), { canvasWidth: previewWidth });
        this._viewer = new Viewer(this._imageService, this._shadowRoot.querySelector("#viewer"));
        this._viewer.container.addEventListener("contextmenu", e => e.preventDefault());
        this._annotatorService = new AnnotatorService(this._imageService, this._viewer);
        this.initMainContainerEventHandlers();
        this.initViewControls();
        this.initFileButtons(options.fileButtons || []);
        this.initModeSwitchButtons();
        this.initAnnotationButtons();
        this._eventService.addListener(imageChangeEvent, this.onImageChange);
        this._eventService.addListener(imageServiceStateChangeEvent, this.onImageServiceStateChange);
        this._eventService.addListener(annotChangeEvent, this.onAnnotatorChange);
        this._eventService.addListener(annotatorDataChangeEvent, this.onAnnotatorDataChanged);
    }
    destroy() {
        var _a, _b;
        this._annotChangeCallback = null;
        (_a = this._annotatorService) === null || _a === void 0 ? void 0 : _a.destroy();
        this._viewer.destroy();
        this._previewer.destroy();
        this._imageService.destroy();
        this._eventService.removeListener(imageServiceStateChangeEvent, this.onImageServiceStateChange);
        this._eventService.removeListener(imageChangeEvent, this.onImageChange);
        this._eventService.destroy();
        (_b = this._mainContainerRObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        this._shadowRoot.innerHTML = "";
    }
    openImagesAsync(loadInfos) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._imageService.addImagesAsync(loadInfos);
            }
            catch (e) {
                throw new Error(`Cannot load file data: ${e.message}`);
            }
        });
    }
    closeImages() {
        this._imageService.clearImages();
    }
    importAnnotations(dtos) {
        try {
            this._imageService.appendSerializedAnnotations(dtos);
        }
        catch (e) {
            console.log(`Error while importing annotations: ${e.message}`);
        }
    }
    importAnnotationsFromJson(json) {
        try {
            const dtos = JSON.parse(json);
            this._imageService.appendSerializedAnnotations(dtos);
        }
        catch (e) {
            console.log(`Error while importing annotations: ${e.message}`);
        }
    }
    exportAnnotations(imageUuid) {
        const dtos = this._imageService.serializeAnnotations(imageUuid);
        return dtos;
    }
    exportAnnotationsToJson(imageUuid) {
        const dtos = this._imageService.serializeAnnotations(imageUuid);
        return JSON.stringify(dtos);
    }
    initMainContainerEventHandlers() {
        const mcResizeObserver = new ResizeObserver((entries) => {
            const { width } = this._mainContainer.getBoundingClientRect();
            if (width < 721) {
                this._mainContainer.classList.add("mobile");
            }
            else {
                this._mainContainer.classList.remove("mobile");
            }
            if (width < 400) {
                this._mainContainer.classList.add("compact");
            }
            else {
                this._mainContainer.classList.remove("compact");
            }
        });
        mcResizeObserver.observe(this._mainContainer);
        this._mainContainerRObserver = mcResizeObserver;
        this._mainContainer.addEventListener("pointermove", this.onMainContainerPointerMove);
    }
    initViewControls() {
        this._shadowRoot.querySelector("#paginator-prev")
            .addEventListener("click", this.onPaginatorPrevClick);
        this._shadowRoot.querySelector("#paginator-next")
            .addEventListener("click", this.onPaginatorNextClick);
        this._shadowRoot.querySelector("#rotate-counterclockwise")
            .addEventListener("click", this.onRotateCounterClockwiseClick);
        this._shadowRoot.querySelector("#rotate-clockwise")
            .addEventListener("click", this.onRotateClockwiseClick);
        this._shadowRoot.querySelector("#zoom-out")
            .addEventListener("click", this.onZoomOutClick);
        this._shadowRoot.querySelector("#zoom-in")
            .addEventListener("click", this.onZoomInClick);
        this._shadowRoot.querySelector("#zoom-fit-viewer")
            .addEventListener("click", this.onZoomFitViewerClick);
        this._shadowRoot.querySelector("#zoom-fit-image")
            .addEventListener("click", this.onZoomFitImageClick);
        this._shadowRoot.querySelector("#toggle-previewer")
            .addEventListener("click", this.onPreviewerToggleClick);
    }
    initFileButtons(fileButtons) {
        const openButton = this._shadowRoot.querySelector("#button-open-file");
        const saveButton = this._shadowRoot.querySelector("#button-save-file");
        const closeButton = this._shadowRoot.querySelector("#button-close-file");
        if (fileButtons.includes("open")) {
            this._fileInput = this._shadowRoot.getElementById("open-file-input");
            this._fileInput.addEventListener("change", this.onFileInput);
            openButton.addEventListener("click", this._fileOpenAction || this.onOpenFileButtonClick);
        }
        else {
            openButton.remove();
        }
        if (fileButtons.includes("save")) {
            saveButton.addEventListener("click", this._fileSaveAction || this.onSaveFileButtonClick);
        }
        else {
            saveButton.remove();
        }
        if (fileButtons.includes("close")) {
            closeButton.addEventListener("click", this._fileCloseAction || this.onCloseFileButtonClick);
        }
        else {
            closeButton.remove();
        }
    }
    initModeSwitchButtons() {
        this._shadowRoot.querySelector("#button-mode-hand")
            .addEventListener("click", this.onHandModeButtonClick);
        this._shadowRoot.querySelector("#button-mode-annotation")
            .addEventListener("click", this.onAnnotatorModeButtonClick);
        this.setViewerMode("hand");
    }
    initAnnotationButtons() {
        this._shadowRoot.querySelector("#button-annotation-mode-select")
            .addEventListener("click", this.onAnnotatorSelectModeButtonClick);
        this._shadowRoot.querySelector("#button-annotation-mode-pen")
            .addEventListener("click", this.onAnnotatorPenModeButtonClick);
        this._shadowRoot.querySelector("#button-annotation-edit-text")
            .addEventListener("click", this.onAnnotatorEditTextButtonClick);
        this._shadowRoot.querySelector("#button-annotation-delete")
            .addEventListener("click", this.onAnnotatorDeleteButtonClick);
        this._shadowRoot.querySelector("#button-annotation-pen-undo")
            .addEventListener("click", this.annotatorUndo);
        this._shadowRoot.querySelector("#button-annotation-pen-clear")
            .addEventListener("click", this.annotatorClear);
        this._shadowRoot.querySelector("#button-annotation-pen-save")
            .addEventListener("click", this.annotatorSave);
        this._shadowRoot.querySelector("#button-annotation-geometric-undo")
            .addEventListener("click", this.annotatorUndo);
        this._shadowRoot.querySelector("#button-annotation-geometric-clear")
            .addEventListener("click", this.annotatorClear);
        this._shadowRoot.querySelector("#button-annotation-geometric-save")
            .addEventListener("click", this.annotatorSave);
        this._shadowRoot.querySelector("#button-annotation-text-undo")
            .addEventListener("click", this.annotatorUndo);
        this._shadowRoot.querySelector("#button-annotation-text-clear")
            .addEventListener("click", this.annotatorClear);
        this._shadowRoot.querySelector("#button-annotation-text-save")
            .addEventListener("click", this.annotatorSave);
        this._shadowRoot.querySelector("#button-command-undo")
            .addEventListener("click", this.imageServiceUndo);
    }
    setViewerMode(mode) {
        mode = mode || "hand";
        viewerModes.forEach(x => {
            this._mainContainer.classList.remove("mode-" + x);
            this._shadowRoot.querySelector("#button-mode-" + x).classList.remove("on");
        });
        this.setAnnotatorMode("select");
        this._mainContainer.classList.add("mode-" + mode);
        this._shadowRoot.querySelector("#button-mode-" + mode).classList.add("on");
        this._viewer.mode = mode;
    }
    setAnnotatorMode(mode) {
        var _a, _b;
        if (!this._annotatorService || !mode) {
            return;
        }
        const prevMode = this._annotatorService.mode;
        (_a = this._shadowRoot.querySelector(`#button-annotation-mode-${prevMode}`)) === null || _a === void 0 ? void 0 : _a.classList.remove("on");
        (_b = this._shadowRoot.querySelector(`#button-annotation-mode-${mode}`)) === null || _b === void 0 ? void 0 : _b.classList.add("on");
        this._annotatorService.mode = mode;
    }
    showPreviewer(value) {
        if (value) {
            this._mainContainer.classList.remove("hide-previewer");
            this._shadowRoot.querySelector("div#toggle-previewer").classList.add("on");
            this._previewer.show();
            setTimeout(() => this._viewer.zoomFitImage(), 1000);
        }
        else {
            this._mainContainer.classList.add("hide-previewer");
            this._shadowRoot.querySelector("div#toggle-previewer").classList.remove("on");
            this._previewer.hide();
        }
    }
    refreshImages() {
        const imageCount = this._imageService.imageCount;
        if (!imageCount) {
            this._mainContainer.classList.add("disabled");
            this.setViewerMode("hand");
            this.setAnnotatorMode("select");
            this.showPreviewer(false);
            return;
        }
        this._mainContainer.classList.remove("disabled");
        if (imageCount === 1) {
            this.showPreviewer(false);
            this._shadowRoot.querySelector("#paginator").classList.add("disabled");
        }
        else {
            this.showPreviewer(true);
            this._shadowRoot.querySelector("#paginator").classList.remove("disabled");
        }
    }
}

export { AnnotEvent, TsImageViewer };
