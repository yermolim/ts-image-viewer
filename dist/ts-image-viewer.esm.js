/**
 * MIT License
 *
 * Copyright (c) 2021-present yermolim
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import { v4 } from 'uuid';

var img$g = "data:image/png;base64,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";

var img$f = "data:image/png;base64,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";

var img$e = "data:image/png;base64,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";

var img$d = "data:image/png;base64,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";

var img$c = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZG9S8NQFMVPW8Wi1Q46SHHIUMWhhaIgjlLBLtWhrWDVJXlN2kKShpcUKa6Ci0PBQXTxa/A/0FVwVRAERRBx8R/wa5ES72sKLdLe8PJ+nHfP5eUE8Kd1Zth9CcAwHZ5JJaW1/Lo08A4fRhBEHBGZ2dZydimHnvXzSN1UD3Exq3df1xoqqDYDfEHiOWZxh3iBOL3lWIL3iMdYSS4QnxDHOF2Q+Fboisdvgosefwnmucwi4BczpWIHKx3MStwgniaOGnqVte4jviSkmqtZ2iO0JmAjgxSSkKCgijJ0OJRLGSZl1t2XaPpWUCEPo7eFGjg5iiiRN0ZqlaaqtGukq/ToqInc/+dpa7Mz3vRQEuh/dd3PSWBgH2jUXff31HUbZ0DgBbg22/4K5TT/TXq9rUWPgfAOcHnT1pQD4GoXGH+2ZC43pQAtv6YBHxfAcB4YvQcGN7ysWuc4fwJy2/SL7oDDI2CK+sObf/JNaAQfxWcoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+0lEQVR42u2bMW/EIAyFA7qla5Ol///HdUm6dguFKlQuBwnh7ADKs5TlTsrxPp6NAZ16H0czCMTXsijO90mNUw83DwC4OwAV5hZ37rYWoV6kAAAAAAAAAAAAAAAAAAAAAADcMh6CO63F7iwnkR2cUmqe57YcEIq3zyg4cWaapnYARM7rRjtLYupXY9ggaAHxzqKDtSgbAXdIkwBqqgK4QryP8J3OBe6xLjBVAFwpnjoh9rmDUJoOuhfxqXTwTiitCbon8WE6ROrCaQi6N/GxdFjX9XtzwWkIukS8/cHPmuKfnKD1W6kTdMnM2x/8qC0+VhNIPciGoEts7+nb75ro53cm4nCJ3L0ZkrqRvWSXRwokBZR9M9SzeJoOR82SziHYe5C6kA/A2cZB8E/PsXfh+zgqLt4+DgIl2cotsivEdizJlD0aZ84ymOy/G5nd5FhyJukQwHby8td60jW3hULpxP8Wu605O+vQrEaIQqDtZ20nePG+OStJz+xW+MkJpP2s4QQqvmTmizZDUSdsg7jSCVzii7bDHkK4PF5VEzjFFx+IOAip/lsSArf4YgCxZkl6iZQQ/zKAVJ/AnQ5S4lkA0Jog3Msv3OK5HBBdHZjj300TZxvOdjcoCYHrjlHMAT0HAAAAAAAAAAAAAAAAAAAAANwzFP47jBQAgFvHDyRnPtj60cBDAAAAAElFTkSuQmCC";

var img$b = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZG9S8NQFMVPW8Wi1Q46SHHIUMWhhaIgjlLBLtWhrWDVJXlN2kKShpcUKa6Ci0PBQXTxa/A/0FVwVRAERRBx8R/wa5ES72sKLdLe8PJ+nHfP5eUE8Kd1Zth9CcAwHZ5JJaW1/Lo08A4fRhBEHBGZ2dZydimHnvXzSN1UD3Exq3df1xoqqDYDfEHiOWZxh3iBOL3lWIL3iMdYSS4QnxDHOF2Q+Fboisdvgosefwnmucwi4BczpWIHKx3MStwgniaOGnqVte4jviSkmqtZ2iO0JmAjgxSSkKCgijJ0OJRLGSZl1t2XaPpWUCEPo7eFGjg5iiiRN0ZqlaaqtGukq/ToqInc/+dpa7Mz3vRQEuh/dd3PSWBgH2jUXff31HUbZ0DgBbg22/4K5TT/TXq9rUWPgfAOcHnT1pQD4GoXGH+2ZC43pQAtv6YBHxfAcB4YvQcGN7ysWuc4fwJy2/SL7oDDI2CK+sObf/JNaAQfxWcoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB30lEQVR42u2bzXKDIBCAw+ql6cnqpQ/Q93+f9gF60aan9GKwmkqHsXZA5Wd3YWcyySFO+D4WCLKKU+R4qush5u/DKfHIAlIXIFIDXs45eQhkAYlHiaUhTdMMcvgZniDcTE397Xb9vFweKQgoFfwU+ue1kFJ+AcDDf6J+RQKcqWRAv+cikyhqc4Ax71WPT73Pbg746Lpd/0uO7iVIrwIuNlJkBIyrhJddJBkBbdt62UIDp7Qf5xExL5PvLAXYwM+rxDM7AbbwLIeAL3gSAnzCoxfgGx61gBDwaAWEgkcpICQ8OgGh4VEJiAGPRkAseBQCPMF3JAQo+LV7e3vh9esGKd9M3xeppT2Kk6GYY/5PBiwb47sBmOCDZwA2eCsBVVW9Tg0fX63TsadNfLHgrQQIgBebHtza8+pQIyb81iFQc0n7YHMAdnivAijAexNABd6LAErwzgVQg3cqgCK8MwFU4Z0IoAx/WAB1+EMCOMBvEqAfOXOB3yRAHTlzgne6DOrwy3IW9gKWPa+Xs7AXQDHt9ThcJ7h2p8eiglPMdYF85oCpfvf+ble+OpDMAFNx8o7f7tELGHv2WhbF2SQGisJYv7soh+9JZICp3p565EdmsoDEQ8R+dpfSwUgeAlkAw/gGgdL3j4c6UpkAAAAASUVORK5CYII=";

var img$a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcmlDQ1BpY2MAACiRdZE9S8NQFIbftkpFWwrqIOKQoYpCC0VBHKWCXapDW8GqS3KbtEKShpsUKa6Ci0PBQXTxa/Af6Cq4KgiCIoi4+Af8WqTEc5tCi7Qn3JyH9573cO+5gD+tM8PuSQCG6fBMKimt5tek4Dt8GEQYQ5iSmW0tZRdz6Bo/j1RN8RAXvbrXdYyBgmozwNdHPMss7hDPE6e3HEvwHvEwK8kF4hPiGKcDEt8KXfH4TXDR4y/BPJdZAPyip1RsY6WNWYkbxJPEUUOvsOZ5xE1CqrmSpTxKaww2MkghCQkKKtiEDgdxyibNrLMv0fAto0weRn8LVXByFFEib4zUCnVVKWukq/TpqIq5/5+nrc1Me91DSaD31XU/x4HgPlCvue7vqevWz4DAC3BttvxlmtPcN+m1lhY9BiI7wOVNS1MOgKtdYOTZkrnckAK0/JoGfFwA4TwwdA/0r3uzau7j/AnIbdMT3QGHR8AE1Uc2/gDt82gCvNGYhAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAcpJREFUeNrtWwFuwyAMjBEPWNf8/4XpugesoWMKUppBYidQ5cAnVZWaRtGdDxscoC6Bvu9d7PfRue6sMETJa8MwRC8Slzi6ACkhiEu8FgGWQpiucdBW9FNj5wiWzyvxjOk5/muVm30n8Xfjl8NfkNeEMLHo10Cem/CbyAHeCZMb/sGePfqTfXfh5/Hovu/3F25Lx9ujiURad6WIld1xHDtjTLLshXv8f7Zgka2dY04ClQNCxDmR5eL0Dvi63Vavf16vh1xjzzy13YKUPPQQWFaDHOShBJjX8VzkIRdDa+RDvvBlskoBOOSlVcLURr7KIVCKPIQAJclDJsGc5FkzwdBUqJE8pANykocTIDd59mKI2zIv0Q8oSR7GAaXIQwhQkjx0GVQBGI5xjEWRrTGqkmGjQ0AFUAFUABVABVAB2sXmRMi3pEbnSDLJyNm3h3MAEvnsAqCRZw0Bb/l5Q2THjg1qaghoFVABVAAVQAVQAVQAFUCCI9thxYSJXj5WcspCHaACNNgP+LhcTr+gySqAX/nNX2nP99ujI/aaX3NAbAPDkQ0RSNFfPTUWbkA/QLUVTNoT9RpOj+rJ0aUDJE5AdkDy8LRECEQBUrnsCeUexwK5uUFRAAAAAElFTkSuQmCC";

var img$9 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZE9S8NQFIbfpkpFqx3qIMUhQxWHFoqCOEoFu1SHtoJVl+Q2aYQkDUmKFFfBxaHgILr4NfgPdBVcFQRBEURc/AN+LVLiuU2hRdoTbs7De897uPdcQMjqzHD6UoBhunYukxZXi2ti6B0BxDACAVGJOdZSfrGAnvHzSNUUD0neq3dd1xgqKQ4DAgPEs8yyXeJ54uyWa3HeIx5lmlQiPiFO2HRA4luuyz6/cS77/MXZLuQWAIH3FMsdLHcw02yDeIo4buhV1joPv0lYMVfylGO0xuEghwzSECGjik3ocJGkbNLMuvtSTd8yKuRh9LdQg02OMjTyJkitUleFskq6Qp+OGp/7/3k66sy03z2cBvpfPe9zAgjtA4265/2eel7jDAi+ANdm21+hOc19k15va/FjILIDXN60NfkAuNoFxp4tyZaaUpCWoKrAxwUwXASi98Dguj+r1j7On4DCNj3RHXB4BExSfWTjD603Z+Sp2ztrAAAACXBIWXMAAAsTAAALEwEAmpwYAAADGklEQVR42uVbC47jIAytESeY6f1P2NkjLCOqInmoP5g4BChSpLZJAT8/G9sQuDHtfr+Tv/9P6WZp/35+tP6lDsEyXgBg7z0eD3qAVsE9AWgU/s8cOQG+vr+bAOCAiK2Cn9CS4TnwGrTIWYAItw9voGmfo56DJlI1DnD38jx75qGxOvcZRwuuCV++V888zaCmLyUkvlc+S0BE6uZBtBMDKHjYbvnMzVG6Rz0bvbSaByWo+0frR0GQWCSZicSE0Kv93Fm5mAl10V/4PSkrSGpRkgrAUXoatWbq8yVA8ujfFQBOg56UbxXQCoIXACytvUHwBjkepffL+Q0PYGqQseaxw5WWyScDcmyPr6uEYOzdnT3YcTcxwMsBtsTlXv1aVoJwpv0bNH16tDl8FThTmwygXeYSBtn61YAmLn6YlgFW0Bg/UgueatMYWQ+AWRiFQZjSBOql6kwneWlF6MyaA8E+6EqHtUleEQUeMD2ofcJH1QRPS4cno7tp/NjoMGbSIljpL4EfPo3ybwzAOzd5aRC0DSOTllEgBEPykBSAlmzBkjkhILyWJLb2Vy7qP54heW89oGu/rgiEKskiRdGETyurBUr7L08L0sA9FdhpTYBaZopmpMKjBwjO+5KiuVD9xVYPSuzXTRdAtdQRc90TnyMIBxBetuHib+jQxjYgPNnQ68m3igOsjm0nEALl4Q2BzvIgRC3Qwaewciu5A9pzr4sM65nAQRYszYioxPzqQUXsDzJbOMZMDwAX6GQB6vM522WDStKzdYt1HlCzQNrBXZEROAxuDYS2YUGtrAwGmw1+SmsNhdMm2n87Wxha1/PdvH/xa8GQg69eEL3ufMBszg+zPBjD2jRwgmfavv7CxC7rvqbcgA89E4cKYQNfkCTlDt0XmGDZezNt1QmuGBgJwvNvjeE/t5Siy3ncq/f9LcJTrA1Wp7GAQ2SFJ0+ItGx5C0XQNJPmhYIuiG+Otm5P9QzQypwjpmSlPR4TNDoTr6iRA40+ak/l95QD1+RaemdIE96UDqMDCUuBYBW+lhM0O1VC4nQl/SkW1MJrcvwCJhH28gf87HUAAAAASUVORK5CYII=";

var img$8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/N4piFBEtRCxSRLFQCApiKRFMoxYxgq8mu24SIRuX3Q0itoKNRcBCtPFV+A+0FWwVBEERRGz8A74akfVOVohIMsvs/Tgz5zJzBrTJvGG59TGwCp6TTMQjc/MLkcYXQmiE6aQ9bbj21MxEiprj8446VW8HVa/a+6qO8LLpGlDXJDxi2I4nPCY8uebZireFO41celn4UHjAkQMKXyldD/hZcTbgd8VOKjkOmuoZyf5h/Q8bOccS7heOWvmi8XsedZMWszA7I7VbZg8uSRLEiaBTZIU8HoNSC5JZdV+s7JtmVTyG/G3WccSRJSfeAVGL0tWUmhHdlC/Pusr9f55uZngo6N4Sh4Yn33/rhcYd+C75/teR738fQ+gRLgoV/6rkNPoheqmiRQ+gbRPOLiuavgvnW9D1YKeddFkKydQyGXg9hdZ56LiB5sUgq991Tu4htSFPdA17+9An+9uWfgCZXmfbLPy9EwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAhxJREFUeNrtW1lywyAMtRhO0OT+J3SaHqCxanfijsuAEQaEWDTjn2CM3kMbS2ByyP1+R9vvC+IkVRSAs22eZ2sjUIHXToCLCKACb4UAkwg1dS7gm32X78TIOp45RhZw73FOsWlO4NzyJhbOiFC22W8BPDXgdxEDNktwuZmWPvtmvAiR79dr+no+/2EzLV7nVCBFgLOl3WVZJqWUM+3tfbZ3fKJrNu0UNYmOncFYCwktdDbQlJlNRkBp+Xw8Tts/brcoq4H1A2gMSAmCUuthr+4m3iu2hIINJli37tcCKoeZSXaB4CDoiPLkgWxZ5Opi6Czg7cHSfMcXRKtxAQp4LhdoBnwVBOQEX3UWSAF+FEKbBWxMBrLZVCG0d/p9THZ87wt9KBbw94ClU9MuYOquMw7UbCnc/VpgEDAIaEhitsQ4MgFItQCuNIjDBYQSwFUHgOQYAD1bwEiDzRBw3HEJPWWpUUyMuhfgLhJ0dyZvHKnrkKtlIwgOAgYB7RNAvTJbo9iwjauyLmZauyzpwqh9HWonwufScMX3z66nHc7pkxK3fhcpVSu1rslyXf54xLYrnBK8OUbS/YCdkZRZYFM81hJSEmlzaedd4VRExJCQEjz5P0MJBH3xhvk7/jQokATk0jdnirsKAjl1zZ3jQ8Egt54cRQ4VFJbQkavK84HDUvpxlrkoUTfuOh+l6VVioYOSdCq50kNBuhQloegO1A9Y7hjyBIja5wAAAABJRU5ErkJggg==";

var img$7 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZG9S0JRGMZ/adGX4VBDRIODRYOCGERjGNRiDWrQ16LXezVQu9yrRLQGLQ1BQ9TS19B/UGvQWhAERRDR0j/Q1xJye48KSui5nPv+eM55Xs55DriiOS1vt4cgXyhasdmIb3Fp2df5jpsh+gnTndRscy4+k6Dl+HmkTdWHoOrVel/T0ZvWbQ3auoQnNNMqCk8JRzeKpuJd4QEtm0wLnwgHLDmg8K3SU1V+U5yp8pdiKxGbBpfq6cs0cKqBtayVFx4T9udzJa12HnUTj15YiEsdkjmMTYxZIvhIUWKNHEWCUguSWXNfqOKbZ108mvxNNrHEkSEr3oCoJemqSzVE1+XLsaly/5+nbYyHq909Eeh4dZzPEejch/Ke4/yeOk75DNwvcF2o+9clp8lv0ffqmv8YvNtweVPXUgdwtQODz2bSSlYkt0yXYcDHBfQtQf899KxUs6qtc/4EiS15ojs4PIJR2e9d/QMO/2gR3i+r3wAAAAlwSFlzAAALEwAACxMBAJqcGAAAAvVJREFUeNrtW01y0zAYtRQPadzpkEQ5AwcoXcCGHSdgxTFaTtA9tGy5BxumnemCbXoD9mwsJ6sYZlqLT0EeUiNZ/pHj2P40o3HGcWS99733SXJk4hnKYrHQnk+E2B4jzr1DKXPGtkdKiPGaMAy150c64EEQGBsS6hjHca1Ow31ePhuPf0yOjye/4viuTlsT1V+SQ4DEJOtms3lyntgi3oQCIGIrOEx3z0F7pEkFmBRB9y1XxthZFrwsM8au27APsUXf5J2q4EE/NzoClL0+rzg/d3U/m6oltlHqD92XWb/U9TwAXMLHoyRJfoJfTzTReDUOgueQE765uKfsv6ymnCa/G+lYchn1FDzkjlsJXiWrkxxJvnZJginA6fnGc4BMeAB+qWS/zk2woAyVmM6njF256oMMqCmoJKsAl9FXkV9W/X3ieddrzi+qev3h8dFbr1a519IijetqgchHKXiIbGwb7nTnpRKgHVGaOBiqZaXULvBGLCAjL0e2v6ld/IaOTIqM9abvgYRPRQCntUyhTYCHTtz8MxkZl5noGK67sJFQtVDH4E+V7Gd1ZnlGEubzj3X7mFULrSMfDfjborKuRAIhH1yQ4FwBKuHd1418GyRQB7J/kQXuAryNBFg7XB4EAUKIt02BN7TH1azpvea6dEK1PwI451+Ahe9Ngde0y+B+X4H4dzrwW1C0OCzfQd8eoih6s4+la84k6jCGwS4WJGDoBFhzgOtnA6gAJKBjFjA9cOiLNdACSAAS0K+yOy0WBRZFfh+jWmZtgBZAApAAJAAJQAKQgGGvBrN/Bz158Cg3IO3+Y3RI2+MqFoEKQAJKECAlL/ffpbXoBoku5YDWFyzpRsfBWCCbSNtMrJgDkAAkAAlAAoa+FhhWxDMvVfhl3rJACyABAyRgOpv1mgD5vsB/+2PDMOxlYtBh9VvqiKchvR0L6KKtY6qP0ZfYfdsPum4HWzBJlajX2Va/74mOqaSBHfwwWMn/XVZA1tKkine6SIApl/0BVV9uhgTVncEAAAAASUVORK5CYII=";

var img$6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABbmlDQ1BpY2MAACiRdZG9S0JRGMZ/amGY4VBDRIODhYRCFERjGORiDWqQ1aLXr8CPy71KSGvQ0iA0RC19Df0HtQatBUFQBBEt/QN9LSG392RghJ7Lue+P55zn5ZzngD1S0Ipm1zgUSxUjGg55lxLLXucLDly4GcOf1Ex9PjYXp+P4vMOm6m1Q9eq8r+3oTWdMDWw9wlOablSEZ4Qj6xVd8bbwgJZPpoUPhQOGHFD4SumpJj8rzjX5XbERj86CXfX05v5w6g9reaMo7Bf2FQtV7fc86ibuTGkxJnVI5jAmUcKE8JKiyhoFKgSlliSz9r7xH98CZfFo8tepYYgjR168AVGr0jUjNSt6Rr4CNZX7/zzN7OREs7s7BN1PlvU2As4daNQt6+vIshrH4HiEi1LLX5acpj9Er7c03wF4NuHssqWlduF8CwYf9KSR/JEcMu3ZLLyeQl8C+m/AtdLM6nedk3uIb8gTXcPePozKfs/qNw5zaBHJcPVKAAAACXBIWXMAAAsTAAALEwEAmpwYAAADIUlEQVR42u1bPY7UMBS2PZYQotmdTMMhqFhKGsR23IN6F1pEg7bj5xZUnICSluEAXIBmnEkFQsomPId45bGcxEnsTJ4nT7I0cX7s73u/diaUNMhms7H2F2VJ+kgqhK3b9hBqu3CdJM5jMUobz+12O2s/dwWOXRQukwgeO/AuIhg5caFd2m/ynZHiHAN8aLsNG58Y+KSiMLQRwWwnYwDvaiEnEQOkQp3T4Ny0PyY75be3JNvvD7CZz+MhJ+CDUFvhVRQFYYw1Fj7qHnlNl3DMpt23KrUGQUyAlcZdNOsqR7EAWd/rawTz2GEtMWitYLMa7sOMhpIwh2egcQEzGPsAj4oAPZv4Ao9yMdQGXsULmSajJMAFfN8swWIDH6ULhAKPgoCQ4FEGQZ/gnSrBOe4N+AKP0gJ8gkdHgG/wzouhMXsCvlwoBHg0FhAKPAoCQoJHnQYXAhwspnRYFPEYtdrHbRYXWAhYCFgIWAhYCDhhGV0H5Hn+iDF2Qyh9UedgGmqy6yT5/xanLL+lafpMDu/DAkqjmYNWr5NUU+/aVaOUfqnBi4NJhgIvhdKnSZK8HPioA7zjXYCxz/WvxDpZ3+DvOKBfZxED9kK8BZN87zJpX+DlsGB9PychQNbV8rW0anJzRG/VNWn6OgQJlvv3MIfHMKf17LKAbxJs9wH456D5H7NNgxUJhHwYS0KD5i98gw9SB4B5vhpDgpbq/mqavwTwWzSFUE0C6UuCOl8UxR8I8/e0gBcEfNBKUBZEBSEfXUnQ+6Gwul9r/sJnwAtSCXZsmV/nUDwBy1e1Zn8BuIct12fQztTvkJqfbC2QCXGtLKEDPKnBZ7Xmz6NZDOkk2ERahpHqtmQimWw1KEkAJ/9kr6Yry8hgFfUkNHi9qKua2RFSoGy+aiIBRr4UQnyPfj9AkmA3kOnBH21DRKZIsIR34Pu/pwx4gwg4O/c/N5k6V5S+4avVAzjcHvODLdtncyUEortgoP/fHrtIbLNwgTkJ07XdxlSM2pfYedcNNoKwAzfSb3+tH+sv9q6FjosoxS5fjg7xf8wWYLo0HeI7GAloimX/ANBjieJDfrkhAAAAAElFTkSuQmCC";

var img$5 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/EyXigxSxELFIEcXCoCiIWEkEbaJFEsFXk6x5CHksuxsk2Ao2FoKFaOOr8B9oK9gqCIIiiNj4B3w1EtY72UCCJLPM3o8zcy4zZ8AVzmo5s3UUcnnLiMyF/EvLK37POy58eBhhKq6Z+nx0NkbT8fNIi6oPQdWr+b6Go3M9aWrQ0i48oemGJTwtHN60dMW7wj1aJr4ufCI8bMgBhW+VnnD4TXHa4S/FRiwyAy7V05+u40QdaxkjJzwkHMhli1r1POomXcn8YlRqn8x+TCLMEcJPgiIbZLEISs1LZo19oxXfAgXxaPLXKWGII01GvMOiFqVrUmpK9KR8WUoq9/95mqnxMad7VwjaXm37cwA8+1Des+3fU9sun4H7Ba7zNX9Bcpr8Fn2vpgWOwbsNlzc1LXEAVzvQ+6zHjXhFcst0pVLwcQHdy+C7h45VJ6vqOudPENuSJ7qDwyMYlP3etT9GwWgrP+9tUQAAAAlwSFlzAAALEwAACxMBAJqcGAAACZpJREFUeNrNW11sHNUVvnN31xtt145nZxfbiL+KQHAfioIqpYT0oVJ5ICEUVPKAFEFf7AZIlLa0lZBaVaoUqX+o1DStGh7a0qhqRVRKoZEpUh8KhUi0BFWqsEhIUCqR2N3ZtWM79npn5/Y7w665e3d2/nbG3itZO56Znbnnu+fnO+ee1VjCo1QqjTYajbuEpt0uGBvXbPuTgvMRfF6jcT5A99hC1JmmzeHcLK5d0Bh7VxPiHc75G+Vy+VKS89OSeGihUNiJjwdtTdvDGfuU2z22bTMI2HHsct8Mrp0Stn2yWq2exinRlwBA6CGs8gQmOokJ35oEsHj2WSB1HKg8CzAW+gIAXde3YlJPYFmOYA2H2AYMaMUizGfKtqynFhYWqpsFgKYXixOw1aM4LnrNFyv3DkD6O45noCUzol6/CL+wuDQ6ukg35C9fHkylUoNaJnMDJrSdCTEOKXdDyB24nPJ4tmkz9p150/wlvWfDABgqlW5O2/avcbi7yy0WhJgWQvwWq/Vq1FXaunXrMIC5G885ADDuwalMl1vf5Jr2CBzm2cQBwKo/JBqN47DzvMvlKkxhql6r/Wxpaakcp9rn8/niwMDAY4gWR8jluJjFMrTsILThRFIAcDi6H2AC33B5+QpW4Puapv3ENM3FhMNqHubzVYTOJ7EIuQ5HydjTVdN8IqhJBAVgoGAYhOz+TtcsTmFCh6DmF9gGjuHh4RsBwDNYkH0uILxQ1fWH2LlztTgAGMDKv4AX7VHOr0H4b1YqlSm2icMwjMfhI57C/LLKpemKrt/vB4IfABpW/g/qykPlL6c43wd1/yfrg1EsFu+wGo2XoBHXKrzhT+ALX/Iyh5QPufkRkJ1QHnpOZDKfr5bL/2F9Mq5evXopm83+EYd74IeM9dXTtNu25HL66srKdGgNIG+PGP87VfhMJrN7bm5ulvXhGBkZuaa2tvZaBxMV4hGY6nOBAaA4zy3rDB40KKs9Vv6uhbm586yPB7jDTeAM/5DNAXO/mk6ldoAnvNcR2txAIZIjC08ODzZ/X78LTwPR6AORSt2LVV93fhQuLSGec5OXu6j+RAfDg7eHw3vL018YxoYK6vW+hXL5DDLRrymC7kTEeNTTBCixgeM4C+9RkuM87Gdv0MlUTHPDhe/2TsjzIszhPvnWhmVtk6l5uwYgq5OFJ4ZHJCfMZJLWhJDPP0z2L38ducW3XE3AyeeR0rZdBL2NwvCSBIFWG/OiP9H6Aw9wvRcc4CKuH21PTcUhSrI6AKBihpLPV4nbB5lQF3KSFOlhLlWhrlUihO2fUtosOcQ8T6cnOwGw7UnliVNBExs3EIC0owkb7RzVMTs7uww/9nSb4xNisuX/eKuGp5CHOqW0UVQzYcrLotQE6/X6L5zc5WOKeDMc5C5ZAx5Uwt50lHweRCNWnyB/L6rwNBYXF01o+CnF4e9fB8BWMj1kVyd6dVK9ghBSeF/Vgz87oRQxnNCuOXV725Zr7zZiZbHXYqObwARMNy3x4hVeAOB5geyOohxQqLQlgEJcz2nTQkl4zvQqvJ9jDANcL6rfNp9K5Qpy4n8pp+/ktGOj2MZrccfsoCGyCzg9qb5Cel5ve7Cm7eC0XaXcNxOn53ZT+W6aQIDJfz5RRQtiTop2v6v4gXFOe3UKKrECENUx+ql+WOHdFheO8SZOG5VtANTrF5OI4WEmHIfXd9UAIf6raOIIhxro8knasUmSx8chfMTVd7bUFA0ogADyLfLJ1nbVZoIQlyap48qVK0uKRmR5P1VzklJ9z8gAtWirm9NG5Wbk80mqfmsMDQ3lFROw0oj7RHrWt5hol5Y0LcJK+U6wh8ywZ+GbqfCgYgL/ozDYVuKmLeogDtXtnFcNYBNCnls+cL1CzWcpDF5QjGx7D+9wBaGb8H48PwzXDwjAdkUDPuDUkKQEy/Ee39MGgpfwQeYcc0FlXAFkhlM3lhIsPxdkYlE0oYvwws/u4yqvIe3frWjAGQ0PHwMj+lBJhw1khPMxVGe6Oq+gqh9Xyd0wjEG8jNLhtJQb3MipD49a0WTfQG0pQQhJAPsUEa9pMUcRWu27ZeFx4n2natwMD6eUmw+E8S0+mhI2l/cMeVFBQJJ3QPn/L+slMWpCbJsB5/dQT04IahoKBC9QwlaMAhKgAia4VwHg5DoA1IHpNCF+PDJOQ1I4fh4IBB+N0IJGizCOMZ1O057ggKTi5+fL5dfXAXDskTow22PEEWpISgKEsKoftbxGY2xsjFjuEWX1j7d8EJfC37NKuligbqwImVoU4uJLdaNWm1fX1g4r+53LtmUdl8pkHw3qvaX2UwXlJ6nhwCcU9gxCUKoblhIXCoXrYNrfVujvsa67w0Dmx6x9Hy2HkPhM2AmFASEs1VXNwYsbQNWnlIbO+Xq9/sM2QOR/iPxQ763iC+6lVjQ/r6yqYosneAkYlee3hPYSXi8WJ/HwBxQy8F3aJfKL4RzCkIe8U/piDUjuwoTf7qHYIZJKctQxXCrdzizrtFztgu2/NV+tkkwNXxKDyd5iNRrUJPUJ6QGXYE+7qAeH9fHQdf0GQU1SjF0nzX0lxfkdpml2VLx5F9WkHyYcVIoJY3CSr1ArWr8Knx8dLUHNXpGFbzq+Q27COwWgruFjZeXfW3K5YajIZ6X00bAs64vZbPblWq02328rzxuNv2Ghbmsze9s+hgh3NGpay3XDOKk6E6jUh+lUal8vPiF2m7ftl9WVh+96qVKpPKDava8JyLI6XdeMTSvmcC1AeGPYMB7b9JWHt3ccniI8otlfK4XCfi/hgxOWbduyumn+Hj7g/o5Ya9t/xsdhSi03UnCH5CDOd4S61sqT8AHa5VPBAm+lsbq6+jw1HuOFO9U6G9Lnr+RyOcq63l5eXq4nKThx+0w2+3W883k4t0+7LAjZ/Jcx50Dz0CIg/zAo8s/lECkNkxqSqCdHJRy9DkppkdUdZB91gHZw8OavVh6Hzf8qVBISkdTcagnxGy5FCGWsUU9Osy3lVWpOiKjm1Lb3BSpmNPP5AVdHBZKDOP9wt1AXOwAtX0i9t4i732MuP2KSRoM6M6g5obk/P0O7tJR5tvbqaMeGNi2obt8sXY9TARPf+YyPmc4TvQXAx/ycXRIAOAPZok7tp9SB2eWXZLEPSmkpq6PEpldTi42PU/up04Fp2xOIFtsSkVyI81TMoHw+jj6mWAGQn+k0IVIfnm3v7RkMId6nAibV8JplrP788bRXvKbMkhqSqCeH2lKoMwOfJfiCdDOU1nBcob062q6iHRvatMCl00nzi/8Dx0Tcgl7ehnwAAAAASUVORK5CYII=";

var img$4 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/EyXigxSxELFIEcXCoCiIWEkEbaJFEsFXk6x5CHksuxsk2Ao2FoKFaOOr8B9oK9gqCIIiiNj4B3w1EtY72UCCJLPM3o8zcy4zZ8AVzmo5s3UUcnnLiMyF/EvLK37POy58eBhhKq6Z+nx0NkbT8fNIi6oPQdWr+b6Go3M9aWrQ0i48oemGJTwtHN60dMW7wj1aJr4ufCI8bMgBhW+VnnD4TXHa4S/FRiwyAy7V05+u40QdaxkjJzwkHMhli1r1POomXcn8YlRqn8x+TCLMEcJPgiIbZLEISs1LZo19oxXfAgXxaPLXKWGII01GvMOiFqVrUmpK9KR8WUoq9/95mqnxMad7VwjaXm37cwA8+1Des+3fU9sun4H7Ba7zNX9Bcpr8Fn2vpgWOwbsNlzc1LXEAVzvQ+6zHjXhFcst0pVLwcQHdy+C7h45VJ6vqOudPENuSJ7qDwyMYlP3etT9GwWgrP+9tUQAAAAlwSFlzAAALEwAACxMBAJqcGAAACRlJREFUeNrlW1toHFUYnjm7my3rJs3s7DaJ1FoxtMYHS0Wo1fgg6IO9eEH7IJTqS2LVlnoHQRGEgrdijVYxffBWRLFYL7VEBR+s1kLViCAGW6tUsE3c2c092ezsHL9/uklmzs7sJdnZWfFAyXZm9sz5v/9+WVnyeCUSidZcLnctl+U1XJI6ZMO4hDPWgr/LZMYa6BmD86wky0O4Noh7f8iS9KvM+U+MsWPJZPKsl+eTvdg0Foutw587DFnewCTpcqdnDMOQQGDBZ4fnBnDvCDeMg+l0+jgu8boEAEQ3gctdOGg3DrzKC2Cx90kg1QtU9gOMkboAQFGUpTjUw2DLLvCwSarBglSMQX16DF3fMzIykvYLAFmJx7ugq7vxOV7svODcTwDpa3wegJQM8Gz2DOzC2Hhr6xg9ED13rjEQCDTKodAKHGi1xHkHqOwEkWtxO1Bkb82QpCeHNe11ek/NAGhKJC4NGsab+Njp8ogOIvo45++AW18ulEtLly5tBjA3Yp+tAOMmXAq5PPodk+W7YDBPeg4AuH4nz+V6oedRh9tpqEJPNpN5ZXx8PFlNsY9Go/GGhob74C12kclxUIsJSNl2SMMBrwBgMHTP4gCPOLx8Chx4RpblFzVNG/PYrUahPg/AdT4OJkQKDKUk7U1r2sPlqkS5ADTEVJWQ3VJomvkRHGgHxPwPqYarubn5YgDwMhiy2QGEQ2lFuVM6dSpTDQAawPlDeNEG4foMiH80lUr1SD4uVVXvh43Yg/OFhVt9KUW5tRQIpQCQwfn3Rc5D5M8FGNsMcf9eqoMVj8ev1HO5TyERFwpxw0eIF24vpg6BEsHN80C2S9j0FA+Frk8nk79IdbImJyfPhsPhD/FxA+yQOsc9Wb5sSSSiTE9N9VUsAWTt4ePfFYkPhUKdQ0NDg1IdrpaWlmWZmZmjBZEo53dBVd8uGwDy80zX+7FRo1XswflrR4aGTkt1vBA7rETM8K1VHXD2yWAgsBZxwm8Frs0JFApyrMSTwYPO31zvxNOCN/qTBwKbwPU540fuUuf8bSd6mYPodxVEeLD2MHgnitoLVeW1JLTY+0aSyX5kog8KhK6Dx7i3qApQYgPDcRLWI2H189CfjeUeJqVpco2Jl/FOt0TtY6jDzZZLqZyut1tDc7sEIKuzEk8RHgU5lXDCa0lw2L/Y+3aS/lu/jtziMUcVMPN5pLS2mwhvFxLheQVCpfsiBjgDGnbbU1O+g5KsAgComCHk82mK7Uu9xE3kEZzwWhBfSuXgtl+itNliEKMsGOwuBMAwugW56ik3sXE6BJA2D41/vhFPa3BwcAJ2bK/N8HHePWv/2GwNTwgespTSVnJIOgzEzbGS5Rfx88RkXzNzl/kQ8VIYyGusEnCH4Pb6FpLPI9CQq2kTqkE8rbGxMQ0SfkQw+FvmADCETA/Z1YGFcsxNEioFoVrEW/KCA0IRw3Ttslm3Nwxr7d2Ar4wvttjoRAAB4yYlXhI/6+WAQsqWAHJ+EaOmhZDw9C+W+FKGsdbEm99PpUaRE/8gXF7PqGMj6MbRarkuN3Vwc5FeEW9xed/YmC3Laxm1q4TnBqrpv51E3kkSvCY+L92/Cnagg1GvTkClqgCUYxhrQbwTc2EYVzJqVNoAyGbPeBHGVuoivUiq4N3+EiSxhUEMFOtF6th4lciUS5RXGSW11AQJiCEAZEusF2fbVX6B4GU6PTo6Oi5IRJhJ//PFIBa2ujk1Kv2q5HhdT2hqaooKKqAz+H1b0ENdWr+I9xoEoc5JKvAPuUFbiZta1LUk3k3nvQABHL9ICM0HyQ3aKj5mf77GxNeqqAIAVgsS8CejgSTBWXb4wfmF5g4Vrg4BkAFG01iCs7zOL7GvNHeoOA6Q5U5BAvplbN4GpP8W0mEVGeGwX5UcL6JDVVUbsSmlw0FLbnAxozk8GkWz2gYaS/GzjFWtoorA7RutxOPC72bVOO8ejggPb/WLeK/Ka0jytgr//2yuJEZDiDbjwNhNNJPjF/HVdpEIgGLYaKMAwME5AGgC0xxCnF8hcyDJR+JLfb8SwxgMBqkn2GAR8dPDyeQ3cwDQJXMC0+4jdtFAkp/EV8NFtrW10SDVLoH7vVK+XM8s7m+/kC7GaBrLb+IXaxinZ2Z2Cv3OCUPXey1lsvOLZm9p/FRA+XEaOHDb3E0MvUppy6ko28CJxZZDtZ8Qwt99rt1hIPOCZO+jReASXy52IJErXrfHy4kgLaLeIwx0Dmez2edsgFj/Q8EPzd4KtmATjaKVw5VazAaUk0PQUuLxbty8TQgGnqIukZD7FGaN0CuykOstX8wAyWtA7I//hSJHcyKxRtL149ZqF3T/xHA6TTTlXCVg9lkaPDZnb+elIKzncoeL2YN6WYqirAC1hwXipwKMbROJdwNAMqeuGdsuFBPaYCQ/p1G0eiU+2tqagFX+HEQtFwzfDk3THMv9roOS01NTPy+JRJqhI1db0kdV1/VbwuHw4UwmM1xvnGe53Fdg1GU2tTeMffBwu11rBKWqSIqqHhSNCUTq72AgsLlebIKp8yT2Audhuz5NpVK3OYl+URWw0mpOXUtSn6AOFwKEY82qep/vnIe1Nw2eQDy82RepWGxLMeLLkYDzq709rGjae7ABtxb4WsP4BH92UmpZS8LNIAd+vsDVzXKeiC9jXD5QnuNN5aanpz+gwWO8cJ1YZ0P6fE8kEqGs68eJiYmsl4RTbB8Khx/COz+AcbvCgSGk83fjzGWdQ14A8tsQIr8KNbjA4bZGA0k0kyMGHItdlNIiq9sunZ8ALUjV879auR86/0Yl+y4ockMOsErn/C1m8RDCmqGZnPxYypc0nLBAMaexvRuomJHP5xscDRWCHPLzbq6u6gDM2kKavYXffVpy+BGTZeVoMoOGE/L9+QHq0lLmOduro44NNS2obp8vXXdQARPfuaqEmg5TeAuA95Uydl4AYC5EhwqNn9IEpssvyaq+KEqlrI4Sm8WqWtWSFxo/NScwDaML3qLdE8o5P03FDMrnqzHHVFUArHuaQ4g0h2cYGxcNBue/UwGTanj5MlZ9/ni6mL+mzJIGkmgmh8ZSaDIDfxOwBcG8K83gc4p6ddSuoo4NNS1w67jX8cW/7UTXYK9/2wQAAAAASUVORK5CYII=";

var img$3 = "data:image/png;base64,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";

var img$2 = "data:image/png;base64,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";

var img$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAA0dJREFUeNrlWwmO5CAMjBEv2On/v7BnnjDeZhUkixgfQELIIkXqzgG4XD64YKuU1+vF3v9F3Dzl5/vbVX9PewGg+uz9frP3wduxskMVAdHSlgeImgB/vr5MANTqid6OGAoK92GbXLKcGYgwuH7sfH55iZr2a9TrBAmkdjxsrPkYrZ70LLUZBwpes3vUQCjbSv+5zpf05YSkz/JvCYjAPRykdZCcX6vtWjTrqTOeZPtgZMIQQDTFSUwIrdpPlY2IHFqnRxauzrDNKzhKwz2hPFxA/22UL7AI6AVhJgOGULrXVOJoRK8UvhY2c4zXwuQ/BqTcnl53FHB09KCgTDeBGsPOYl5pNuHJmr7ECVobKqnXo+GRoIWRdmUNU/m9VhBGmkeYaecjtcy9Lw2oLgWgFq8/93BPpNjrrDR5ehRwJDBIQDqFlXGG8C3ffDqMwrfQCkLs7fBVmaLSD2wF4w5jAahcbpB306qaDAfi5SZAhfl0SJoqB6pdmt9bTWYTpt1cANxlQLSDAJY5hV1g1TSWHg5z5qL4iQNgkU4rJ9oI2gZrsjEJiEx70VSSj/i8BwcG5I8lBBWAblO0PlJHGYzCl0B0aarQWjVR2jUJLSGucKTDw2BTZrYLBVR4ia4EHI+tm/xEdpKB0z7pJAidw22tYosCOcxkzaT/QrzGM+21IW3WzAVcY4Fi4hFmaN0DAuMzDiXtJ6D7CMIIGq1W6ORvaNDGY0BIV2ik5CNAYBlgsfMngRA4D+9IdJYHIQqJDmSvSUseO5Clp+Fr/5ebQCcLlmZEVHJ+0NYLqT9IbKkx5vYA1BKdJMCoFZ0losCIQc+yJsCxgNuadsMJEbvGSRpsTYQew4LDstgHjOpo8H8p1lQYH6L9w4auYI3nT/P+2a8FxxgcFwcBe0zgUc6Psjw401q8sINn2r5+YOIpcV9TbqD7e5hNhfAAX4CScmNHpbCA3auHt1QnuGJiJAhfPzVGP7ZMRe9bVuCsjY5nCM+xNnidxgIOsSo8e2DCsuQtTILinTQvTOiCeHLUujzV0oCVOT2m5KU9bRM0OjNH1NiGZm21V84LgybX0itDmvCu4bB19+YKiyKS8KWcoNmpkhLjTPpzLCiF1+T4C+eX+V1keq0EAAAAAElFTkSuQmCC";

var img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAaNJREFUeNrlm0sOgzAMRHHEEbj/CbmDq7Ko2opWxBk79pBNuwCTN/4lCshSc+jbfxkxJMXhhzmEAH6IRUjgzTxCBG9iaoXhBSBW+gi4Aq8jbELiebMIQhL2ZhGEBN58rxDBm2wIGXy3LSGE77LZSOEv399I4S8viORm8GlqQDR8qjaYBn5GDZie8zMjIEXOzxIgJXyUAGnhIwRIDe8tQHp4TwFKwHsJUAbeQ4BS8GgBysEjBSgJf2pk27bjd993evjnWL/B7+J5xGaoPPxLAIP3KeCtEUADfxg+8/6fAkgF3xsBdPCnAvzwPiX8Rxsk8Tz8bDAzPOStkdUw8dnwipxf73l7NnjxqgG6+AwFpSKsQDYQQEl49EqwHPw/g8iXEhHwbmsCj91gGfgeAQSYDqneS2oArym4jWqkWM2hZmgV+F8PUcM1iLDXGWnSgMKhcj60RvTsBTwLni6ThjhOxgIf3iHWIFFTwp89VIPAU8BbIqDiV2bDAngfoU8VVYInqdkiKmpTolnTCXEuUBbeskTtTZ30RTRqpZa2eyA/R6FvmZTjAXQIhaMv+ge0AAAAAElFTkSuQmCC";

const html = `
  <div id="main-container" class="hide-previewer disabled" 
    ondragstart="return false;" ondrop="return false;">
    <div id="viewer"></div>
    <div id="previewer"></div>
    <div id="top-panel"> 
      <div class="subpanel panel-item">
        <div id="toggle-previewer" class="panel-button panel-item">
          <img src="${img$a}"/>
        </div> 
      </div>
      <div id="modes" class="subpanel panel-item">
        <div id="button-mode-hand" class="panel-button panel-item">
          <img src="${img$9}"/>
        </div> 
        <div id="button-mode-annotation" class="panel-button panel-item">
          <img src="${img$8}"/>
        </div> 
        <div class="panel-v-separator margin-s-5 panel-item"></div>
        <div id="button-open-file" class="panel-button panel-item">
          <img src="${img$7}"/>
        </div> 
        <div id="button-save-file" class="panel-button panel-item">
          <img src="${img$6}"/>
        </div> 
        <div id="button-close-file" class="panel-button panel-item">
          <img src="${img$3}"/>
        </div> 
      </div>
    </div>
    <div id="bottom-panel">
      <div id="paginator" class="subpanel panel-item">
        <div id="paginator-prev" class="panel-button">
          <img src="${img$g}"/>
        </div>
        <div id="paginator-next" class="panel-button">
          <img src="${img$f}"/>
        </div>
        <input id="paginator-input" type="text">
        <span>&nbsp/&nbsp</span>
        <span id="paginator-total">0</span>
      </div>
      <div class="panel-v-separator panel-item"></div>
      <div id="zoomer" class="subpanel panel-item">
        <div id="zoom-out" class="panel-button">
          <img src="${img$e}"/>
        </div>
        <div id="zoom-in" class="panel-button">
          <img src="${img$d}"/>
        </div>
        <div id="zoom-fit-viewer" class="panel-button">
          <img src="${img$c}"/>
        </div>
        <div id="zoom-fit-image" class="panel-button">
          <img src="${img$b}"/>
        </div>
      </div>
    </div>
    <div id="annotation-panel">
      <div class="annotation-panel-row">
        <div id="button-annotation-delete" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$4}"/>
        </div> 
        <div id="button-annotation-mode-select" 
          class="panel-button annotation-panel-item">
          <img src="${img$1}"/>
        </div> 
      </div>
      <div class="annotation-panel-row">
        <div id="button-annotation-pen-undo" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$2}"/>
        </div> 
        <div id="button-annotation-pen-clear" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$4}"/>
        </div> 
        <div id="button-annotation-pen-save" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$5}"/>
        </div> 
        <div id="button-annotation-mode-pen" 
          class="panel-button annotation-panel-item">
          <img src="${img}"/>
        </div> 
      </div>
    </div>
    <input id="open-file-input" type="file" multiple="true">
  </div>
`;

const styles = `
<style>
  :host {
    --tsimage-color-primary-final: var(--tsimage-color-primary, rgba(40,40,40,1));
    --tsimage-color-primary-tr-final: var(--tsimage-color-primary-tr, rgba(40,40,40,0.9));
    --tsimage-color-secondary-final: var(--tsimage-color-secondary, rgba(60,60,60,1));
    --tsimage-color-secondary-tr-final: var(--tsimage-color-secondary-tr, rgba(60,60,60,0.9));
    --tsimage-color-accent-final: var(--tsimage-color-accent, rgba(96,96,96,1));
    --tsimage-color-shadow-final: var(--tsimage-color-shadow, rgba(0,0,0,0.75));
    --tsimage-color-bg-final: var(--tsimage-color-bg, rgba(128,128,128,1));
    --tsimage-color-fg-primary-final: var(--tsimage-color-fg-primary, rgba(255,255,255,1));
    --tsimage-color-fg-secondary-final: var(--tsimage-color-fg-secondary, rgba(187,187,187,1));
    --tsimage-color-fg-accent-final: var(--tsimage-color-fg-accent, rgba(255,255,255,1));
    --tsimage-color-text-selection-final: var(--tsimage-color-text-selection, rgba(104,104,128,0.3));
  }

  .disabled {
    pointer-events: none;
  }

  .relative {
    position: relative;
  }
  .absolute {
    position: absolute;
  }
  .abs-stretch {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
  }
  .abs-topleft {
    position: absolute;
    left: 0;
    top: 0;
  }
  .stretch {
    width: 100%;
    height: 100%;
  }
  
  .no-margin {
    margin: 0;
  }
  .no-padding {
    padding: 0;
  }
  .margin-s-5 {
    margin: 0 5px;
  }

  #main-container {
    box-sizing: border-box;
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: stretch;
    align-items: stretch;
    width: 100%;
    height: 100%;
    background: var(--tsimage-color-bg-final);
  }

  #top-panel {
    position: relative;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
    width: 100%;
    height: 50px;
    background: var(--tsimage-color-primary-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
    z-index: 1;
    transition: height 0.25s ease-out 0.1s;
  }
  .hide-panels #top-panel {
    height: 0;
    transition: height 0.25s ease-in 0.2s;
  }

  #bottom-panel {
    position: absolute;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    flex-grow: 0;
    flex-shrink: 0;
    left: calc(50% - 160px);
    bottom: 20px;
    width: 320px;
    height: 50px;  
    background: var(--tsimage-color-primary-tr-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
    z-index: 1;
    transition: height 0.25s ease-out, bottom 0.1s linear 0.25s;
  }
  .hide-panels #bottom-panel {
    bottom: 0;
    height: 0;
    transition: bottom 0.1s linear 0.1s, height 0.25s ease-in 0.2s;
  }
  
  #annotation-panel {
    position: absolute;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-end;
    flex-grow: 1;
    flex-shrink: 1;
    top: 80px;
    right: 20px;
    z-index: -5;
    transition: z-index 0s linear 0.25s;
  }
  .mode-annotation #annotation-panel {
    z-index: 1;
  }
  
  .annotation-panel-row {      
      display: flex;
      flex-direction: row;
      justify-content: flex-end;
      align-items: center;
      flex-grow: 1;
      flex-shrink: 1;
    }

  .annotation-panel-item {
    margin: 3px;
    cursor: default;      
    opacity: 0;
    background: var(--tsimage-color-primary-tr-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
    transform: scale(0);
    transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
  }    
  .mode-annotation .annotation-panel-item { 
    cursor: pointer;
    opacity: 100;
    transform: scale(1);    
    transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
  }

  .annotation-panel-subitem {
    margin: 3px;    
    background: var(--tsimage-color-secondary-tr-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
  }  
  :not(.annotation-selected) #button-annotation-delete,
  :not(.pen-path-present) #button-annotation-pen-undo,
  :not(.pen-path-present) #button-annotation-pen-clear,
  :not(.pen-path-present) #button-annotation-pen-save {
    cursor: default;      
    opacity: 0;
    transform: scale(0);
    transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
  }
  .annotation-selected #button-annotation-delete,
  .pen-path-present #button-annotation-pen-undo,
  .pen-path-present #button-annotation-pen-clear,
  .pen-path-present #button-annotation-pen-save { 
    cursor: pointer;
    opacity: 100;
    transform: scale(1);    
    transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
  }

  .panel-v-separator {
    width: 1px;
    height: 30px;
    background-color: var(--tsimage-color-fg-secondary-final);
  }

  .panel-button {
    cursor: pointer;
    user-select: none;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    width: 36px;
    height: 36px;
    border-radius: 50%;
  }
  .panel-button:hover,
  .panel-button.on {
    background-color: var(--tsimage-color-accent-final);
  }
  .panel-button img {
    width: 20px;
    height: 20px;
    filter: invert() opacity(0.5) drop-shadow(0 0 0 var(--tsimage-color-fg-primary-final)) saturate(1000%);
  }  
  .panel-button:hover img,
  .panel-button.on img {
    filter: invert() opacity(0.5) drop-shadow(0 0 0 var(--tsimage-color-fg-accent-final)) saturate(1000%);
  }
  
  .subpanel {
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    margin: 0 4px;
  }    
  
  .panel-item {
    transform: scale(1);
    transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
  }
  .hide-panels .panel-item {
    cursor: default;      
    opacity: 0;
    transform: scale(0);
    transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
  }

  #paginator {  
    user-select: none;
    font-family: sans-serif;
    font-size: 16px;
    color: var(--tsimage-color-fg-primary-final);
  }
  #paginator-input {
    text-align: center; 
    font-size: 16px;
    width: 30px;
    height: 30px;
    margin: 2px;
    padding: 0;
    outline: none;
    border: none;
    color: var(--tsimage-color-fg-primary-final);
    background-color: var(--tsimage-color-primary-final);
  }
  #paginator-total {
    margin: 4px;
  }

  #toggle-previewer {
    margin: 4px;
  }
    
  #previewer {
    box-sizing: border-box;
    position: absolute;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    overflow-y: auto;
    left: 0;
    top: 50px;
    bottom: 0;
    width: 160px; 
    padding-top: 0px;
    background: var(--tsimage-color-secondary-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
    z-index: 1;
    transition: padding-top 0.25s ease-out 0.1s, top 0.25s ease-out 0.1s, width 0.25s ease-out;
  } 
  .hide-panels #previewer {
    top: 0;
    padding-top: 50px;
    transition: padding-top 0.25s ease-in 0.2s, top 0.25s ease-in 0.2s;
  }   
  .mobile #previewer {
    background: var(--tsimage-color-secondary-tr-final);
  } 
  .hide-previewer #previewer {
    width: 0;
    transition: width 0.25s ease-in 0.1s;
  }
  #previewer .image-preview {      
    transform: scaleX(1);
    transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
  }
  .hide-previewer #previewer .image-preview {
    opacity: 0;
    transform: scaleX(0);
    transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
  }

  #viewer {
    box-sizing: border-box;
    position: absolute;
    display: flex;
    flex-direction: column;
    justify-content: center;
    overflow: auto;
    left: 160px;
    right: 0;
    top: 50px;
    bottom: 0;
    padding-top: 0;
    transition: padding-top 0.25s ease-out 0.1s, top 0.25s ease-out 0.1s, left 0.25s ease-out;
  }
  .mode-hand #viewer {
    cursor: grab !important;
    user-select: none !important;
  }
  .hide-panels #viewer {
    top: 0;
    padding-top: 50px;
    transition: padding-top 0.25s ease-in 0.2s, top 0.25s ease-in 0.2s;
  }      
  .hide-panels.mobile #viewer,
  .hide-panels.hide-previewer #viewer {
    top: 0;
    padding-top: 50px;
    left: 0;
    transition: padding-top 0.25s ease-in 0.2s, top 0.25s ease-in 0.2s, left 0.25s ease-in;
  }   
  .mobile #viewer,
  .hide-previewer #viewer {
    top: 50px;
    padding-top: 0px;
    left: 0;
    transition: padding-top 0.25s ease-out 0.1s, top 0.25s ease-out 0.1s, left 0.25s ease-in;
  }
  
  #annotation-overlay-container {
    position: absolute;
    top: 0; 
    right: 0;
    bottom: 0;
    left: 0; 
    margin-top: 0;
    transition: margin-top 0.25s ease-out 0.1s;
  }
  .hide-panels #annotation-overlay-container {
    margin-top: 50px;
    transition: margin-top 0.25s ease-in 0.2s;
  }
  
  #annotation-overlay {
    position: absolute;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    touch-action: none;
  }

  .image {    
    position: relative;
    display: flex;
    flex-grow: 0;
    flex-shrink: 0;
    margin: 10px auto;
    background-color: white;
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
  }
  .image-preview {   
    cursor: pointer; 
    position: relative;
    display: flex;
    flex-grow: 0;
    flex-shrink: 0;
    margin: 0 auto;
    background-color: white;
    background-clip: content-box;
    border-style: solid;
    border-width: 10px 10px 20px 10px;
    border-color: transparent;
  }
  .image-preview:hover,
  .image-preview.current {
    border-color: var(--tsimage-color-accent-final);
  }
  .image-preview::after {
    display: inline-block;
    position: absolute;
    top: calc(100% + 3px);
    width: 100%;
    text-align: center;
    font-family: sans-serif;
    font-size: 14px;
    line-height: 1;
    color: var(--tsimage-color-fg-primary-final);
    content: attr(data-image-index) " ";
  }

  .image-canvas {
    background-color: white;
  } 
  
  .image-text {
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin: 0;
    padding: 0;
    overflow: hidden;
    line-height: 1;
  }
  .image-text span {
    cursor: text;
    position: absolute;
    white-space: pre;
    color: transparent;
    transform-origin: 0% 0%;
  }
  .image-text ::selection {
    background: var(--tsimage-color-text-selection-final);
  }
  .mode-hand .image-text span {
    cursor: grab;
  }
  
  .image-annotations {
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin: 0;
    padding: 0;
    overflow: hidden;
  }
  .mode-text .image-annotations,
  .mode-hand .image-annotations {
    pointer-events: none;
  }
  
  #password-dialog {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: var(--tsimage-color-secondary-tr-final);
    z-index: 2;
  }
  #password-dialog .form {
    position: absolute;
    display: flex;
    flex-direction: row;
    justify-content: stretch;
    align-items: stretch;
    flex-grow: 0;
    flex-shrink: 0;
    left: calc(50% - 160px);
    top: calc(50% - 25px);
    width: 320px;
    height: 50px;  
    background: var(--tsimage-color-primary-tr-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
  }
  #password-dialog input {
    width: 220px;
    margin: 10px 0 10px 10px;
    padding: 5px;
    font-size: 16px;
    outline: none;
    border: none;
    color: var(--tsimage-color-fg-primary-final);
    background-color: var(--tsimage-color-primary-final);
  }
  #password-dialog input::placeholder {
    font-size: 14px;
    font-style: italic;
    color: var(--tsimage-color-fg-primary-final);
  }
  #password-dialog .buttons {
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    flex-grow: 1;
    flex-shrink: 1;
    width: 100px;
  } 

  .svg-annotation {
    cursor: pointer;
  }     
  .out .svg-annotation {
    cursor: not-allowed;
  }
  .svg-annot-rect,
  .svg-annot-box {
    fill: transparent;
  }
  .mode-annotation .svg-annotation.selected {
    cursor: grab;
  } 
  .mode-annotation .svg-annotation.selected .svg-annot-rect,
  .mode-annotation .svg-annotation.selected .svg-annot-box {
    stroke: var(--tsimage-color-secondary-tr-final);
    stroke-dasharray: 3 3;
  } 
  .mode-annotation .svg-annotation.selected .svg-annot-handle-scale,
  .mode-annotation .svg-annotation.selected .svg-annot-handle-rotation {
    r: 8;
    fill: var(--tsimage-color-primary-final);
    cursor: pointer;
  }
  .mode-annotation .svg-annotation.selected .svg-annot-rotation {
    fill: none;
    cursor: pointer;
  }
  .mode-annotation .svg-annotation.selected .svg-annot-rotation .circle {
    r: 25;
  }
  .mode-annotation .svg-annotation.selected .svg-annot-rotation .dashed {
    stroke: var(--tsimage-color-secondary-tr-final);
    stroke-dasharray: 3 3;
  }

  #context-menu {
    box-sizing: border-box;
    position: absolute;
    z-index: 2;
    min-width: 50px;
    min-height: 50px;
    padding: 5px;
    background: var(--tsimage-color-secondary-tr-final);
    box-shadow: 0 0 10px var(--tsimage-color-shadow-final);
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
  }
  .context-menu-content {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-grow: 1;
    flex-shrink: 0;
  }
  .context-menu-content.row {
    flex-direction: row;
  }
  .context-menu-content.column {
    flex-direction: column;
  }
  .context-menu-color-icon {
    width: 20px;
    height: 20px;
    border-radius: 3px;
  }
  .context-menu-stamp-select-button {
    box-sizing: border-box;
    cursor: pointer;
    user-select: none;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-start;
    width: 100%;
    height: 36px;
    padding: 0 5px;
    border-radius: 5px;
    font-family: sans-serif;
    font-size: 16px;
    color: var(--tsimage-color-fg-primary-final); 
  }
  .context-menu-stamp-select-button:hover {
    background-color: var(--tsimage-color-accent-final);
  }
  #open-file-input {
    position: absolute;
    opacity: 0;
    z-index: -10;
  }

  #button-open-file {
    pointer-events: auto !important;
  }
</style>
`;

function getRandomUuid() {
    return v4();
}
function getDistance(x1, y1, x2, y2) {
    return Math.hypot(x2 - x1, y2 - y1);
}

function clamp(v, min, max) {
    return Math.max(min, Math.min(v, max));
}
class Vec2 {
    constructor(x = 0, y = 0) {
        this.length = 2;
        this.x = x;
        this.y = y;
    }
    static multiplyByScalar(v, s) {
        return new Vec2(v.x * s, v.y * s);
    }
    static addScalar(v, s) {
        return new Vec2(v.x + s, v.y + s);
    }
    static normalize(v) {
        return new Vec2().setFromVec2(v).normalize();
    }
    static add(v1, v2) {
        return new Vec2(v1.x + v2.x, v1.y + v2.y);
    }
    static substract(v1, v2) {
        return new Vec2(v1.x - v2.x, v1.y - v2.y);
    }
    static dotProduct(v1, v2) {
        return v1.x * v2.x + v1.y * v2.y;
    }
    static applyMat3(v, m) {
        return v.clone().applyMat3(m);
    }
    static lerp(v1, v2, t) {
        return v1.clone().lerp(v2, t);
    }
    static rotate(v, center, theta) {
        return v.clone().rotate(center, theta);
    }
    static equals(v1, v2, precision = 6) {
        return v1.equals(v2);
    }
    static getDistance(v1, v2) {
        const x = v2.x - v1.x;
        const y = v2.y - v1.y;
        return Math.sqrt(x * x + y * y);
    }
    clone() {
        return new Vec2(this.x, this.y);
    }
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    setFromVec2(vec2) {
        this.x = vec2.x;
        this.y = vec2.y;
        return this;
    }
    multiplyByScalar(s) {
        this.x *= s;
        this.y *= s;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
    }
    getMagnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    normalize() {
        const m = this.getMagnitude();
        if (m) {
            this.x /= m;
            this.y /= m;
        }
        return this;
    }
    add(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    }
    substract(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }
    dotProduct(v) {
        return Vec2.dotProduct(this, v);
    }
    applyMat3(m) {
        if (m.length !== 9) {
            throw new Error("Matrix must contain 9 elements");
        }
        const { x, y } = this;
        const [x_x, x_y, , y_x, y_y, , z_x, z_y,] = m;
        this.x = x * x_x + y * y_x + z_x;
        this.y = x * x_y + y * y_y + z_y;
        return this;
    }
    lerp(v, t) {
        this.x += t * (v.x - this.x);
        this.y += t * (v.y - this.y);
        return this;
    }
    rotate(center, theta) {
        const s = Math.sin(theta);
        const c = Math.cos(theta);
        const x = this.x - center.x;
        const y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
    }
    equals(v, precision = 6) {
        return +this.x.toFixed(precision) === +v.x.toFixed(precision)
            && +this.y.toFixed(precision) === +v.y.toFixed(precision);
    }
    toArray() {
        return [this.x, this.y];
    }
    toIntArray() {
        return new Int32Array(this);
    }
    toFloatArray() {
        return new Float32Array(this);
    }
    *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
    }
}
class Mat3 {
    constructor() {
        this.length = 9;
        this._matrix = new Array(this.length);
        this._matrix[0] = 1;
        this._matrix[1] = 0;
        this._matrix[2] = 0;
        this._matrix[3] = 0;
        this._matrix[4] = 1;
        this._matrix[5] = 0;
        this._matrix[6] = 0;
        this._matrix[7] = 0;
        this._matrix[8] = 1;
    }
    get x_x() {
        return this._matrix[0];
    }
    get x_y() {
        return this._matrix[1];
    }
    get x_z() {
        return this._matrix[2];
    }
    get y_x() {
        return this._matrix[3];
    }
    get y_y() {
        return this._matrix[4];
    }
    get y_z() {
        return this._matrix[5];
    }
    get z_x() {
        return this._matrix[6];
    }
    get z_y() {
        return this._matrix[7];
    }
    get z_z() {
        return this._matrix[8];
    }
    static fromMat3(m) {
        return new Mat3().setFromMat3(m);
    }
    static multiply(m1, m2) {
        const [a11, a12, a13, a21, a22, a23, a31, a32, a33] = m1._matrix;
        const [b11, b12, b13, b21, b22, b23, b31, b32, b33] = m2._matrix;
        const m = new Mat3();
        m.set(a11 * b11 + a12 * b21 + a13 * b31, a11 * b12 + a12 * b22 + a13 * b32, a11 * b13 + a12 * b23 + a13 * b33, a21 * b11 + a22 * b21 + a23 * b31, a21 * b12 + a22 * b22 + a23 * b32, a21 * b13 + a22 * b23 + a23 * b33, a31 * b11 + a32 * b21 + a33 * b31, a31 * b12 + a32 * b22 + a33 * b32, a31 * b13 + a32 * b23 + a33 * b33);
        return m;
    }
    static multiplyScalar(m, s) {
        const res = new Mat3();
        for (let i = 0; i < this.length; i++) {
            res._matrix[i] = m._matrix[i] * s;
        }
        return res;
    }
    static transpose(m) {
        const res = new Mat3();
        res.set(m.x_x, m.y_x, m.z_x, m.x_y, m.y_y, m.z_y, m.x_z, m.y_z, m.z_z);
        return res;
    }
    static invert(m) {
        const mTemp = new Mat3();
        mTemp.set(m.y_y * m.z_z - m.z_y * m.y_z, m.y_x * m.z_z - m.z_x * m.y_z, m.y_x * m.z_y - m.z_x * m.y_y, m.x_y * m.z_z - m.z_y * m.x_z, m.x_x * m.z_z - m.z_x * m.x_z, m.x_x * m.z_y - m.z_x * m.x_y, m.x_y * m.y_z - m.y_y * m.x_z, m.x_x * m.y_z - m.y_x * m.x_z, m.x_x * m.y_y - m.y_x * m.x_y);
        mTemp.set(mTemp.x_x, -mTemp.x_y, mTemp.x_z, -mTemp.y_x, mTemp.y_y, -mTemp.y_z, mTemp.z_x, -mTemp.z_y, mTemp.z_z);
        const det = m.x_x * mTemp.x_x + m.x_y * mTemp.x_y + m.x_z * mTemp.x_z;
        const inversed = new Mat3();
        if (!det) {
            inversed.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        else {
            const detInv = 1 / 10;
            inversed.set(detInv * mTemp.x_x, detInv * mTemp.y_x, detInv * mTemp.z_x, detInv * mTemp.x_y, detInv * mTemp.y_y, detInv * mTemp.z_y, detInv * mTemp.x_z, detInv * mTemp.y_z, detInv * mTemp.z_z);
        }
        return inversed;
    }
    static buildScale(x, y = undefined) {
        y !== null && y !== void 0 ? y : (y = x);
        return new Mat3().set(x, 0, 0, 0, y, 0, 0, 0, 1);
    }
    static buildRotation(theta) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        return new Mat3().set(c, -s, 0, s, c, 0, 0, 0, 1);
    }
    static buildTranslate(x, y) {
        return new Mat3().set(1, 0, 0, 0, 1, 0, x, y, 1);
    }
    static equals(m1, m2, precision = 6) {
        return m1.equals(m2, precision);
    }
    clone() {
        return new Mat3().set(this.x_x, this.x_y, this.x_z, this.y_x, this.y_y, this.y_z, this.z_x, this.z_y, this.z_z);
    }
    set(x_x, x_y, x_z, y_x, y_y, y_z, z_x, z_y, z_z) {
        this._matrix[0] = x_x;
        this._matrix[1] = x_y;
        this._matrix[2] = x_z;
        this._matrix[3] = y_x;
        this._matrix[4] = y_y;
        this._matrix[5] = y_z;
        this._matrix[6] = z_x;
        this._matrix[7] = z_y;
        this._matrix[8] = z_z;
        return this;
    }
    reset() {
        this._matrix[0] = 1;
        this._matrix[1] = 0;
        this._matrix[2] = 0;
        this._matrix[3] = 0;
        this._matrix[4] = 1;
        this._matrix[5] = 0;
        this._matrix[6] = 0;
        this._matrix[7] = 0;
        this._matrix[8] = 1;
        return this;
    }
    setFromMat3(m) {
        for (let i = 0; i < this.length; i++) {
            this._matrix[i] = m._matrix[i];
        }
        return this;
    }
    multiply(m) {
        const [a11, a12, a13, a21, a22, a23, a31, a32, a33] = this._matrix;
        const [b11, b12, b13, b21, b22, b23, b31, b32, b33] = m._matrix;
        this._matrix[0] = a11 * b11 + a12 * b21 + a13 * b31;
        this._matrix[1] = a11 * b12 + a12 * b22 + a13 * b32;
        this._matrix[2] = a11 * b13 + a12 * b23 + a13 * b33;
        this._matrix[3] = a21 * b11 + a22 * b21 + a23 * b31;
        this._matrix[4] = a21 * b12 + a22 * b22 + a23 * b32;
        this._matrix[5] = a21 * b13 + a22 * b23 + a23 * b33;
        this._matrix[6] = a31 * b11 + a32 * b21 + a33 * b31;
        this._matrix[7] = a31 * b12 + a32 * b22 + a33 * b32;
        this._matrix[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
    }
    multiplyScalar(s) {
        for (let i = 0; i < this.length; i++) {
            this._matrix[i] *= s;
        }
        return this;
    }
    transpose() {
        const temp = new Mat3().setFromMat3(this);
        this.set(temp.x_x, temp.y_x, temp.z_x, temp.x_y, temp.y_y, temp.z_y, temp.x_z, temp.y_z, temp.z_z);
        return this;
    }
    invert() {
        const mTemp = new Mat3();
        mTemp.set(this.y_y * this.z_z - this.z_y * this.y_z, this.y_x * this.z_z - this.z_x * this.y_z, this.y_x * this.z_y - this.z_x * this.y_y, this.x_y * this.z_z - this.z_y * this.x_z, this.x_x * this.z_z - this.z_x * this.x_z, this.x_x * this.z_y - this.z_x * this.x_y, this.x_y * this.y_z - this.y_y * this.x_z, this.x_x * this.y_z - this.y_x * this.x_z, this.x_x * this.y_y - this.y_x * this.x_y);
        mTemp.set(mTemp.x_x, -mTemp.x_y, mTemp.x_z, -mTemp.y_x, mTemp.y_y, -mTemp.y_z, mTemp.z_x, -mTemp.z_y, mTemp.z_z);
        const det = this.x_x * mTemp.x_x + this.x_y * mTemp.x_y + this.x_z * mTemp.x_z;
        if (!det) {
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        else {
            const detInv = 1 / 10;
            this.set(detInv * mTemp.x_x, detInv * mTemp.y_x, detInv * mTemp.z_x, detInv * mTemp.x_y, detInv * mTemp.y_y, detInv * mTemp.z_y, detInv * mTemp.x_z, detInv * mTemp.y_z, detInv * mTemp.z_z);
        }
        return this;
    }
    getDeterminant() {
        const [a, b, c, d, e, f, g, h, i] = this._matrix;
        return a * e * i - a * f * h + b * f * g - b * d * i + c * d * h - c * e * g;
    }
    getTRS() {
        const t = new Vec2(this.z_x, this.z_y);
        const s_x = Math.sqrt(this.x_x * this.x_x + this.x_y * this.x_y);
        const s_y = Math.sqrt(this.y_x * this.y_x + this.y_y * this.y_y);
        const s = new Vec2(s_x, s_y);
        const sign = Math.atan(-this.x_y / this.x_x);
        const angle = Math.acos(this.x_x / s_x);
        let r;
        if ((angle > Math.PI / 2 && sign > 0)
            || (angle < Math.PI / 2 && sign < 0)) {
            r = 2 * Math.PI - angle;
        }
        else {
            r = angle;
        }
        return { t, r, s };
    }
    equals(m, precision = 6) {
        for (let i = 0; i < this.length; i++) {
            if (+this._matrix[i].toFixed(precision) !== +m._matrix[i].toFixed(precision)) {
                return false;
            }
        }
        return true;
    }
    applyScaling(x, y = undefined) {
        const m = Mat3.buildScale(x, y);
        return this.multiply(m);
    }
    applyTranslation(x, y) {
        const m = Mat3.buildTranslate(x, y);
        return this.multiply(m);
    }
    applyRotation(theta) {
        const m = Mat3.buildRotation(theta);
        return this.multiply(m);
    }
    toArray() {
        return this._matrix.slice();
    }
    toIntArray() {
        return new Int32Array(this);
    }
    toIntShortArray() {
        return new Int32Array([
            this._matrix[0],
            this._matrix[1],
            this._matrix[3],
            this._matrix[4],
            this._matrix[6],
            this._matrix[7],
        ]);
    }
    toFloatArray() {
        return new Float32Array(this);
    }
    toFloatShortArray() {
        return new Float32Array([
            this._matrix[0],
            this._matrix[1],
            this._matrix[3],
            this._matrix[4],
            this._matrix[6],
            this._matrix[7],
        ]);
    }
    *[Symbol.iterator]() {
        for (let i = 0; i < 9; i++) {
            yield this._matrix[i];
        }
    }
}
function vecMinMax(...values) {
    const min = new Vec2(Math.min(...values.map(x => x.x)), Math.min(...values.map(x => x.y)));
    const max = new Vec2(Math.max(...values.map(x => x.x)), Math.max(...values.map(x => x.y)));
    return { min, max };
}

class ContextMenu {
    constructor() {
        this.onPointerDownOutside = (e) => {
            if (!this._shown) {
                return;
            }
            const target = e.composedPath()[0];
            if (!target.closest("#context-menu")) {
                this.hide();
            }
        };
        this._container = document.createElement("div");
        this._container.id = "context-menu";
        this.hide();
        document.addEventListener("pointerdown", this.onPointerDownOutside);
    }
    set content(value) {
        var _a;
        (_a = this._content) === null || _a === void 0 ? void 0 : _a.remove();
        if (value) {
            this._container.append(value);
            this._content = value;
        }
        else {
            this._content = null;
        }
    }
    destroy() {
        this.clear();
        document.removeEventListener("pointerdown", this.onPointerDownOutside);
    }
    show(pointerPosition, parent) {
        parent.append(this._container);
        this._shown = true;
        setTimeout(() => {
            this.setContextMenuPosition(pointerPosition, parent);
            this._container.style.opacity = "1";
        }, 0);
    }
    hide() {
        this._container.style.opacity = "0";
        this._container.remove();
        this._shown = false;
    }
    clear() {
        this.hide();
        this.content = null;
    }
    setContextMenuPosition(pointerPosition, parent) {
        const menuDimension = new Vec2(this._container.offsetWidth, this._container.offsetHeight);
        const menuPosition = new Vec2();
        const parentRect = parent.getBoundingClientRect();
        const relPointerPosition = new Vec2(pointerPosition.x - parentRect.x, pointerPosition.y - parentRect.y);
        if (relPointerPosition.x + menuDimension.x > parentRect.width + parentRect.x) {
            menuPosition.x = relPointerPosition.x - menuDimension.x;
        }
        else {
            menuPosition.x = relPointerPosition.x;
        }
        if (relPointerPosition.y + menuDimension.y > parentRect.height + parentRect.y) {
            menuPosition.y = relPointerPosition.y - menuDimension.y;
        }
        else {
            menuPosition.y = relPointerPosition.y;
        }
        this._container.style.left = menuPosition.x + "px";
        this._container.style.top = menuPosition.y + "px";
    }
}

class Annotation {
    constructor(dto) {
        this._imageDimensions = new Vec2();
        this._transformationMatrix = new Mat3();
        this._transformationPoint = new Vec2();
        this._currentAngle = 0;
        this._boxX = new Vec2();
        this._boxY = new Vec2();
        this._svgId = getRandomUuid();
        this.onRectPointerDown = (e) => {
            if (!this.translationEnabled || !e.isPrimary) {
                return;
            }
            document.addEventListener("pointerup", this.onRectPointerUp);
            document.addEventListener("pointerout", this.onRectPointerUp);
            this._transformationTimer = setTimeout(() => {
                this._transformationTimer = null;
                this._svg.after(this._svgContentCopy);
                this._transformationPoint.setFromVec2(this.convertClientCoordsToImage(e.clientX, e.clientY));
                document.addEventListener("pointermove", this.onRectPointerMove);
            }, 200);
        };
        this.onRectPointerMove = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const current = this.convertClientCoordsToImage(e.clientX, e.clientY);
            this._transformationMatrix.reset()
                .applyTranslation(current.x - this._transformationPoint.x, current.y - this._transformationPoint.y);
            this._svgContentCopyUse.setAttribute("transform", `matrix(${this._transformationMatrix.toFloatShortArray().join(" ")})`);
        };
        this.onRectPointerUp = (e) => {
            if (!e.isPrimary) {
                return;
            }
            document.removeEventListener("pointermove", this.onRectPointerMove);
            document.removeEventListener("pointerup", this.onRectPointerUp);
            document.removeEventListener("pointerout", this.onRectPointerUp);
            if (this._transformationTimer) {
                clearTimeout(this._transformationTimer);
                this._transformationTimer = null;
                return;
            }
            this._svgContentCopy.remove();
            this._svgContentCopyUse.setAttribute("transform", "matrix(1 0 0 1 0 0)");
            this.applyCommonTransform(this._transformationMatrix);
            this._transformationMatrix.reset();
            this.updateRender();
        };
        this.onRotationHandlePointerDown = (e) => {
            if (!e.isPrimary) {
                return;
            }
            document.addEventListener("pointerup", this.onRotationHandlePointerUp);
            document.addEventListener("pointerout", this.onRotationHandlePointerUp);
            this._transformationTimer = setTimeout(() => {
                this._transformationTimer = null;
                this._svg.after(this._svgContentCopy);
                document.addEventListener("pointermove", this.onRotationHandlePointerMove);
            }, 200);
            e.stopPropagation();
        };
        this.onRotationHandlePointerMove = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const centerX = (this._aabb[0] + this._aabb[2]) / 2;
            const centerY = (this._aabb[1] + this._aabb[3]) / 2;
            const clientCenter = this.convertImageCoordsToClient(centerX, centerY);
            const currentRotation = this.getCurrentRotation();
            const angle = Math.atan2(e.clientY - clientCenter.y, e.clientX - clientCenter.x) + Math.PI / 2 - currentRotation;
            this._currentAngle = angle;
            this._transformationMatrix.reset()
                .applyTranslation(-centerX, -centerY)
                .applyRotation(angle)
                .applyTranslation(centerX, centerY);
            this._svgContentCopyUse.setAttribute("transform", `matrix(${this._transformationMatrix.toFloatShortArray().join(" ")})`);
        };
        this.onRotationHandlePointerUp = (e) => {
            if (!e.isPrimary) {
                return;
            }
            document.removeEventListener("pointermove", this.onRotationHandlePointerMove);
            document.removeEventListener("pointerup", this.onRotationHandlePointerUp);
            document.removeEventListener("pointerout", this.onRotationHandlePointerUp);
            if (this._transformationTimer) {
                clearTimeout(this._transformationTimer);
                this._transformationTimer = null;
                return;
            }
            this._svgContentCopy.remove();
            this._svgContentCopyUse.setAttribute("transform", "matrix(1 0 0 1 0 0)");
            this.applyCommonTransform(this._transformationMatrix);
            this._transformationMatrix.reset();
            this.updateRender();
        };
        this.onScaleHandlePointerDown = (e) => {
            if (!e.isPrimary) {
                return;
            }
            document.addEventListener("pointerup", this.onScaleHandlePointerUp);
            document.addEventListener("pointerout", this.onScaleHandlePointerUp);
            const target = e.target;
            const { ll, lr, ur, ul } = this.getLocalBB();
            const handleName = target.dataset["handleName"];
            switch (handleName) {
                case "ll":
                    this._transformationPoint.setFromVec2(ur);
                    this._boxX.setFromVec2(ul).substract(ur);
                    this._boxY.setFromVec2(lr).substract(ur);
                    break;
                case "lr":
                    this._transformationPoint.setFromVec2(ul);
                    this._boxX.setFromVec2(ur).substract(ul);
                    this._boxY.setFromVec2(ll).substract(ul);
                    break;
                case "ur":
                    this._transformationPoint.setFromVec2(ll);
                    this._boxX.setFromVec2(lr).substract(ll);
                    this._boxY.setFromVec2(ul).substract(ll);
                    break;
                case "ul":
                    this._transformationPoint.setFromVec2(lr);
                    this._boxX.setFromVec2(ll).substract(lr);
                    this._boxY.setFromVec2(ur).substract(lr);
                    break;
                default:
                    throw new Error(`Invalid handle name: ${handleName}`);
            }
            this._boxXLength = this._boxX.getMagnitude();
            this._boxYLength = this._boxY.getMagnitude();
            this._transformationTimer = setTimeout(() => {
                this._transformationTimer = null;
                this._svg.after(this._svgContentCopy);
                document.addEventListener("pointermove", this.onScaleHandlePointerMove);
            }, 200);
            e.stopPropagation();
        };
        this.onScaleHandlePointerMove = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const current = this.convertClientCoordsToImage(e.clientX, e.clientY)
                .substract(this._transformationPoint);
            const currentLength = current.getMagnitude();
            const cos = Math.abs(current.dotProduct(this._boxX)) / currentLength / this._boxXLength;
            const pXLength = cos * currentLength;
            const pYLength = Math.sqrt(currentLength * currentLength - pXLength * pXLength);
            const scaleX = pXLength / this._boxXLength;
            const scaleY = pYLength / this._boxYLength;
            const centerX = (this._aabb[0] + this._aabb[2]) / 2;
            const centerY = (this._aabb[1] + this._aabb[3]) / 2;
            const currentRotation = this.getCurrentRotation();
            this._transformationMatrix.reset()
                .applyTranslation(-centerX, -centerY)
                .applyRotation(-currentRotation)
                .applyScaling(scaleX, scaleY)
                .applyRotation(currentRotation)
                .applyTranslation(centerX, centerY);
            const translation = this._transformationPoint.clone().substract(this._transformationPoint.clone().applyMat3(this._transformationMatrix));
            this._transformationMatrix.applyTranslation(translation.x, translation.y);
            this._svgContentCopyUse.setAttribute("transform", `matrix(${this._transformationMatrix.toFloatShortArray().join(" ")})`);
        };
        this.onScaleHandlePointerUp = (e) => {
            if (!e.isPrimary) {
                return;
            }
            document.removeEventListener("pointermove", this.onScaleHandlePointerMove);
            document.removeEventListener("pointerup", this.onScaleHandlePointerUp);
            document.removeEventListener("pointerout", this.onScaleHandlePointerUp);
            if (this._transformationTimer) {
                clearTimeout(this._transformationTimer);
                this._transformationTimer = null;
                return;
            }
            this._svgContentCopy.remove();
            this._svgContentCopyUse.setAttribute("transform", "matrix(1 0 0 1 0 0)");
            this.applyCommonTransform(this._transformationMatrix);
            this._transformationMatrix.reset();
            this.updateRender();
        };
        this.type = (dto === null || dto === void 0 ? void 0 : dto.annotationType) || "none";
        this.uuid = (dto === null || dto === void 0 ? void 0 : dto.uuid) || getRandomUuid();
        this._imageUuid = dto === null || dto === void 0 ? void 0 : dto.imageUuid;
        this._dateCreated = (dto === null || dto === void 0 ? void 0 : dto.dateCreated)
            ? new Date(dto.dateCreated)
            : new Date();
        this._dateModified = (dto === null || dto === void 0 ? void 0 : dto.dateModified)
            ? new Date(dto.dateModified)
            : new Date();
        this._author = (dto === null || dto === void 0 ? void 0 : dto.author) || "unknown";
        this._aabb = (dto === null || dto === void 0 ? void 0 : dto.rect) || [0, 0, 0, 0];
        if (dto === null || dto === void 0 ? void 0 : dto.bbox) {
            const [a, b, d, e, g, h] = dto.matrix;
            this._matrix = new Mat3().set(a, b, 0, d, e, 0, g, h, 1);
        }
        if (dto === null || dto === void 0 ? void 0 : dto.matrix) {
            const [a, b, d, e, g, h] = dto.matrix;
            this._matrix = new Mat3().set(a, b, 0, d, e, 0, g, h, 1);
        }
        else {
            this._matrix = new Mat3();
        }
    }
    get imageUuid() {
        return this._imageUuid;
    }
    set imageUuid(value) {
        if (value !== this._imageUuid) {
            this._imageUuid = value;
        }
    }
    get deleted() {
        return this._deleted;
    }
    set deleted(value) {
        this._deleted = value;
    }
    get dateCreated() {
        return new Date(this._dateCreated);
    }
    get dateModified() {
        return new Date(this._dateModified);
    }
    get author() {
        return this._author;
    }
    get imageDimensions() {
        return this._imageDimensions;
    }
    set imageDimensions(value) {
        if (value) {
            this._imageDimensions.setFromVec2(value);
        }
        else {
            this.imageDimensions.set(0, 0);
        }
        this.updateRender();
    }
    get lastRenderResult() {
        return this._lastRenderResult;
    }
    render() {
        if (!this._svg) {
            this._svg = this.renderMainElement();
        }
        this.updateRender();
        const renderResult = {
            svg: this._svg,
            clipPaths: this._svgClipPaths,
            tempCopy: this._svgContentCopy,
            tempCopyUse: this._svgContentCopyUse,
        };
        this._lastRenderResult = renderResult;
        return renderResult;
    }
    moveTo(imageX, imageY) {
        const width = this._bb[2] - this._bb[0];
        const height = this._bb[3] - this._bb[1];
        const x = imageX - width / 2;
        const y = imageY - height / 2;
        const mat = Mat3.buildTranslate(x, y);
        this.applyCommonTransform(mat);
    }
    toDto() {
        var _a;
        return {
            annotationType: this.type,
            uuid: this.uuid,
            imageUuid: this.imageUuid,
            dateCreated: this.dateCreated.toISOString(),
            dateModified: this.dateModified.toISOString(),
            author: this.author,
            rect: this._aabb,
            bbox: this._bb,
            matrix: this._matrix.toFloatShortArray(),
            html: (_a = this._svgContent) === null || _a === void 0 ? void 0 : _a.innerHTML,
        };
    }
    getCurrentRotation() {
        const matrix = this._matrix;
        if (!matrix) {
            return 0;
        }
        const { r } = matrix.getTRS();
        return r;
    }
    getLocalBB() {
        let bBoxLL;
        let bBoxLR;
        let bBoxUR;
        let bBoxUL;
        if (this._bb) {
            bBoxLL = new Vec2(this._bb[0], this._bb[1]);
            bBoxLR = new Vec2(this._bb[2], this._bb[3]);
            bBoxUR = new Vec2(this._bb[4], this._bb[5]);
            bBoxUL = new Vec2(this._bb[6], this._bb[7]);
        }
        else {
            bBoxLL = new Vec2(this._aabb[0], this._aabb[1]);
            bBoxLR = new Vec2(this._aabb[2], this._aabb[1]);
            bBoxUR = new Vec2(this._aabb[2], this._aabb[3]);
            bBoxUL = new Vec2(this._aabb[0], this._aabb[3]);
        }
        this._bb = [bBoxLL.x, bBoxLL.y, bBoxLR.x, bBoxLR.y, bBoxUR.x, bBoxUR.y, bBoxUL.x, bBoxUL.y];
        return {
            ll: bBoxLL,
            lr: bBoxLR,
            ur: bBoxUR,
            ul: bBoxUL,
        };
    }
    applyRectTransform(matrix) {
        const bBox = this.getLocalBB();
        bBox.ll.applyMat3(matrix);
        bBox.lr.applyMat3(matrix);
        bBox.ur.applyMat3(matrix);
        bBox.ul.applyMat3(matrix);
        const { min: newRectMin, max: newRectMax } = vecMinMax(bBox.ll, bBox.lr, bBox.ur, bBox.ul);
        this._aabb = [newRectMin.x, newRectMin.y, newRectMax.x, newRectMax.y];
    }
    applyCommonTransform(matrix) {
        this.applyRectTransform(matrix);
        this._dateModified = new Date();
    }
    convertClientCoordsToImage(clientX, clientY) {
        const { x, y, width, height } = this._svgBox.getBoundingClientRect();
        const rectMinScaled = new Vec2(x, y);
        const rectMaxScaled = new Vec2(x + width, y + height);
        const imageScale = (rectMaxScaled.x - rectMinScaled.x) / (this._aabb[2] - this._aabb[0]);
        const imageLowerLeft = new Vec2(x - this._aabb[0] * imageScale, y + height + (this._aabb[1] * imageScale));
        const position = new Vec2((clientX - imageLowerLeft.x) / imageScale, (imageLowerLeft.y - clientY) / imageScale);
        return position;
    }
    convertImageCoordsToClient(imageX, imageY) {
        const { x, y, width, height } = this._svgBox.getBoundingClientRect();
        const rectMinScaled = new Vec2(x, y);
        const rectMaxScaled = new Vec2(x + width, y + height);
        const imageScale = (rectMaxScaled.x - rectMinScaled.x) / (this._aabb[2] - this._aabb[0]);
        const imageLowerLeft = new Vec2(x - this._aabb[0] * imageScale, y + height + (this._aabb[1] * imageScale));
        const position = new Vec2(imageLowerLeft.x + (imageX * imageScale), imageLowerLeft.y - (imageY * imageScale));
        return position;
    }
    renderRect() {
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.classList.add("svg-annot-rect");
        rect.setAttribute("data-annotation-name", this.uuid);
        rect.setAttribute("x", this._aabb[0] + "");
        rect.setAttribute("y", this._aabb[1] + "");
        rect.setAttribute("width", this._aabb[2] - this._aabb[0] + "");
        rect.setAttribute("height", this._aabb[3] - this._aabb[1] + "");
        return rect;
    }
    renderBox() {
        const { ll, lr, ur, ul } = this.getLocalBB();
        const boxPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        boxPath.classList.add("svg-annot-box");
        boxPath.setAttribute("data-annotation-name", this.uuid);
        boxPath.setAttribute("d", `M ${ll.x} ${ll.y} L ${lr.x} ${lr.y} L ${ur.x} ${ur.y} L ${ul.x} ${ul.y} Z`);
        return boxPath;
    }
    renderMainElement() {
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "g");
        rect.classList.add("svg-annotation");
        rect.setAttribute("data-annotation-name", this.uuid);
        rect.addEventListener("pointerdown", this.onRectPointerDown);
        return rect;
    }
    renderContent() {
        return null;
    }
    renderContentCopy() {
        const copy = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        const copyDefs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        const copySymbol = document.createElementNS("http://www.w3.org/2000/svg", "symbol");
        copySymbol.id = this._svgId + "_symbol";
        const copySymbolUse = document.createElementNS("http://www.w3.org/2000/svg", "use");
        copySymbolUse.setAttribute("href", `#${this._svgId}`);
        copySymbolUse.setAttribute("viewBox", `0 0 ${this._imageDimensions.x} ${this._imageDimensions.y}`);
        copySymbol.append(copySymbolUse);
        copyDefs.append(copySymbol);
        const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
        use.setAttribute("href", `#${this._svgId}_symbol`);
        use.setAttribute("opacity", "0.2");
        copy.append(copyDefs, use);
        return { copy, use };
    }
    renderScaleHandles() {
        const bBox = this.getLocalBB();
        const handles = [];
        ["ll", "lr", "ur", "ul"].forEach(x => {
            const handle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            handle.classList.add("svg-annot-handle-scale");
            handle.setAttribute("data-handle-name", x);
            handle.setAttribute("cx", bBox[x].x + "");
            handle.setAttribute("cy", bBox[x].y + "");
            handle.addEventListener("pointerdown", this.onScaleHandlePointerDown);
            handles.push(handle);
        });
        return handles;
    }
    renderRotationHandle() {
        const centerX = (this._aabb[0] + this._aabb[2]) / 2;
        const centerY = (this._aabb[1] + this._aabb[3]) / 2;
        const currentRotation = this.getCurrentRotation();
        const rotationGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        rotationGroup.classList.add("svg-annot-rotation");
        rotationGroup.setAttribute("data-handle-name", "center");
        const rotationGroupCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        rotationGroupCircle.classList.add("circle", "dashed");
        rotationGroupCircle.setAttribute("cx", centerX + "");
        rotationGroupCircle.setAttribute("cy", centerY + "");
        const handleMatrix = new Mat3()
            .applyTranslation(-centerX, -centerY + 35)
            .applyRotation(currentRotation)
            .applyTranslation(centerX, centerY);
        const handleCenter = new Vec2(centerX, centerY).applyMat3(handleMatrix);
        const rotationGroupLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        rotationGroupLine.classList.add("dashed");
        rotationGroupLine.setAttribute("x1", centerX + "");
        rotationGroupLine.setAttribute("y1", centerY + "");
        rotationGroupLine.setAttribute("x2", handleCenter.x + "");
        rotationGroupLine.setAttribute("y2", handleCenter.y + "");
        const centerRectHandle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        centerRectHandle.classList.add("svg-annot-handle-rotation");
        centerRectHandle.setAttribute("data-handle-name", "center");
        centerRectHandle.setAttribute("cx", handleCenter.x + "");
        centerRectHandle.setAttribute("cy", handleCenter.y + "");
        centerRectHandle.addEventListener("pointerdown", this.onRotationHandlePointerDown);
        rotationGroup.append(rotationGroupCircle, rotationGroupLine, centerRectHandle);
        return rotationGroup;
    }
    renderHandles() {
        return [...this.renderScaleHandles(), this.renderRotationHandle()];
    }
    updateRender() {
        this._svg.innerHTML = "";
        const contentResult = this.renderContent();
        if (!contentResult) {
            this._svgBox = null;
            this._svgContent = null;
            this._svgContentCopy = null;
            this._svgContentCopyUse = null;
            this._svgClipPaths = null;
            return;
        }
        const content = contentResult.svg;
        content.id = this._svgId;
        content.classList.add("svg-annotation-content");
        content.setAttribute("data-annotation-name", this.uuid);
        const { copy, use } = this.renderContentCopy();
        const rect = this.renderRect();
        const box = this.renderBox();
        const handles = this.renderHandles();
        this._svg.append(rect, box, contentResult.svg, ...handles);
        this._svgBox = box;
        this._svgContent = content;
        this._svgContentCopy = copy;
        this._svgContentCopyUse = use;
        this._svgClipPaths = contentResult.clipPaths;
    }
}
const annotSelectionRequestEvent = "tsimage-annotselectionrequest";
class AnnotSelectionRequestEvent extends CustomEvent {
    constructor(detail) {
        super(annotSelectionRequestEvent, { detail });
    }
}
const annotChangeEvent = "tsimage-annotchange";
class AnnotEvent extends CustomEvent {
    constructor(detail) {
        super(annotChangeEvent, { detail });
    }
}

class Annotator {
    constructor(parent, imageView) {
        this._scale = 1;
        this.onParentScroll = () => {
            this.refreshViewBox();
        };
        if (!parent || !imageView) {
            throw new Error("Argument is not defined");
        }
        this._parent = parent;
        this._imageView = imageView;
    }
    get scale() {
        return this._scale;
    }
    set scale(value) {
        this._scale = value;
        this.refreshViewBox();
    }
    get overlayContainer() {
        return this._overlayContainer;
    }
    destroy() {
        var _a, _b, _c;
        this._overlayContainer.remove();
        (_a = this._parent) === null || _a === void 0 ? void 0 : _a.removeEventListener("scroll", this.onParentScroll);
        (_b = this._parentMutationObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this._parentResizeObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
    }
    refreshViewBox() {
        const { width: w, height: h } = this._overlay.getBoundingClientRect();
        if (!w || !h) {
            return;
        }
        this._overlay.style.left = this._parent.scrollLeft + "px";
        this._overlay.style.top = this._parent.scrollTop + "px";
        const viewBoxWidth = w / this._scale;
        const viewBoxHeight = h / this._scale;
        this._svgWrapper.setAttribute("viewBox", `0 0 ${viewBoxWidth} ${viewBoxHeight}`);
        this._lastScale = this._scale;
    }
    initObservers() {
        this._parent.addEventListener("scroll", this.onParentScroll);
        const onPossibleViewerSizeChanged = () => {
            if (this._scale === this._lastScale) {
                return;
            }
            this.refreshViewBox();
        };
        const viewerRObserver = new ResizeObserver((entries) => {
            onPossibleViewerSizeChanged();
        });
        const viewerMObserver = new MutationObserver((mutations) => {
            const record = mutations[0];
            if (!record) {
                return;
            }
            record.addedNodes.forEach(x => {
                const element = x;
                if (element.classList.contains("image")) {
                    viewerRObserver.observe(x);
                }
            });
            record.removedNodes.forEach(x => viewerRObserver.unobserve(x));
            onPossibleViewerSizeChanged();
        });
        viewerMObserver.observe(this._parent, {
            attributes: false,
            childList: true,
            subtree: false,
        });
        this._parentMutationObserver = viewerMObserver;
        this._parentResizeObserver = viewerRObserver;
    }
    init() {
        const annotationOverlayContainer = document.createElement("div");
        annotationOverlayContainer.id = "annotation-overlay-container";
        const annotationOverlay = document.createElement("div");
        annotationOverlay.id = "annotation-overlay";
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.classList.add("abs-stretch", "no-margin", "no-padding");
        svg.setAttribute("opacity", "0.75");
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svg.append(g);
        annotationOverlay.append(svg);
        annotationOverlayContainer.append(annotationOverlay);
        this._overlayContainer = annotationOverlayContainer;
        this._overlay = annotationOverlay;
        this._svgWrapper = svg;
        this._svgGroup = g;
        this._parent.append(this._overlayContainer);
        this.refreshViewBox();
        this.initObservers();
    }
    updateImageCoords(clientX, clientY) {
        const imageCoords = this.getImageCoordsUnderPointer(clientX, clientY);
        if (!imageCoords) {
            this._svgGroup.classList.add("out");
        }
        else {
            this._svgGroup.classList.remove("out");
        }
        this._imageCoords = imageCoords;
    }
    getImageCoordsUnderPointer(clientX, clientY) {
        const { left: pxMin, top: pyMin, width: pw, height: ph } = this._imageView.viewContainer.getBoundingClientRect();
        const pxMax = pxMin + pw;
        const pyMax = pyMin + ph;
        if ((clientX < pxMin || clientX > pxMax)
            || (clientY < pyMin || clientY > pyMax)) {
            return null;
        }
        return {
            imageX: (clientX - pxMin) / this._scale,
            imageY: (clientY - pyMin) / this._scale,
        };
    }
}

class PenData {
    constructor(options) {
        this._paths = [];
        this._positionBuffer = [];
        this._options = Object.assign({}, PenData.defaultOptions, options);
        this._group = document.createElementNS("http://www.w3.org/2000/svg", "g");
    }
    get id() {
        return this._options.id;
    }
    get bufferSize() {
        return this._options.bufferSize;
    }
    get strokeWidth() {
        return this._options.strokeWidth;
    }
    get color() {
        return this._options.color.slice();
    }
    get group() {
        return this._group;
    }
    get paths() {
        return this._paths.slice();
    }
    get pathCount() {
        return this._paths.length;
    }
    newPath(startPosition) {
        const [r, g, b, a] = this._options.color || [0, 0, 0, 1];
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", `rgba(${r},${g},${b},${a})`);
        path.setAttribute("stroke-width", this._options.strokeWidth + "");
        const pathString = "M" + startPosition.x + " " + startPosition.y;
        path.setAttribute("d", pathString);
        this._positionBuffer = [startPosition];
        this._currentPath = { path, positions: [new Vec2(startPosition.x, startPosition.y)] };
        this._currentPathString = pathString;
        this._group.append(path);
    }
    endPath() {
        if (this._currentPath && this._currentPath.positions.length > 1) {
            this._paths.push(this._currentPath);
        }
        this._positionBuffer = null;
        this._currentPath = null;
        this._currentPathString = null;
    }
    removePath(path) {
        if (!path) {
            return;
        }
        path.remove();
        this._paths = this._paths.filter(x => x.path !== path);
    }
    removeLastPath() {
        const pathData = this._paths.pop();
        pathData === null || pathData === void 0 ? void 0 : pathData.path.remove();
    }
    addPosition(pos) {
        this.appendPositionToBuffer(pos);
        this.updateCurrentPath();
    }
    setGroupMatrix(matrix) {
        this._group.setAttribute("transform", `matrix(${matrix.join(" ")})`);
    }
    appendPositionToBuffer(pos) {
        const buffer = this._positionBuffer;
        buffer.push(pos);
        this._positionBuffer = buffer
            .slice(Math.max(0, buffer.length - this._options.bufferSize), buffer.length);
    }
    getAveragePosition(offset) {
        const len = this._positionBuffer.length;
        if (len % 2 === 1 || len >= this._options.bufferSize) {
            let totalX = 0;
            let totalY = 0;
            let pos;
            let i;
            let count = 0;
            for (i = offset; i < len; i++) {
                count++;
                pos = this._positionBuffer[i];
                totalX += pos.x;
                totalY += pos.y;
            }
            return new Vec2(totalX / count, totalY / count);
        }
        return null;
    }
    updateCurrentPath() {
        let pos = this.getAveragePosition(0);
        if (pos) {
            this._currentPathString += " L" + pos.x + " " + pos.y;
            this._currentPath.positions.push(pos);
            let tmpPath = "";
            for (let offset = 2; offset < this._positionBuffer.length; offset += 2) {
                pos = this.getAveragePosition(offset);
                tmpPath += " L" + pos.x + " " + pos.y;
            }
            this._currentPath.path.setAttribute("d", this._currentPathString + tmpPath);
        }
    }
    ;
}
PenData.defaultOptions = {
    bufferSize: 8,
    strokeWidth: 3,
    color: [0, 0, 0, 0.5],
};

class PenAnnotation extends Annotation {
    constructor(dto) {
        if (!dto) {
            throw new Error("No source object passed to the constructor");
        }
        if (dto.annotationType !== "pen") {
            throw new Error(`Invalid annotation type: '${dto.annotationType}' (must be 'pen')`);
        }
        super(dto);
        this._pathList = dto.pathList;
        this._strokeColor = dto.strokeColor;
        this._strokeWidth = dto.strokeWidth;
        this._strokeDashGap = dto.strokeDashGap;
    }
    get pathList() {
        return this._pathList;
    }
    get color() {
        return this.color;
    }
    get strokeWidth() {
        return this._strokeWidth;
    }
    get strokeDashGap() {
        return this._strokeDashGap;
    }
    static createFromPenData(data, userName) {
        const positions = [];
        const pathList = [];
        data.paths.forEach(path => {
            const ink = [];
            path.positions.forEach(pos => {
                positions.push(pos);
                ink.push(pos.x, pos.y);
            });
            pathList.push(ink);
        });
        const { min: newRectMin, max: newRectMax } = vecMinMax(...positions);
        const w = data.strokeWidth;
        const rect = [
            newRectMin.x - w / 2,
            newRectMin.y - w / 2,
            newRectMax.x + w / 2,
            newRectMax.y + w / 2,
        ];
        const nowString = new Date().toISOString();
        const dto = {
            uuid: getRandomUuid(),
            annotationType: "pen",
            imageUuid: null,
            dateCreated: nowString,
            dateModified: nowString,
            author: userName || "unknown",
            rect,
            bbox: null,
            matrix: [1, 0, 0, 1, 0, 0],
            html: null,
            pathList,
            strokeColor: data.color,
            strokeWidth: data.strokeWidth,
            strokeDashGap: null,
        };
        return new PenAnnotation(dto);
    }
    toDto() {
        var _a;
        return {
            annotationType: this.type,
            uuid: this.uuid,
            imageUuid: this._imageUuid,
            dateCreated: this._dateCreated.toISOString(),
            dateModified: this._dateModified.toISOString(),
            author: this._author,
            rect: this._aabb,
            bbox: this._bb,
            matrix: this._matrix.toFloatShortArray(),
            html: (_a = this._svgContent) === null || _a === void 0 ? void 0 : _a.innerHTML,
            pathList: this._pathList,
            strokeColor: this._strokeColor,
            strokeWidth: this._strokeWidth,
            strokeDashGap: this._strokeDashGap,
        };
    }
    applyCommonTransform(matrix) {
        let x;
        let y;
        let xMin;
        let yMin;
        let xMax;
        let yMax;
        const vec = new Vec2();
        this._pathList.forEach(list => {
            for (let i = 0; i < list.length; i = i + 2) {
                x = list[i];
                y = list[i + 1];
                vec.set(x, y).applyMat3(matrix);
                list[i] = vec.x;
                list[i + 1] = vec.y;
                if (!xMin || vec.x < xMin) {
                    xMin = vec.x;
                }
                if (!yMin || vec.y < yMin) {
                    yMin = vec.y;
                }
                if (!xMax || vec.x > xMax) {
                    xMax = vec.x;
                }
                if (!yMax || vec.y > yMax) {
                    yMax = vec.y;
                }
            }
        });
        this._aabb = [xMin, yMin, xMax, yMax];
        if (this._bb) {
            const bBox = this.getLocalBB();
            bBox.ll.set(xMin, yMin);
            bBox.lr.set(xMax, yMin);
            bBox.ur.set(xMax, yMax);
            bBox.ul.set(xMin, yMax);
        }
        this._dateModified = new Date();
    }
    renderContent() {
        try {
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.setAttribute("transform", `matrix(${this._matrix.toFloatShortArray().join(" ")})`);
            g.setAttribute("fill", "none");
            g.setAttribute("stroke", `rgba(${this._strokeColor.join(",")})`);
            g.setAttribute("stroke-width", this._strokeWidth + "");
            if (this._strokeDashGap) {
                g.setAttribute("stroke-dasharray", this._strokeDashGap.join(" "));
            }
            for (const pathCoords of this.pathList) {
                if (!(pathCoords === null || pathCoords === void 0 ? void 0 : pathCoords.length)) {
                    continue;
                }
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                let d = `M ${pathCoords[0]} ${pathCoords[1]}`;
                for (let i = 2; i < pathCoords.length;) {
                    d += ` L ${pathCoords[i++]} ${pathCoords[i++]}`;
                }
                path.setAttribute("d", d);
                g.append(path);
            }
            return {
                svg: g,
            };
        }
        catch (e) {
            console.log(`Annotation render error: ${e.message}`);
            return null;
        }
    }
}
const pathChangeEvent = "tsimage-penpathchange";
class PathChangeEvent extends CustomEvent {
    constructor(detail) {
        super(pathChangeEvent, { detail });
    }
}

class PenAnnotator extends Annotator {
    constructor(parent, imageView, color) {
        super(parent, imageView);
        this.onPenPointerDown = (e) => {
            if (!e.isPrimary || e.button === 2) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updateImageCoords(cx, cy);
            const imageCoords = this._imageCoords;
            if (!imageCoords) {
                return;
            }
            const { imageX: px, imageY: py } = imageCoords;
            if (!this._annotationPenData) {
                this.resetTempPenData(this._imageView.imageInfo.uuid);
            }
            this._annotationPenData.newPath(new Vec2(px, py));
            const target = e.target;
            target.addEventListener("pointermove", this.onPenPointerMove);
            target.addEventListener("pointerup", this.onPenPointerUp);
            target.addEventListener("pointerout", this.onPenPointerUp);
            target.setPointerCapture(e.pointerId);
        };
        this.onPenPointerMove = (e) => {
            if (!e.isPrimary || !this._annotationPenData) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updateImageCoords(cx, cy);
            const imageCoords = this._imageCoords;
            if (!imageCoords) {
                return;
            }
            this._annotationPenData.addPosition(new Vec2(imageCoords.imageX, imageCoords.imageY));
        };
        this.onPenPointerUp = (e) => {
            var _a;
            if (!e.isPrimary) {
                return;
            }
            const target = e.target;
            target.removeEventListener("pointermove", this.onPenPointerMove);
            target.removeEventListener("pointerup", this.onPenPointerUp);
            target.removeEventListener("pointerout", this.onPenPointerUp);
            target.releasePointerCapture(e.pointerId);
            (_a = this._annotationPenData) === null || _a === void 0 ? void 0 : _a.endPath();
            this.emitPathCount();
        };
        this.init();
        this._color = color || PenAnnotator.lastColor || [0, 0, 0, 0.9];
        PenAnnotator.lastColor = this._color;
    }
    destroy() {
        this.removeTempPenData();
        super.destroy();
    }
    refreshViewBox() {
        super.refreshViewBox();
        this.updatePenGroupPosition();
    }
    undoPath() {
        var _a;
        (_a = this._annotationPenData) === null || _a === void 0 ? void 0 : _a.removeLastPath();
        this.emitPathCount();
    }
    clearPaths() {
        this.removeTempPenData();
    }
    savePathsAsPenAnnotation(userName) {
        if (!this._annotationPenData) {
            return;
        }
        const imageUuid = this._annotationPenData.id;
        const annotation = PenAnnotation.createFromPenData(this._annotationPenData, userName);
        this.removeTempPenData();
        return { imageUuid, annotation };
    }
    init() {
        super.init();
        this._overlay.addEventListener("pointerdown", this.onPenPointerDown);
    }
    updatePenGroupPosition() {
        if (!this._annotationPenData) {
            return;
        }
        const image = this._imageView;
        if (!image) {
            this._annotationPenData.setGroupMatrix([0, 0, 0, 0, 0, 0]);
        }
        const { height: ph, top: ptop, left: px } = image.viewContainer.getBoundingClientRect();
        const py = ptop + ph;
        const { height: vh, top: vtop, left: vx } = this._overlay.getBoundingClientRect();
        const vy = vtop + vh;
        const offsetX = (px - vx) / this._scale;
        const offsetY = (vy - py) / this._scale;
        this._annotationPenData.setGroupMatrix([1, 0, 0, 1, offsetX, offsetY]);
    }
    removeTempPenData() {
        if (this._annotationPenData) {
            this._annotationPenData.group.remove();
            this._annotationPenData = null;
            this.emitPathCount();
        }
    }
    resetTempPenData(imageUuid) {
        this.removeTempPenData();
        this._annotationPenData = new PenData({ id: imageUuid, color: this._color });
        this._svgGroup.append(this._annotationPenData.group);
        this.updatePenGroupPosition();
    }
    emitPathCount() {
        var _a;
        this._parent.dispatchEvent(new PathChangeEvent({
            pathCount: ((_a = this._annotationPenData) === null || _a === void 0 ? void 0 : _a.pathCount) || 0,
        }));
    }
}

class ImageInfo {
    constructor(image, uuid) {
        this._dimensions = new Vec2();
        this._annotations = [];
        if (!image || !image.complete) {
            throw new Error("Image is not loaded");
        }
        this._uuid = uuid || getRandomUuid();
        this._image = image;
        this._dimensions.set(image.naturalWidth, image.naturalHeight);
    }
    get uuid() {
        return this._uuid;
    }
    get image() {
        return this._image;
    }
    get dimensions() {
        return this._dimensions;
    }
    get annotations() {
        return this._annotations;
    }
}

class ImageAnnotationView {
    constructor(imageInfo) {
        this._rendered = new Set();
        this.onAnnotationSelectionChange = (e) => {
            const annotation = e["detail"].annotation;
            if (annotation) {
                this._container.style.touchAction = "none";
            }
            else {
                this._container.style.touchAction = "";
            }
        };
        if (!imageInfo) {
            throw new Error("Image info is not defined");
        }
        this._imageInfo = imageInfo;
        this._container = document.createElement("div");
        this._container.classList.add("image-annotations");
        this._svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        this._svg.classList.add("stretch");
        this._svg.setAttribute("data-image-id", this._imageInfo.uuid + "");
        const { x, y } = this._imageInfo.dimensions;
        this._svg.setAttribute("viewBox", `0 0 ${x} ${y}`);
        this._svg.addEventListener("pointerdown", () => {
            document.dispatchEvent(new AnnotSelectionRequestEvent({
                annotation: null,
            }));
        });
        this._defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        this._container.append(this._svg);
    }
    destroy() {
        this.remove();
        this._container = null;
        this._destroyed = true;
    }
    remove() {
        var _a;
        (_a = this._container) === null || _a === void 0 ? void 0 : _a.remove();
        document.removeEventListener("annotationselectionchange", this.onAnnotationSelectionChange);
    }
    append(parent) {
        if (this._destroyed) {
            return;
        }
        this.renderAnnotations();
        parent.append(this._container);
        document.addEventListener("annotationselectionchange", this.onAnnotationSelectionChange);
    }
    renderAnnotations() {
        this.clear();
        const annotations = this._imageInfo.annotations || [];
        for (let i = 0; i < annotations.length || 0; i++) {
            const annotation = annotations[i];
            if (annotation.deleted) {
                continue;
            }
            let renderResult;
            if (!this._rendered.has(annotation)) {
                renderResult = annotation.render();
            }
            else {
                renderResult = annotation.lastRenderResult;
            }
            if (!renderResult) {
                continue;
            }
            this._rendered.add(annotation);
            const { svg, clipPaths } = renderResult;
            this._svg.append(svg);
            clipPaths === null || clipPaths === void 0 ? void 0 : clipPaths.forEach(x => this._defs.append(x));
            svg.addEventListener("pointerdown", () => document.dispatchEvent(new AnnotSelectionRequestEvent({ annotation })));
        }
        this._svg.append(this._defs);
        return true;
    }
    clear() {
        this._svg.innerHTML = "";
    }
}

class ImageView {
    constructor(imageInfo, index, previewWidth) {
        if (!imageInfo) {
            throw new Error("Image info is not defined");
        }
        if (isNaN(index)) {
            throw new Error("Index is not defined");
        }
        this.imageInfo = imageInfo;
        this.index = index;
        const { x: width, y: height } = imageInfo.dimensions;
        previewWidth = Math.max(previewWidth !== null && previewWidth !== void 0 ? previewWidth : 0, 50);
        const previewHeight = previewWidth * (height / width);
        this._dimensions = { width, height, previewWidth, previewHeight };
        this._previewContainer = document.createElement("div");
        this._previewContainer.classList.add("image-preview");
        this._previewContainer.setAttribute("data-image-index", this.index + 1 + "");
        this._previewContainer.style.width = this._dimensions.previewWidth + "px";
        this._previewContainer.style.height = this._dimensions.previewHeight + "px";
        this._viewContainer = document.createElement("div");
        this._viewContainer.classList.add("image");
        this._viewContainer.setAttribute("data-image-index", this.index + "");
        this.scale = 1;
    }
    get previewContainer() {
        return this._previewContainer;
    }
    get viewContainer() {
        return this._viewContainer;
    }
    set _viewRendered(value) {
        this.$viewRendered = value;
        this._viewContainer.setAttribute("data-loaded", value + "");
    }
    get _viewRendered() {
        return this.$viewRendered;
    }
    set scale(value) {
        if (value <= 0 || this._scale === value) {
            return;
        }
        this._scale = value;
        const dpr = window.devicePixelRatio;
        this._dimensions.scaledWidth = this._dimensions.width * this._scale;
        this._dimensions.scaledHeight = this._dimensions.height * this._scale;
        this._dimensions.scaledDprWidth = this._dimensions.scaledWidth * dpr;
        this._dimensions.scaledDprHeight = this._dimensions.scaledHeight * dpr;
        this._viewContainer.style.width = this._dimensions.scaledWidth + "px";
        this._viewContainer.style.height = this._dimensions.scaledHeight + "px";
        if (this._viewCanvas) {
            this._viewCanvas.style.width = this._dimensions.scaledWidth + "px";
            this._viewCanvas.style.height = this._dimensions.scaledHeight + "px";
        }
        this._scaleIsValid = false;
    }
    get viewValid() {
        return this._scaleIsValid && this._viewRendered;
    }
    destroy() {
        this._previewContainer.remove();
        this._viewContainer.remove();
    }
    renderPreview(force = false) {
        if (!force && this._previewRendered) {
            return;
        }
        const canvas = this.createPreviewCanvas();
        const ctx = canvas.getContext("2d");
        const { x: imgW, y: imgH } = this.imageInfo.dimensions;
        ctx.drawImage(this.imageInfo.image, 0, 0, imgW, imgH, 0, 0, canvas.width, canvas.height);
        this._previewContainer.innerHTML = "";
        this._previewContainer.append(canvas);
        this._previewRendered = true;
    }
    renderView(force = false) {
        var _a;
        if (!force && this.viewValid) {
            return;
        }
        const scale = this._scale;
        const canvas = this.createViewCanvas();
        const ctx = canvas.getContext("2d");
        const { x: imgW, y: imgH } = this.imageInfo.dimensions;
        ctx.drawImage(this.imageInfo.image, 0, 0, imgW, imgH, 0, 0, canvas.width, canvas.height);
        (_a = this._viewCanvas) === null || _a === void 0 ? void 0 : _a.remove();
        this._viewContainer.append(canvas);
        this._viewCanvas = canvas;
        this._viewRendered = true;
        if (!this._annotationView) {
            this._annotationView = new ImageAnnotationView(this.imageInfo);
        }
        this._annotationView.append(this.viewContainer);
        if (scale === this._scale) {
            this._scaleIsValid = true;
        }
    }
    clearPreview() {
        this._previewContainer.innerHTML = "";
    }
    clearView() {
        var _a, _b;
        (_a = this._annotationView) === null || _a === void 0 ? void 0 : _a.destroy();
        this._annotationView = null;
        (_b = this._viewCanvas) === null || _b === void 0 ? void 0 : _b.remove();
        this._viewRendered = false;
    }
    createPreviewCanvas() {
        const canvas = document.createElement("canvas");
        canvas.classList.add("image-canvas");
        const dpr = window.devicePixelRatio;
        const { previewWidth: width, previewHeight: height } = this._dimensions;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        return canvas;
    }
    createViewCanvas() {
        const canvas = document.createElement("canvas");
        canvas.classList.add("image-canvas");
        canvas.style.width = this._dimensions.scaledWidth + "px";
        canvas.style.height = this._dimensions.scaledHeight + "px";
        canvas.width = this._dimensions.scaledDprWidth;
        canvas.height = this._dimensions.scaledDprHeight;
        return canvas;
    }
}

var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ViewerData {
    constructor(options) {
        this._imageViews = [];
        this.onSelectionRequest = (e) => {
            var _a;
            if ((_a = e.detail) === null || _a === void 0 ? void 0 : _a.annotation) {
                this.selectedAnnotation = e.detail.annotation;
            }
            else {
                this.selectedAnnotation = null;
            }
        };
        this.previewWidth = (options === null || options === void 0 ? void 0 : options.previewWidth) || 50;
        document.addEventListener(annotSelectionRequestEvent, this.onSelectionRequest);
    }
    get imageViews() {
        return this._imageViews;
    }
    get imageCount() {
        return this._imageViews.length;
    }
    get currentImageView() {
        return this._currentImageView;
    }
    get selectedAnnotation() {
        return this._selectedAnnotation;
    }
    set selectedAnnotation(annotation) {
        var _a, _b;
        if (annotation === this._selectedAnnotation) {
            return;
        }
        if (this._selectedAnnotation) {
            this._selectedAnnotation.translationEnabled = false;
            const oldSelectedSvg = (_b = (_a = this._selectedAnnotation) === null || _a === void 0 ? void 0 : _a.lastRenderResult) === null || _b === void 0 ? void 0 : _b.svg;
            oldSelectedSvg === null || oldSelectedSvg === void 0 ? void 0 : oldSelectedSvg.classList.remove("selected");
        }
        const newSelectedSvg = annotation === null || annotation === void 0 ? void 0 : annotation.lastRenderResult.svg;
        if (!newSelectedSvg) {
            this._selectedAnnotation = null;
        }
        else {
            annotation.translationEnabled = true;
            newSelectedSvg.classList.add("selected");
            this._selectedAnnotation = annotation;
        }
        document.dispatchEvent(new AnnotEvent({
            type: "select",
            annotations: this._selectedAnnotation
                ? [this._selectedAnnotation.toDto()]
                : [],
        }));
    }
    destroy() {
        var _a;
        document.removeEventListener(annotSelectionRequestEvent, this.onSelectionRequest);
        (_a = this._imageViews) === null || _a === void 0 ? void 0 : _a.forEach(x => x.destroy());
    }
    addImagesAsync(loadInfos) {
        var _a;
        return __awaiter$1(this, void 0, void 0, function* () {
            if (!(loadInfos === null || loadInfos === void 0 ? void 0 : loadInfos.length)) {
                return;
            }
            for (const info of loadInfos) {
                if (!info || !info.type || !info.data) {
                    console.log("Empty image load info");
                    continue;
                }
                let loadedImage;
                let imageUrl;
                switch (info.type) {
                    case "URL":
                    case "Base64":
                        if (typeof info.data !== "string") {
                            throw new Error(`Invalid data type: ${typeof info.data} (must be string)`);
                        }
                        loadedImage = yield new Promise((resolve, reject) => {
                            const image = new Image();
                            image.onerror = (e) => {
                                console.log(`Error while loading image: ${e}`);
                                resolve(null);
                            };
                            image.onload = () => {
                                resolve(image);
                            };
                            image.src = info.data;
                        });
                        break;
                    case "Blob":
                        if (!(info.data instanceof Blob)) {
                            throw new Error("Invalid data type: must be Blob");
                        }
                        imageUrl = URL.createObjectURL(info.data);
                        loadedImage = yield new Promise((resolve, reject) => {
                            const image = new Image();
                            image.onerror = (e) => {
                                URL.revokeObjectURL(imageUrl);
                                console.log(`Error while loading image: ${e}`);
                                resolve(null);
                            };
                            image.onload = () => {
                                URL.revokeObjectURL(imageUrl);
                                resolve(image);
                            };
                            image.src = imageUrl;
                        });
                        break;
                    case "ByteArray":
                        if (!(info.data instanceof Uint8Array)) {
                            throw new Error("Invalid data type: must be Uint8Array");
                        }
                        if (!((_a = info.data) === null || _a === void 0 ? void 0 : _a.length)) {
                            console.log("Empty image load byte data");
                            continue;
                        }
                        const blob = new Blob([info.data], {
                            type: "application/octet-binary",
                        });
                        imageUrl = URL.createObjectURL(blob);
                        loadedImage = yield new Promise((resolve, reject) => {
                            const image = new Image();
                            image.onerror = (e) => {
                                URL.revokeObjectURL(imageUrl);
                                console.log(`Error while loading image: ${e}`);
                                resolve(null);
                            };
                            image.onload = () => {
                                URL.revokeObjectURL(imageUrl);
                                resolve(image);
                            };
                            image.src = imageUrl;
                        });
                        break;
                    default:
                        throw new Error(`Invalid info type: ${info.type}`);
                }
                if (!loadedImage) {
                    continue;
                }
                const imageInfo = new ImageInfo(loadedImage, info.uuid);
                const view = new ImageView(imageInfo, this._imageViews.length, this.previewWidth);
                this._imageViews.push(view);
            }
            document.dispatchEvent(new ImageEvent({
                type: "add",
                imageViews: [...this._imageViews],
            }));
            if (!this._currentImageView) {
                this.setImageAtIndexAsCurrent(0);
            }
        });
    }
    clearImages() {
        this.selectedAnnotation = null;
        this._currentImageView = null;
        this._imageViews.forEach(x => x.destroy());
        this._imageViews.length = 0;
    }
    setImageAtIndexAsCurrent(index) {
        var _a;
        const imageView = this._imageViews[index];
        if (!imageView || imageView === this._currentImageView) {
            return;
        }
        (_a = this._currentImageView) === null || _a === void 0 ? void 0 : _a.previewContainer.classList.remove("current");
        this._currentImageView = imageView;
        this._currentImageView.previewContainer.classList.add("current");
        document.dispatchEvent(new ImageEvent({
            type: "select",
            imageViews: [this._currentImageView],
        }));
    }
    setPreviousImageAsCurrent() {
        this.setImageAtIndexAsCurrent(this._currentImageView.index - 1);
    }
    setNextImageAsCurrent() {
        this.setImageAtIndexAsCurrent(this._currentImageView.index + 1);
    }
    appendAnnotationToImage(imageUuid, annotation) {
        if (!imageUuid || !annotation) {
            throw new Error("Argument is not defined");
        }
        const image = this._imageViews.find(x => x.imageInfo.uuid === imageUuid);
        if (!image) {
            throw new Error(`Image with uuid '${imageUuid}' is not found`);
        }
        if (image.imageInfo.annotations.find(x => x.uuid === annotation.uuid)) {
            throw new Error(`Image already has the annotation with this uuid: '${imageUuid}'`);
        }
        image.imageInfo.annotations.push(annotation);
        annotation.imageUuid = imageUuid;
        document.dispatchEvent(new AnnotEvent({
            type: "add",
            annotations: [annotation.toDto()],
        }));
    }
    appendSerializedAnnotations(dtos) {
        let annotation;
        for (const dto of dtos) {
            switch (dto.annotationType) {
                case "pen":
                    annotation = new PenAnnotation(dto);
                    break;
                default:
                    throw new Error(`Unsupported annotation type: ${dto.annotationType}`);
            }
            this.appendAnnotationToImage(dto.imageUuid, annotation);
        }
    }
    deleteAnnotation(annotation) {
        if (!annotation) {
            return;
        }
        annotation.deleted = true;
        document.dispatchEvent(new AnnotEvent({
            type: "delete",
            annotations: [annotation.toDto()],
        }));
    }
    deleteSelectedAnnotation() {
        this.deleteAnnotation(this._selectedAnnotation);
    }
    serializeAnnotations(imageUuid) {
        var _a, _b, _c, _d, _e;
        const dtos = [];
        if (imageUuid) {
            for (const imageView of this._imageViews) {
                if (((_a = imageView.imageInfo) === null || _a === void 0 ? void 0 : _a.uuid) === imageUuid) {
                    if ((_c = (_b = imageView.imageInfo) === null || _b === void 0 ? void 0 : _b.annotations) === null || _c === void 0 ? void 0 : _c.length) {
                        dtos.push(...imageView.imageInfo.annotations.map(x => x.toDto()));
                    }
                    break;
                }
            }
        }
        else {
            for (const imageView of this._imageViews) {
                if ((_e = (_d = imageView.imageInfo) === null || _d === void 0 ? void 0 : _d.annotations) === null || _e === void 0 ? void 0 : _e.length) {
                    dtos.push(...imageView.imageInfo.annotations.map(x => x.toDto()));
                }
            }
        }
        return dtos;
    }
    bakeAnnotations(imageUuid) {
        return null;
    }
}
const imageChangeEvent = "tsimage-imagechange";
class ImageEvent extends CustomEvent {
    constructor(detail) {
        super(imageChangeEvent, { detail });
    }
}

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class TsImageViewer {
    constructor(options) {
        this._visibleAdjPreviews = 0;
        this._previewWidth = 100;
        this._minScale = 0.125;
        this._maxScale = 8;
        this._scale = 1;
        this._previewerHidden = true;
        this._pointerInfo = {
            lastPos: null,
            downPos: null,
            downScroll: null,
        };
        this._timers = {
            hidePanels: 0,
        };
        this._pinchInfo = {
            active: false,
            lastDist: 0,
            minDist: 10,
            sensitivity: 0.025,
            target: null,
        };
        this.onFileInput = () => {
            const files = this._fileInput.files;
            if (files.length === 0) {
                return;
            }
            const imageLoadInfos = [];
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const imageLoadInfo = {
                    type: "Blob",
                    data: file,
                };
                imageLoadInfos.push(imageLoadInfo);
            }
            this.openImagesAsync(imageLoadInfos);
        };
        this.onOpenFileButtonClick = () => {
            this._shadowRoot.getElementById("open-file-input").click();
        };
        this.onSaveFileButtonClick = () => {
            const blob = this._viewerData.bakeAnnotations();
            if (!blob) {
                return;
            }
        };
        this.onCloseFileButtonClick = () => {
            this.closeImages();
        };
        this.onPreviewerToggleClick = () => {
            if (this._previewerHidden) {
                this._mainContainer.classList.remove("hide-previewer");
                this._shadowRoot.querySelector("div#toggle-previewer").classList.add("on");
                this._previewerHidden = false;
                setTimeout(() => this.renderVisiblePreviews(), 1000);
            }
            else {
                this._mainContainer.classList.add("hide-previewer");
                this._shadowRoot.querySelector("div#toggle-previewer").classList.remove("on");
                this._previewerHidden = true;
            }
        };
        this.onPreviewerImageClick = (e) => {
            let target = e.target;
            let imageNumber;
            while (target && !imageNumber) {
                const data = target.dataset["imageIndex"];
                if (data) {
                    imageNumber = +data;
                }
                else {
                    target = target.parentElement;
                }
            }
            if (imageNumber) {
                this._viewerData.setImageAtIndexAsCurrent(imageNumber - 1);
            }
        };
        this.onPreviewerScroll = (e) => {
            this.renderVisiblePreviews();
        };
        this.onViewerPointerMove = (event) => {
            const { clientX, clientY } = event;
            const { x: rectX, y: rectY, width, height } = this._viewer.getBoundingClientRect();
            const l = clientX - rectX;
            const t = clientY - rectY;
            const r = width - l;
            const b = height - t;
            if (Math.min(l, r, t, b) > 100) {
                if (!this._panelsHidden && !this._timers.hidePanels) {
                    this._timers.hidePanels = setTimeout(() => {
                        this._mainContainer.classList.add("hide-panels");
                        this._panelsHidden = true;
                        this._timers.hidePanels = null;
                    }, 5000);
                }
            }
            else {
                if (this._timers.hidePanels) {
                    clearTimeout(this._timers.hidePanels);
                    this._timers.hidePanels = null;
                }
                if (this._panelsHidden) {
                    this._mainContainer.classList.remove("hide-panels");
                    this._panelsHidden = false;
                }
            }
            this._pointerInfo.lastPos = new Vec2(clientX, clientY);
        };
        this.onHandModeButtonClick = () => {
            this.setViewerMode("hand");
        };
        this.onAnnotationModeButtonClick = () => {
            this.setViewerMode("annotation");
        };
        this.onViewerScroll = (e) => {
            this._contextMenu.hide();
            this._viewerData.currentImageView.renderView();
        };
        this.onViewerPointerDownScroll = (event) => {
            if (this._viewerMode !== "hand") {
                return;
            }
            const { clientX, clientY } = event;
            this._pointerInfo.downPos = new Vec2(clientX, clientY);
            this._pointerInfo.downScroll = new Vec2(this._viewer.scrollLeft, this._viewer.scrollTop);
            const onPointerMove = (moveEvent) => {
                const { x, y } = this._pointerInfo.downPos;
                const { x: left, y: top } = this._pointerInfo.downScroll;
                const dX = moveEvent.clientX - x;
                const dY = moveEvent.clientY - y;
                this._viewer.scrollTo(left - dX, top - dY);
            };
            const onPointerUp = (upEvent) => {
                this._pointerInfo.downPos = null;
                this._pointerInfo.downScroll = null;
                window.removeEventListener("pointermove", onPointerMove);
                window.removeEventListener("pointerup", onPointerUp);
                window.removeEventListener("pointerout", onPointerUp);
            };
            window.addEventListener("pointermove", onPointerMove);
            window.addEventListener("pointerup", onPointerUp);
            window.addEventListener("pointerout", onPointerUp);
        };
        this.onViewerWheelZoom = (event) => {
            if (!event.ctrlKey) {
                return;
            }
            event.preventDefault();
            if (event.deltaY > 0) {
                this.zoomOut(this._pointerInfo.lastPos);
            }
            else {
                this.zoomIn(this._pointerInfo.lastPos);
            }
        };
        this.onViewerTouchZoom = (event) => {
            if (event.touches.length !== 2) {
                return;
            }
            const a = event.touches[0];
            const b = event.touches[1];
            this._pinchInfo.active = true;
            this._pinchInfo.lastDist = getDistance(a.clientX, a.clientY, b.clientX, b.clientY);
            const onTouchMove = (moveEvent) => {
                if (moveEvent.touches.length !== 2) {
                    return;
                }
                const mA = moveEvent.touches[0];
                const mB = moveEvent.touches[1];
                const dist = getDistance(mA.clientX, mA.clientY, mB.clientX, mB.clientY);
                const delta = dist - this._pinchInfo.lastDist;
                const factor = Math.floor(delta / this._pinchInfo.minDist);
                if (factor) {
                    const center = new Vec2((mB.clientX + mA.clientX) / 2, (mB.clientY + mA.clientY) / 2);
                    this._pinchInfo.lastDist = dist;
                    this.zoom(factor * this._pinchInfo.sensitivity, center);
                }
            };
            const onTouchEnd = (endEvent) => {
                this._pinchInfo.active = false;
                this._pinchInfo.lastDist = 0;
                event.target.removeEventListener("touchmove", onTouchMove);
                event.target.removeEventListener("touchend", onTouchEnd);
                event.target.removeEventListener("touchcancel", onTouchEnd);
            };
            event.target.addEventListener("touchmove", onTouchMove);
            event.target.addEventListener("touchend", onTouchEnd);
            event.target.addEventListener("touchcancel", onTouchEnd);
        };
        this.onZoomOutClick = () => {
            this.zoomOut();
        };
        this.onZoomInClick = () => {
            this.zoomIn();
        };
        this.onZoomFitViewerClick = () => {
            this.zoomFitViewer();
        };
        this.onZoomFitImageClick = () => {
            this.zoomFitImage();
        };
        this.onPaginatorInput = (event) => {
            if (event.target instanceof HTMLInputElement) {
                event.target.value = event.target.value.replace(/[^\d]+/g, "");
            }
        };
        this.onPaginatorChange = (event) => {
            if (event.target instanceof HTMLInputElement) {
                const value = +event.target.value;
                if (!isNaN(value)) {
                    this._viewerData.setImageAtIndexAsCurrent(value - 1);
                }
            }
        };
        this.onPaginatorPrevClick = () => {
            this._viewerData.setPreviousImageAsCurrent();
        };
        this.onPaginatorNextClick = () => {
            this._viewerData.setNextImageAsCurrent();
        };
        this.onImageChange = (e) => {
            if (e.detail.type === "select") {
                const selectedImage = e.detail.imageViews[0];
                this._shadowRoot.getElementById("paginator-input")
                    .value = selectedImage.index + 1 + "";
                selectedImage.scale = this._scale;
                selectedImage.renderView();
                this.scrollToCurrentPreview();
                this._viewer.innerHTML = "";
                this._viewer.append(selectedImage.viewContainer);
                this.zoomFitImage();
                this.setAnnotationMode(this._annotatorMode, true);
            }
        };
        this.onAnnotationDeleteButtonClick = () => {
            this._viewerData.deleteSelectedAnnotation();
        };
        this.onAnnotationSelectModeButtonClick = () => {
            this.setAnnotationMode("select");
        };
        this.onAnnotationPenModeButtonClick = () => {
            this.setAnnotationMode("pen");
        };
        this.onAnnotationChange = (e) => {
            var _a;
            if (!e.detail) {
                return;
            }
            const annotations = e.detail.annotations;
            switch (e.detail.type) {
                case "select":
                    if (annotations === null || annotations === void 0 ? void 0 : annotations.length) {
                        this._mainContainer.classList.add("annotation-selected");
                    }
                    else {
                        this._mainContainer.classList.remove("annotation-selected");
                    }
                    break;
            }
            if (this._annotChangeCallback) {
                this._annotChangeCallback(e.detail);
            }
            if (annotations === null || annotations === void 0 ? void 0 : annotations.length) {
                (_a = this._viewerData.currentImageView) === null || _a === void 0 ? void 0 : _a.renderView(true);
            }
        };
        if (!options) {
            throw new Error("No options provided");
        }
        const container = document.querySelector(options.containerSelector);
        if (!container) {
            throw new Error("Container not found");
        }
        else if (!(container instanceof HTMLDivElement)) {
            throw new Error("Container is not a DIV element");
        }
        else {
            this._outerContainer = container;
        }
        this._userName = options.userName || "Guest";
        this._fileOpenAction = options.fileOpenAction;
        this._fileSaveAction = options.fileSaveAction;
        this._fileCloseAction = options.fileCloseAction;
        this._annotChangeCallback = options.annotChangeCallback;
        this._viewerData = new ViewerData({ previewWidth: this._previewWidth });
        this._shadowRoot = this._outerContainer.attachShadow({ mode: "open" });
        this._shadowRoot.innerHTML = styles + html;
        this.initMainDivs();
        this.initViewControls();
        this.initFileButtons(options.fileButtons || []);
        this.initModeSwitchButtons();
        this.initAnnotationButtons();
        document.addEventListener("tsimage-imagechange", this.onImageChange);
        document.addEventListener("tsimage-annotchange", this.onAnnotationChange);
    }
    static downloadFile(blob, name) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.setAttribute("download", name);
        link.href = url;
        document.body.appendChild(link);
        link.click();
        link.remove();
        setTimeout(() => URL.revokeObjectURL(url), 10000);
    }
    destroy() {
        var _a, _b, _c;
        document.removeEventListener("tsimage-imagechange", this.onImageChange);
        document.removeEventListener("tsimage-annotchange", this.onAnnotationChange);
        this._annotChangeCallback = null;
        (_a = this._annotator) === null || _a === void 0 ? void 0 : _a.destroy();
        this._viewerData.destroy();
        (_b = this._contextMenu) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this._mainContainerRObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
        this._shadowRoot.innerHTML = "";
    }
    openImagesAsync(loadInfos) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._viewerData.addImagesAsync(loadInfos);
            }
            catch (e) {
                throw new Error(`Cannot load file data: ${e.message}`);
            }
            this.refreshImages();
            this.renderVisiblePreviews();
            this._mainContainer.classList.remove("disabled");
        });
    }
    closeImages() {
        this._viewerData.clearImages();
        if (this === null || this === void 0 ? void 0 : this._annotator) {
            this._annotator.destroy();
            this._annotator = null;
        }
        this._mainContainer.classList.add("disabled");
        this.setViewerMode("hand");
        this.setAnnotationMode("select");
        this.refreshImages();
    }
    importAnnotations(dtos) {
        try {
            this._viewerData.appendSerializedAnnotations(dtos);
        }
        catch (e) {
            console.log(`Error while importing annotations: ${e.message}`);
        }
    }
    exportAnnotations(imageUuid) {
        const dtos = this._viewerData.serializeAnnotations(imageUuid);
        return dtos;
    }
    importAnnotationsFromJson(json) {
        try {
            const dtos = JSON.parse(json);
            this._viewerData.appendSerializedAnnotations(dtos);
        }
        catch (e) {
            console.log(`Error while importing annotations: ${e.message}`);
        }
    }
    exportAnnotationsToJson(imageUuid) {
        const dtos = this._viewerData.serializeAnnotations(imageUuid);
        return JSON.stringify(dtos);
    }
    initMainDivs() {
        const mainContainer = this._shadowRoot.querySelector("div#main-container");
        const mcResizeObserver = new ResizeObserver((entries) => {
            var _a;
            const { width } = this._mainContainer.getBoundingClientRect();
            if (width < 721) {
                this._mainContainer.classList.add("mobile");
            }
            else {
                this._mainContainer.classList.remove("mobile");
            }
            this._contextMenu.hide();
            (_a = this._annotator) === null || _a === void 0 ? void 0 : _a.refreshViewBox();
        });
        mcResizeObserver.observe(mainContainer);
        this._mainContainer = mainContainer;
        this._mainContainerRObserver = mcResizeObserver;
        this._previewer = this._shadowRoot.querySelector("#previewer");
        this._viewer = this._shadowRoot.querySelector("#viewer");
        this._contextMenu = new ContextMenu();
        this._viewer.addEventListener("contextmenu", (e) => {
            if (this._contextMenuEnabled) {
                e.preventDefault();
                this._contextMenu.show(new Vec2(e.clientX, e.clientY), this._mainContainer);
            }
        });
    }
    initViewControls() {
        const paginatorInput = this._shadowRoot.getElementById("paginator-input");
        paginatorInput.addEventListener("input", this.onPaginatorInput);
        paginatorInput.addEventListener("change", this.onPaginatorChange);
        this._shadowRoot.querySelector("#paginator-prev")
            .addEventListener("click", this.onPaginatorPrevClick);
        this._shadowRoot.querySelector("#paginator-next")
            .addEventListener("click", this.onPaginatorNextClick);
        this._shadowRoot.querySelector("#zoom-out")
            .addEventListener("click", this.onZoomOutClick);
        this._shadowRoot.querySelector("#zoom-in")
            .addEventListener("click", this.onZoomInClick);
        this._shadowRoot.querySelector("#zoom-fit-viewer")
            .addEventListener("click", this.onZoomFitViewerClick);
        this._shadowRoot.querySelector("#zoom-fit-image")
            .addEventListener("click", this.onZoomFitImageClick);
        this._shadowRoot.querySelector("#toggle-previewer")
            .addEventListener("click", this.onPreviewerToggleClick);
        this._previewer.addEventListener("scroll", this.onPreviewerScroll);
        this._viewer.addEventListener("scroll", this.onViewerScroll);
        this._viewer.addEventListener("wheel", this.onViewerWheelZoom, { passive: false });
        this._viewer.addEventListener("pointermove", this.onViewerPointerMove);
        this._viewer.addEventListener("pointerdown", this.onViewerPointerDownScroll);
        this._viewer.addEventListener("touchstart", this.onViewerTouchZoom);
    }
    initFileButtons(fileButtons) {
        const openButton = this._shadowRoot.querySelector("#button-open-file");
        const saveButton = this._shadowRoot.querySelector("#button-save-file");
        const closeButton = this._shadowRoot.querySelector("#button-close-file");
        if (fileButtons.includes("open")) {
            this._fileInput = this._shadowRoot.getElementById("open-file-input");
            this._fileInput.addEventListener("change", this.onFileInput);
            openButton.addEventListener("click", this._fileOpenAction || this.onOpenFileButtonClick);
        }
        else {
            openButton.remove();
        }
        if (fileButtons.includes("save")) {
            saveButton.addEventListener("click", this._fileSaveAction || this.onSaveFileButtonClick);
        }
        else {
            saveButton.remove();
        }
        if (fileButtons.includes("close")) {
            closeButton.addEventListener("click", this._fileCloseAction || this.onCloseFileButtonClick);
        }
        else {
            closeButton.remove();
        }
    }
    initModeSwitchButtons() {
        this._shadowRoot.querySelector("#button-mode-hand")
            .addEventListener("click", this.onHandModeButtonClick);
        this._shadowRoot.querySelector("#button-mode-annotation")
            .addEventListener("click", this.onAnnotationModeButtonClick);
        this.setViewerMode("hand");
    }
    initAnnotationButtons() {
        this._shadowRoot.querySelector("#button-annotation-mode-select")
            .addEventListener("click", this.onAnnotationSelectModeButtonClick);
        this._shadowRoot.querySelector("#button-annotation-mode-pen")
            .addEventListener("click", this.onAnnotationPenModeButtonClick);
        this._shadowRoot.querySelector("#button-annotation-delete")
            .addEventListener("click", this.onAnnotationDeleteButtonClick);
        this._viewer.addEventListener("tsimage-penpathchange", (e) => {
            if (e.detail.pathCount) {
                this._mainContainer.classList.add("pen-path-present");
            }
            else {
                this._mainContainer.classList.remove("pen-path-present");
            }
        });
        this._shadowRoot.querySelector("#button-annotation-pen-undo")
            .addEventListener("click", () => {
            if (this._annotator instanceof PenAnnotator) {
                this._annotator.undoPath();
            }
        });
        this._shadowRoot.querySelector("#button-annotation-pen-clear")
            .addEventListener("click", () => {
            if (this._annotator instanceof PenAnnotator) {
                this._annotator.clearPaths();
            }
        });
        this._shadowRoot.querySelector("#button-annotation-pen-save")
            .addEventListener("click", () => {
            if (this._annotator instanceof PenAnnotator) {
                const { imageUuid, annotation } = this._annotator.savePathsAsPenAnnotation(this._userName);
                this._viewerData.appendAnnotationToImage(imageUuid, annotation);
            }
        });
    }
    refreshImages() {
        var _a;
        const imageCount = this._viewerData.imageCount;
        this._shadowRoot.getElementById("paginator-total").innerHTML = imageCount + "";
        if (!imageCount) {
            return;
        }
        this._previewer.innerHTML = "";
        for (const imageView of this._viewerData.imageViews) {
            imageView.scale = this._scale;
            imageView.previewContainer.addEventListener("click", this.onPreviewerImageClick);
            this._previewer.append(imageView.previewContainer);
        }
        this._viewer.innerHTML = "";
        this._viewer.append((_a = this._viewerData.currentImageView) === null || _a === void 0 ? void 0 : _a.viewContainer);
    }
    scrollToCurrentPreview() {
        const { top: cTop, height: cHeight } = this._previewer.getBoundingClientRect();
        const { top: pTop, height: pHeight } = this._viewerData.currentImageView
            .previewContainer.getBoundingClientRect();
        const cCenter = cTop + cHeight / 2;
        const pCenter = pTop + pHeight / 2;
        const scroll = pCenter - cCenter + this._previewer.scrollTop;
        this._previewer.scrollTo(0, scroll);
    }
    setViewerMode(mode) {
        if (!mode || mode === this._viewerMode) {
            return;
        }
        this.disableCurrentViewerMode();
        switch (mode) {
            case "hand":
                this._mainContainer.classList.add("mode-hand");
                this._shadowRoot.querySelector("#button-mode-hand").classList.add("on");
                break;
            case "annotation":
                this._mainContainer.classList.add("mode-annotation");
                this._shadowRoot.querySelector("#button-mode-annotation").classList.add("on");
                break;
            default:
                throw new Error(`Invalid viewer mode: ${mode}`);
        }
        this._viewerMode = mode;
    }
    disableCurrentViewerMode() {
        this._contextMenu.clear();
        this._contextMenuEnabled = false;
        switch (this._viewerMode) {
            case "hand":
                this._mainContainer.classList.remove("mode-hand");
                this._shadowRoot.querySelector("#button-mode-hand").classList.remove("on");
                break;
            case "annotation":
                this._mainContainer.classList.remove("mode-annotation");
                this._shadowRoot.querySelector("#button-mode-annotation").classList.remove("on");
                this.setAnnotationMode("select");
                break;
        }
    }
    setScale(scale, cursorPosition) {
        var _a;
        const image = (_a = this === null || this === void 0 ? void 0 : this._viewerData) === null || _a === void 0 ? void 0 : _a.currentImageView;
        if (!scale || scale === this._scale || !image) {
            return;
        }
        cursorPosition || (cursorPosition = this.getViewerCenterPosition());
        let imageUnderCursor;
        let xImageRatio;
        let yImageRatio;
        const { x, y } = cursorPosition;
        const { x: imageX, y: imageY, width: imageWidth, height: imageHeight } = image.viewContainer.getBoundingClientRect();
        if (imageX <= x
            && imageX + imageWidth >= x
            && imageY <= y
            && imageY + imageHeight >= y) {
            imageUnderCursor = true;
            xImageRatio = (x - imageX) / imageWidth;
            yImageRatio = (y - imageY) / imageHeight;
        }
        this._contextMenu.hide();
        this._scale = scale;
        image.scale = scale;
        if (this._annotator) {
            this._annotator.scale = scale;
        }
        if (imageUnderCursor) {
            const { x: imageScaledX, y: imageScaledY, width: imageScaledWidth, height: imageScaledHeight } = image.viewContainer.getBoundingClientRect();
            let scrollLeft;
            let scrollTop;
            if (imageScaledWidth > this._viewer.clientHeight
                || imageScaledHeight > this._viewer.clientWidth) {
                const { x: initialX, y: initialY } = cursorPosition;
                const resultX = imageScaledX + (imageScaledWidth * xImageRatio);
                const resultY = imageScaledY + (imageScaledHeight * yImageRatio);
                scrollLeft = this._viewer.scrollLeft + (resultX - initialX);
                scrollTop = this._viewer.scrollTop + (resultY - initialY);
                scrollLeft = scrollLeft < 0
                    ? 0
                    : scrollLeft;
                scrollTop = scrollTop < 0
                    ? 0
                    : scrollTop;
            }
            else {
                scrollLeft = 0;
                scrollTop = 0;
            }
            if (scrollTop !== this._viewer.scrollTop
                || scrollLeft !== this._viewer.scrollLeft) {
                this._viewer.scrollTo(scrollLeft, scrollTop);
                return;
            }
        }
        setTimeout(() => this._viewerData.currentImageView.renderView(), 0);
    }
    zoom(step, cursorPosition) {
        const scale = clamp(this._scale + step, this._minScale, this._maxScale);
        this.setScale(scale, cursorPosition);
    }
    zoomOut(cursorPosition = null) {
        const scale = this._scale;
        let step;
        if (scale <= 1) {
            step = -0.125;
        }
        else if (scale <= this._maxScale / 2) {
            step = -0.25;
        }
        else {
            step = -0.5;
        }
        this.zoom(step, cursorPosition);
    }
    zoomIn(cursorPosition = null) {
        const scale = this._scale;
        let step;
        if (scale < 1) {
            step = 0.125;
        }
        else if (scale < this._maxScale / 2) {
            step = 0.25;
        }
        else {
            step = 0.5;
        }
        this.zoom(step, cursorPosition);
    }
    zoomFitViewer() {
        const cWidth = this._viewer.getBoundingClientRect().width;
        const iWidth = this._viewerData.currentImageView
            .viewContainer.getBoundingClientRect().width;
        const scale = clamp((cWidth - 20) / iWidth * this._scale, this._minScale, this._maxScale);
        this.setScale(scale);
    }
    zoomFitImage() {
        const { width: cWidth, height: cHeight } = this._viewer.getBoundingClientRect();
        const { width: pWidth, height: pHeight } = this._viewerData.currentImageView
            .viewContainer.getBoundingClientRect();
        const hScale = clamp((cWidth - 20) / pWidth * this._scale, this._minScale, this._maxScale);
        const vScale = clamp((cHeight - 20) / pHeight * this._scale, this._minScale, this._maxScale);
        this.setScale(Math.min(hScale, vScale));
    }
    getViewerCenterPosition() {
        const { x, y, width, height } = this._viewer.getBoundingClientRect();
        return new Vec2(x + width / 2, y + height / 2);
    }
    getVisiblePreviewImages(container, images) {
        const imagesVisible = new Set();
        if (!images.length) {
            return imagesVisible;
        }
        const cRect = container.getBoundingClientRect();
        const cTop = cRect.top;
        const cBottom = cRect.top + cRect.height;
        for (let i = 0; i < images.length; i++) {
            const image = images[i];
            const pRect = image.previewContainer.getBoundingClientRect();
            const pTop = pRect.top;
            const pBottom = pRect.top + pRect.height;
            if (pTop < cBottom && pBottom > cTop) {
                imagesVisible.add(i);
            }
            else if (imagesVisible.size) {
                break;
            }
        }
        return imagesVisible;
    }
    renderVisiblePreviews() {
        if (this._previewerHidden) {
            return;
        }
        const images = this._viewerData.imageViews;
        const visiblePreviewNumbers = this.getVisiblePreviewImages(this._previewer, images);
        const minImageNumber = Math.max(Math.min(...visiblePreviewNumbers) - this._visibleAdjPreviews, 0);
        const maxImageNumber = Math.min(Math.max(...visiblePreviewNumbers) + this._visibleAdjPreviews, images.length - 1);
        for (let i = 0; i < images.length; i++) {
            const image = images[i];
            if (i >= minImageNumber && i <= maxImageNumber) {
                image.renderPreview();
            }
        }
    }
    setAnnotationMode(mode, forceReset = false) {
        var _a;
        if (!mode || ((mode === this._annotatorMode) && !forceReset)) {
            return;
        }
        this._contextMenu.clear();
        this._contextMenuEnabled = false;
        (_a = this._annotator) === null || _a === void 0 ? void 0 : _a.destroy();
        this._annotator = null;
        switch (this._annotatorMode) {
            case "select":
                this._shadowRoot.querySelector("#button-annotation-mode-select").classList.remove("on");
                this._viewerData.selectedAnnotation = null;
                break;
            case "pen":
                this._shadowRoot.querySelector("#button-annotation-mode-pen").classList.remove("on");
                break;
        }
        this._annotatorMode = mode;
        switch (mode) {
            case "select":
                this._shadowRoot.querySelector("#button-annotation-mode-select").classList.add("on");
                break;
            case "pen":
                this._shadowRoot.querySelector("#button-annotation-mode-pen").classList.add("on");
                this._annotator = new PenAnnotator(this._viewer, this._viewerData.currentImageView);
                this._annotator.scale = this._scale;
                this.initContextPenColorPicker();
                break;
            default:
                throw new Error(`Invalid annotation mode: ${mode}`);
        }
    }
    initContextPenColorPicker() {
        const colors = [
            [0, 0, 0, 0.9],
            [205, 0, 0, 0.9],
            [0, 205, 0, 0.9],
            [0, 0, 205, 0.9],
        ];
        const contextMenuContent = document.createElement("div");
        contextMenuContent.classList.add("context-menu-content", "row");
        colors.forEach(x => {
            const item = document.createElement("div");
            item.classList.add("panel-button");
            item.addEventListener("click", () => {
                var _a;
                this._contextMenu.hide();
                (_a = this._annotator) === null || _a === void 0 ? void 0 : _a.destroy();
                this._annotator = new PenAnnotator(this._viewer, this._viewerData.currentImageView, x);
                this._annotator.scale = this._scale;
            });
            const colorIcon = document.createElement("div");
            colorIcon.classList.add("context-menu-color-icon");
            colorIcon.style.backgroundColor = `rgb(${x[0] * 255},${x[1] * 255},${x[2] * 255})`;
            item.append(colorIcon);
            contextMenuContent.append(item);
        });
        this._contextMenu.content = contextMenuContent;
        this._contextMenuEnabled = true;
    }
}

export { AnnotEvent, TsImageViewer };
